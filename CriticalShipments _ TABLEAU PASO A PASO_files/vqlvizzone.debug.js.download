/*! BEGIN VizZone */

(function() {
	'dont use strict';
	var $asm = {};
	global.tab = global.tab || {};
	ss.initAssembly($asm, 'vqlvizzone');
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.ContextStatePreserver
	var $tab_$ContextStatePreserver = function(context) {
		this.$alpha = 0;
		this.$lineWidth = 0;
		this.$linePattern = null;
		this.$lineJoin = null;
		this.$lineCap = null;
		this.$strokeStyle = null;
		this.$shapeFillStyle = null;
		this.$textFillStyle = null;
		this.$textAngle = 0;
		this.$font = null;
		this.$textAlign = null;
		this.$alpha = context.get_alpha();
		this.$lineJoin = context.get_lineJoin();
		this.$lineCap = context.get_lineCap();
		this.$linePattern = context.get_linePattern();
		this.$strokeStyle = context.get_strokeStyle();
		this.$lineWidth = context.get_lineWidth();
		this.$textAngle = context.get_textAngle();
		this.$font = context.get_font();
		this.$shapeFillStyle = context.get_shapeFillStyle();
		this.$textFillStyle = context.get_textFillStyle();
		this.$textAlign = context.get_textAlign();
	};
	$tab_$ContextStatePreserver.__typeName = 'tab.$ContextStatePreserver';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.DownloadWorker
	var $tab_$DownloadWorker = function(id) {
		this.$id = 0;
		this.$timeoutID = -1;
		this.$imageData = null;
		this.$completed = true;
		this.$1$DoneField = null;
		this.$1$TimedOutField = null;
		this.$id = id;
		this.$timeoutID = -1;
		this.$completed = true;
	};
	$tab_$DownloadWorker.__typeName = 'tab.$DownloadWorker';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.GroupStatePreserver
	var $tab_$GroupStatePreserver = function(state) {
		this.$shapeFillStyle = null;
		this.$textFillStyle = null;
		this.$state = null;
		this.$hasPreservedState = false;
		this.$state = state;
		this.$hasPreservedState = this.$state === 'selected' || this.$state === 'highlighted' || this.$state === 'hover';
	};
	$tab_$GroupStatePreserver.__typeName = 'tab.$GroupStatePreserver';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.LeafletMapControl.LocalMapData
	var $tab_$LeafletMapControl$LocalMapData = function(center, zoomLevel) {
		this.$1$CenterField = null;
		this.$1$ZoomLevelField = 0;
		this.set_$center(center);
		this.set_$zoomLevel(zoomLevel);
	};
	$tab_$LeafletMapControl$LocalMapData.__typeName = 'tab.$LeafletMapControl$LocalMapData';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.LeafletMapTemplate
	var $tab_$LeafletMapTemplate = function() {
		this.$leftBarnDoor = null;
		this.$rightBarnDoor = null;
		this.$mapHolder = null;
		spiff.Template.call(this, $($tab_$LeafletMapTemplate.$htmlTemplate));
		this.$leftBarnDoor = this.getElementBySelector('.tabLeftBarnDoor');
		this.$rightBarnDoor = this.getElementBySelector('.tabRightBarnDoor');
		this.$mapHolder = this.getElementBySelector('.tabLeafletMapHolder');
		var barnDoorDict = ss.mkdict(['position', 'absolute', 'top', '0px', 'bottom', '0px']);
		this.$leftBarnDoor.css(barnDoorDict);
		this.$rightBarnDoor.css(barnDoorDict);
		this.$leftBarnDoor.css('left', '0px');
		this.$rightBarnDoor.css('right', '0px');
		if (BrowserSupport.BrowserSupport.IsIE()) {
			this.$leftBarnDoor.css('z-index', '10');
			this.$rightBarnDoor.css('z-index', '10');
		}
	};
	$tab_$LeafletMapTemplate.__typeName = 'tab.$LeafletMapTemplate';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.MapboxMapControl.LocalMapData
	var $tab_$MapboxMapControl$LocalMapData = function(center, zoomLevel) {
		this.$1$CenterField = null;
		this.$1$ZoomLevelField = 0;
		this.set_$center(center);
		this.set_$zoomLevel(zoomLevel);
	};
	$tab_$MapboxMapControl$LocalMapData.__typeName = 'tab.$MapboxMapControl$LocalMapData';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.MapControlEventProperty
	var $tab_$MapControlEventProperty = function() {
	};
	$tab_$MapControlEventProperty.__typeName = 'tab.$MapControlEventProperty';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.MapsSearchViewTemplate
	var $tab_$MapsSearchViewTemplate = function() {
		this.$mapsSearchViewRootElement = null;
		spiff.Template.call(this, $($tab_$MapsSearchViewTemplate.$htmlTemplate));
		this.$mapsSearchViewRootElement = this.getElementBySelector('.tabMapsSearchView');
	};
	$tab_$MapsSearchViewTemplate.__typeName = 'tab.$MapsSearchViewTemplate';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.PaneDrawInfo.WorldAndInstanceOffsets
	var $tab_$PaneDrawInfo$WorldAndInstanceOffsets = function(worldOffsets, instanceOffsets) {
		this.$worldOffsets = null;
		this.$instanceOffsets = null;
		this.$worldOffsets = worldOffsets;
		this.$instanceOffsets = instanceOffsets;
	};
	$tab_$PaneDrawInfo$WorldAndInstanceOffsets.__typeName = 'tab.$PaneDrawInfo$WorldAndInstanceOffsets';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableCornersRenderer
	var $tab_$PaneTableCornersRenderer = function() {
		this.$regionImages = [];
	};
	$tab_$PaneTableCornersRenderer.__typeName = 'tab.$PaneTableCornersRenderer';
	$tab_$PaneTableCornersRenderer.$redrawCorners = function PaneTableCornersRenderer$RedrawCorners(geom, paneTableVM, dom) {
		if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
			return;
		}
		var backgroundVlvm = paneTableVM.get_vizRegionMap()['background'];
		if (ss.isNullOrUndefined(backgroundVlvm) || ss.isNullOrUndefined(backgroundVlvm.get_visualListPM().drawItems)) {
			return;
		}
		var backgroundDisplayList = backgroundVlvm.get_visualListPM().drawItems;
		var regionRects = {};
		var len = geom.ri.length;
		for (var i = 0; i < len; i++) {
			var r = geom.ri[i];
			regionRects[r.r] = r;
		}
		var imageDict = null;
		if (ss.isValue(paneTableVM) && ss.isValue(paneTableVM.get_scene())) {
			imageDict = paneTableVM.get_scene().get_imageDictionary();
		}
		var pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
		var backgroundColor = paneTableVM.get_visualModel().get_backgroundColor();
		var cornerRegions = [{ name: 'uleft'.toString(), node: dom.topLeftSpacer }, { name: 'uright'.toString(), node: dom.topRightSpacer }, { name: 'lleft'.toString(), node: dom.bottomLeftSpacer }, { name: 'lright'.toString(), node: dom.bottomRightSpacer }];
		for (var $t1 = 0; $t1 < cornerRegions.length; $t1++) {
			var cornerRegion = cornerRegions[$t1];
			var r1 = regionRects[cornerRegion.name];
			if (ss.isNullOrUndefined(r1)) {
				continue;
			}
			var cornerNode = cornerRegion.node;
			var childNode = cornerNode.get(0).firstChild;
			var canvasElement = ss.safeCast(childNode, ss.isValue(childNode) && (ss.isInstanceOfType(childNode, Element) && childNode.tagName === 'CANVAS'));
			if (ss.isNullOrUndefined(canvasElement)) {
				continue;
			}
			$tab_$PaneTableCornersRenderer.$renderCornerToCanvas(canvasElement, backgroundColor, pixelRatio, r1, backgroundDisplayList, imageDict);
		}
	};
	$tab_$PaneTableCornersRenderer.$renderCornerToCanvas = function PaneTableCornersRenderer$RenderCornerToCanvas(canvasElt, backgroundColor, pixelRatio, r, backgroundDisplayList, imageDict) {
		var backgroundMode = (backgroundColor.get_isOpaque() ? 'opaque' : 'transparent');
		var context = tab.CanvasRenderer.getRenderContext(canvasElt, backgroundMode);
		context.clearRect(0, 0, canvasElt.width, canvasElt.height);
		context.set_shapeFillStyle(backgroundColor.toString());
		context.fillRect(0, 0, canvasElt.width, canvasElt.height);
		context.setDefaultPropertyValues();
		if (!tab.DoubleUtil.isApproximatelyEqual(pixelRatio, 1)) {
			tab.CanvasUtil.scaleCanvasDrawing(context, pixelRatio);
		}
		var $t1 = new $tab_DisplayList2DRenderer(canvasElt, context, $tab_InteractionColorModel.defaultColors);
		$t1.set_renderOffset({ x: r.x, y: r.y });
		var cornerRenderer = $t1;
		cornerRenderer.renderDrawItems(backgroundDisplayList, null, imageDict, null);
	};
	$tab_$PaneTableCornersRenderer.$ensureFirstChildIsGivenTag = function PaneTableCornersRenderer$EnsureFirstChildIsGivenTag(cornerNode, tagName) {
		var childNode = ss.cast(cornerNode.get(0).firstChild, HTMLElement);
		if (!(ss.compareStrings(childNode.tagName, tagName, true) === 0)) {
			childNode = document.createElement(tagName);
			cornerNode.children().first().replaceWith(childNode);
		}
		return childNode;
	};
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.TargetObject
	var $tab_$TargetObject = function(state) {
		this.$targetType = null;
		this.$targetState = null;
		this.$hasValidId = false;
		this.$id = 0;
		this.$invalidationRects = null;
		this.$targetState = state;
		this.$hasValidId = false;
		this.$id = 0;
	};
	$tab_$TargetObject.__typeName = 'tab.$TargetObject';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VersionedImageElement
	var $tab_$VersionedImageElement = function() {
		this.$elt = null;
		this.$cacheVersion = 0;
		this.$cacheVersion = -1;
	};
	$tab_$VersionedImageElement.__typeName = 'tab.$VersionedImageElement';
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.AnnotationDragHandler
	var $tab_AnnotationDragHandler = function(vm) {
		this.$movingAnnotation = null;
		this.dragType = 0;
		this.visualId = null;
		this.dragDictionary = null;
		this.dragOffset = null;
		this.vizRegion = null;
		this.scrollOffset = null;
		this.$annotationShadow = new $tab_AnnotationShadow();
		this.$movingAnnotation = null;
		this.dragType = 0;
		this.visualId = vm.visualId;
		this.dragDictionary = null;
		this.dragOffset = { x: 0, y: 0 };
		this.vizRegion = { x: 0, y: 0, w: 0, h: 0 };
		this.scrollOffset = { x: 0, y: 0 };
	};
	$tab_AnnotationDragHandler.__typeName = 'tab.AnnotationDragHandler';
	$tab_AnnotationDragHandler.getBestConnectionPoint = function AnnotationDragHandler$GetBestConnectionPoint(cursorPosition, annotation) {
		var annotationCenter = tab.RectXYUtil.getCenter(annotation);
		var left = annotation.x;
		var right = annotation.x + annotation.w;
		var top = annotation.y;
		var bottom = annotation.y + annotation.h;
		var centerX = annotationCenter.x;
		var centerY = annotationCenter.y;
		var cursorIsDirectlyNorth = cursorPosition.x >= left && cursorPosition.x <= right && cursorPosition.y <= top;
		var cursorIsDirectlySouth = cursorPosition.x >= left && cursorPosition.x <= right && cursorPosition.y >= bottom;
		var cursorIsDirectlyWest = cursorPosition.y >= top && cursorPosition.y <= bottom && cursorPosition.x <= left;
		var topLeftDiff = tab.PointUtil.subtract(cursorPosition, { x: left, y: top });
		var topRightDiff = tab.PointUtil.subtract(cursorPosition, { x: right, y: top });
		var bottomLeftDiff = tab.PointUtil.subtract(cursorPosition, { x: left, y: bottom });
		var bottomRightDiff = tab.PointUtil.subtract(cursorPosition, { x: right, y: bottom });
		if (cursorIsDirectlyNorth || -topLeftDiff.y >= Math.abs(topLeftDiff.x) || -topRightDiff.y > Math.abs(topRightDiff.x)) {
			return { x: centerX, y: top };
		}
		if (cursorIsDirectlySouth || bottomLeftDiff.y >= Math.abs(bottomLeftDiff.x) || bottomRightDiff.y > Math.abs(bottomRightDiff.x)) {
			return { x: centerX, y: bottom };
		}
		if (cursorIsDirectlyWest || Math.abs(topLeftDiff.y) <= -topLeftDiff.x || Math.abs(bottomLeftDiff.y) < -bottomLeftDiff.x) {
			return { x: left, y: centerY };
		}
		return { x: right, y: centerY };
	};
	global.tab.AnnotationDragHandler = $tab_AnnotationDragHandler;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.AnnotationDragType
	var $tab_AnnotationDragType = function() {
	};
	$tab_AnnotationDragType.__typeName = 'tab.AnnotationDragType';
	global.tab.AnnotationDragType = $tab_AnnotationDragType;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.AnnotationHitTestLink
	var $tab_AnnotationHitTestLink = function(ptvm) {
		this.$hitTestStructureList = null;
		$tab_HitTestLink.call(this, ptvm);
	};
	$tab_AnnotationHitTestLink.__typeName = 'tab.AnnotationHitTestLink';
	$tab_AnnotationHitTestLink.getHitTestResult = function AnnotationHitTestLink$GetHitTestResult(p, hitTargetNodes) {
		var selectionRect = (ss.isValue(p) ? { x: p.x, y: p.y, w: 1, h: 1 } : null);
		for (var i = hitTargetNodes.length - 1; i >= 0; i--) {
			if (tab.RectXYUtil.intersectsWith(selectionRect, hitTargetNodes[i].get_boundingBox())) {
				return [new $tab_HitTestResult.$ctor1(hitTargetNodes[i].get_objectId(), 2, 3)];
			}
		}
		return [$tab_HitTestResult.createEmptyHitTestResult()];
	};
	global.tab.AnnotationHitTestLink = $tab_AnnotationHitTestLink;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ViewModels.AnnotationSelectionChromeViewModel
	var $tab_AnnotationSelectionChromeViewModel = function(visualId, getAnnotations) {
		this.visible = false;
		this.selectedAnnotations = null;
		this.hoverAnnotation = null;
		this.visualId = null;
		this.getAnnotationDictionary = null;
		this.$vizContextMenuViewModel = null;
		this.$cursorPosition = null;
		this.dragHandler = null;
		ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
		this.visible = false;
		this.visualId = visualId;
		this.getAnnotationDictionary = getAnnotations;
		this.selectedAnnotations = {};
		this.hoverAnnotation = null;
		this.dragHandler = new $tab_AnnotationDragHandler(this);
		this.$cursorPosition = { x: 0, y: 0 };
	};
	$tab_AnnotationSelectionChromeViewModel.__typeName = 'tab.AnnotationSelectionChromeViewModel';
	$tab_AnnotationSelectionChromeViewModel.canAnnotationInCurrentSheetType = function AnnotationSelectionChromeViewModel$CanAnnotationInCurrentSheetType() {
		return tsConfig.current_sheet_type !== 'story';
	};
	global.tab.AnnotationSelectionChromeViewModel = $tab_AnnotationSelectionChromeViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.AnnotationShadow
	var $tab_AnnotationShadow = function() {
		this.rectShadow = null;
		this.point1 = null;
		this.point2 = null;
	};
	$tab_AnnotationShadow.__typeName = 'tab.AnnotationShadow';
	global.tab.AnnotationShadow = $tab_AnnotationShadow;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.AnnotationTelemetryUtil
	var $tab_AnnotationTelemetryUtil = function() {
	};
	$tab_AnnotationTelemetryUtil.__typeName = 'tab.AnnotationTelemetryUtil';
	$tab_AnnotationTelemetryUtil.$convertAnnotationType = function AnnotationTelemetryUtil$ConvertAnnotationType(type) {
		switch (type) {
			case 'area': {
				return $tab_AnnotationTelemetryUtil.annotationAreaType;
			}
			case 'mark': {
				return $tab_AnnotationTelemetryUtil.annotationMarkType;
			}
			case 'point': {
				return $tab_AnnotationTelemetryUtil.annotationPointType;
			}
			default: {
				return null;
			}
		}
	};
	$tab_AnnotationTelemetryUtil.reportCreatedAnnotationTelemetry = function AnnotationTelemetryUtil$ReportCreatedAnnotationTelemetry(annotationType) {
		$tab_AnnotationTelemetryUtil.$reportAnnotationTelemetry(annotationType, $tab_AnnotationTelemetryUtil.annotationCreateType, 'Context Menu');
	};
	$tab_AnnotationTelemetryUtil.reportDeletedAnnotationTelemetry = function AnnotationTelemetryUtil$ReportDeletedAnnotationTelemetry(actionFrom) {
		$tab_AnnotationTelemetryUtil.$reportAnnotationTelemetry(null, $tab_AnnotationTelemetryUtil.annotationDeleteType, actionFrom);
	};
	$tab_AnnotationTelemetryUtil.reportMovedAnnotationTelemetry = function AnnotationTelemetryUtil$ReportMovedAnnotationTelemetry(annotationType) {
		$tab_AnnotationTelemetryUtil.$reportAnnotationTelemetry($tab_AnnotationTelemetryUtil.$convertAnnotationType(annotationType), $tab_AnnotationTelemetryUtil.annotationMoveType, $tab_AnnotationTelemetryUtil.annotationFromDrag);
	};
	$tab_AnnotationTelemetryUtil.reportMovedAnnotationPointTargetTelemetry = function AnnotationTelemetryUtil$ReportMovedAnnotationPointTargetTelemetry() {
		$tab_AnnotationTelemetryUtil.$reportAnnotationTelemetry($tab_AnnotationTelemetryUtil.annotationPointType, $tab_AnnotationTelemetryUtil.annotationMovePointTargetType, $tab_AnnotationTelemetryUtil.annotationFromDrag);
	};
	$tab_AnnotationTelemetryUtil.reportResizeAnnotationTelemetry = function AnnotationTelemetryUtil$ReportResizeAnnotationTelemetry(annotationType) {
		$tab_AnnotationTelemetryUtil.$reportAnnotationTelemetry($tab_AnnotationTelemetryUtil.$convertAnnotationType(annotationType), $tab_AnnotationTelemetryUtil.annotationResizeType, $tab_AnnotationTelemetryUtil.annotationFromDrag);
	};
	$tab_AnnotationTelemetryUtil.$reportAnnotationTelemetry = function AnnotationTelemetryUtil$ReportAnnotationTelemetry(annotationType, action, actionFrom) {
		if (tab.FeatureFlags.isEnabled('WebAuthoringOnlineTelemetry')) {
			tab.OnlineAnalyticsClient.logEvent($tab_AnnotationTelemetryUtil.annotationEventType, ss.mkdict([$tab_AnnotationTelemetryUtil.annotationType, annotationType, $tab_AnnotationTelemetryUtil.annotationAction, action, $tab_AnnotationTelemetryUtil.annotationActionFrom, actionFrom]));
		}
	};
	global.tab.AnnotationTelemetryUtil = $tab_AnnotationTelemetryUtil;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.AnnotationVizContextMenuItemsHandler
	var $tab_AnnotationVizContextMenuItemsHandler = function(visualId, selectedAnnotations, telemetryOpenedBy, afterClickCallback) {
		this.$selectionIds = null;
		this.$afterClickCallback = null;
		this.$visualId = null;
		this.$telemetryOpenedBy = null;
		this.$afterClickCallback = afterClickCallback;
		this.$visualId = visualId;
		this.$selectionIds = _.keys(selectedAnnotations);
		this.$telemetryOpenedBy = telemetryOpenedBy;
	};
	$tab_AnnotationVizContextMenuItemsHandler.__typeName = 'tab.AnnotationVizContextMenuItemsHandler';
	global.tab.AnnotationVizContextMenuItemsHandler = $tab_AnnotationVizContextMenuItemsHandler;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.CanvasTemplate
	var $tab_CanvasTemplate = function() {
		this.canvasElt = null;
		spiff.Template.call(this, $($tab_CanvasTemplate.$htmlTemplate));
		this.canvasElt = this.domRoot;
		this.canvasElt.css('display', 'block');
	};
	$tab_CanvasTemplate.__typeName = 'tab.CanvasTemplate';
	global.tab.CanvasTemplate = $tab_CanvasTemplate;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.CanvasView
	var $tab_CanvasView$1 = function(TViewModel) {
		var $type = function(viewModel, backgroundMode) {
			this.canvasElt = null;
			this.context = null;
			this.scrollOffset = null;
			this.$canvasBackgroundMode = null;
			this.$logicalPixelScrollOffset = null;
			this.$pixelRatio = 0;
			this.$redrawTimer = null;
			this.$effectiveViewSize = null;
			this.$waitHandler = null;
			this.$incrementedWH = false;
			this.$completionMonitorToken = null;
			this.$3$SizeChangeField = null;
			ss.makeGenericType(spiff.BaseView$1, [TViewModel]).call(this, viewModel, new $tab_CanvasTemplate());
			var $t1 = ss.cast(this.get_template(), $tab_CanvasTemplate).canvasElt.get(0);
			this.canvasElt = ss.cast($t1, ss.isValue($t1) && (ss.isInstanceOfType($t1, Element) && $t1.tagName === 'CANVAS'));
			this.scrollOffset = { x: 0, y: 0 };
			this.$logicalPixelScrollOffset = { x: 0, y: 0 };
			this.$incrementedWH = false;
			this.$canvasBackgroundMode = backgroundMode;
			this.context = tab.CanvasRenderer.getRenderContext(this.canvasElt, backgroundMode);
			this.$pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
			tab.CommandController.get().add_modelsUpdated(ss.mkdel(this, this.$redrawIfDirty));
		};
		ss.registerGenericClassInstance($type, $tab_CanvasView$1, [TViewModel], {
			add_sizeChange: function CanvasView$add_SizeChange(value) {
				this.$3$SizeChangeField = ss.delegateCombine(this.$3$SizeChangeField, value);
			},
			remove_sizeChange: function CanvasView$remove_SizeChange(value) {
				this.$3$SizeChangeField = ss.delegateRemove(this.$3$SizeChangeField, value);
			},
			get_canScrollX: function CanvasView$get_CanScrollX() {
				return this.get_docSize().w - this.get_effectiveViewSize().w > 0;
			},
			get_canScrollY: function CanvasView$get_CanScrollY() {
				return this.get_docSize().h - this.get_effectiveViewSize().h > 0;
			},
			get_docSize: null,
			get_actualViewSize: function CanvasView$get_ActualViewSize() {
				if (!ss.isValue(this.canvasElt)) {
					return { w: 0, h: 0 };
				}
				return { w: this.canvasElt.width, h: this.canvasElt.height };
			},
			set_actualViewSize: function CanvasView$set_ActualViewSize(value) {
				if (!ss.isValue(this.canvasElt)) {
					return;
				}
				if (tab.CanvasUtil.isOverCanvasSizeLimit(value.w, value.h, this.get_pixelRatio())) {
					this.$pixelRatio = 1;
				}
				if (this.get_effectiveViewSize().w !== value.w || this.get_effectiveViewSize().h !== value.h) {
					this.$effectiveViewSize = { w: value.w, h: value.h };
					tab.CanvasUtil.setCanvasSizeAndDensify(this.canvasElt, this.get_pixelRatio(), this.$effectiveViewSize);
					if (this.$canvasBackgroundMode === 'opaque') {
						this.context.set_shapeFillStyle(this.get_backgroundFillColor().toString());
						this.context.fillRect(0, 0, this.canvasElt.width, this.canvasElt.height);
					}
					this.invalidate(false);
					if (!ss.staticEquals(this.$3$SizeChangeField, null)) {
						this.$3$SizeChangeField();
					}
				}
			},
			get_effectiveViewSize: function CanvasView$get_EffectiveViewSize() {
				if (ss.isValue(this.$effectiveViewSize)) {
					return this.$effectiveViewSize;
				}
				else {
					return this.get_actualViewSize();
				}
			},
			get_pixelRatio: function CanvasView$get_PixelRatio() {
				return this.$pixelRatio;
			},
			get_isContentOpaque: function CanvasView$get_IsContentOpaque() {
				return true;
			},
			get_needsRedraw: function CanvasView$get_NeedsRedraw() {
				return !tab.RectXYUtil.isEmpty(this.get_dirtyRect());
			},
			get_scrollPos: function CanvasView$get_ScrollPos() {
				return this.scrollOffset;
			},
			set_scrollPos: function CanvasView$set_ScrollPos(value) {
				if (!tab.PointUtil.equals(this.scrollOffset, value)) {
					var logicalDesiredScrollPoint = tab.PointDUtil.timesScalar(value, this.$pixelRatio);
					var logicalScrollToPoint = tab.PointDUtil.round(logicalDesiredScrollPoint);
					var logicalPixelDelta = tab.PointUtil.subtract(logicalScrollToPoint, this.$logicalPixelScrollOffset);
					var delta = tab.PointUtil.subtract(value, this.scrollOffset);
					this.$logicalPixelScrollOffset = logicalScrollToPoint;
					this.scrollOffset = value;
					if (this.get_backgroundFillColor().get_isOpaque()) {
						if (!tab.RectXYUtil.isEmpty(this.get_dirtyRect())) {
							var offset = { x: -delta.x, y: -delta.y };
							var dirtyRect = tab.RectXYUtil.offsetRect(this.get_dirtyRect(), offset);
							this.set_dirtyRect(dirtyRect);
						}
						if (delta.x !== 0 && delta.y !== 0 || !this.get_isContentOpaque()) {
							this.invalidate(true);
						}
						else {
							var pixelDeltaX = logicalPixelDelta.x;
							var pixelDeltaY = logicalPixelDelta.y;
							var width = this.get_actualViewSize().w - Math.abs(pixelDeltaX);
							var xSrc = ((pixelDeltaX > 0) ? pixelDeltaX : 0);
							var xDst = ((pixelDeltaX > 0) ? 0 : -pixelDeltaX);
							var height = this.get_actualViewSize().h - Math.abs(pixelDeltaY);
							var ySrc = ((pixelDeltaY > 0) ? pixelDeltaY : 0);
							var yDst = ((pixelDeltaY > 0) ? 0 : -pixelDeltaY);
							if (width <= 0 || height <= 0) {
								this.invalidate(true);
							}
							else {
								this.context.reset();
								this.context.drawImage5(this.canvasElt, xSrc, ySrc, width, height, xDst, yDst, width, height);
								var invalRect = { x: 0, y: 0, w: this.get_effectiveViewSize().w, h: this.get_effectiveViewSize().h };
								if (delta.x > 0) {
									invalRect.x = invalRect.w - delta.x;
								}
								else if (delta.x < 0) {
									invalRect.w = -delta.x;
								}
								if (delta.y > 0) {
									invalRect.y = invalRect.h - delta.y;
								}
								else if (delta.y < 0) {
									invalRect.h = -delta.y;
								}
								if (delta.x === 0) {
									invalRect.h = Math.abs(delta.y);
								}
								if (delta.y === 0) {
									invalRect.w = Math.abs(delta.x);
								}
								invalRect = tab.RectXYUtil.dialate(invalRect, 3);
								this.invalidateRect(invalRect, true);
							}
						}
					}
					else {
						this.invalidate(true);
					}
				}
			},
			get_dirtyRect: function CanvasView$get_DirtyRect() {
				return (ss.isValue(this.context) ? this.context.dirtyRect : { x: 0, y: 0, w: 0, h: 0 });
			},
			set_dirtyRect: function CanvasView$set_DirtyRect(value) {
				if (ss.isValue(this.context)) {
					this.context.dirtyRect = value;
				}
			},
			get_backgroundFillColor: null,
			dispose: function CanvasView$Dispose() {
				if (ss.isValue(this.$redrawTimer)) {
					tab.WindowHelper.cancelAnimationFrame(ss.unbox(this.$redrawTimer));
					this.$redrawTimer = null;
				}
				this.$decrementWait();
				tab.CommandController.get().remove_modelsUpdated(ss.mkdel(this, this.$redrawIfDirty));
				ss.makeGenericType(spiff.BaseView$1, [TViewModel]).prototype.dispose.call(this);
			},
			clearDirty: function CanvasView$ClearDirty() {
				this.set_dirtyRect({ x: 0, y: 0, w: 0, h: 0 });
			},
			invalidate: function CanvasView$Invalidate(immediateRedraw) {
				this.set_dirtyRect({ x: 0, y: 0, w: this.get_effectiveViewSize().w, h: this.get_effectiveViewSize().h });
				this.$triggerRedraw(immediateRedraw);
			},
			invalidateRect: function CanvasView$InvalidateRect(rect, immediateRedraw) {
				var invalRect;
				if (tab.RectXYUtil.isEmpty(this.get_dirtyRect())) {
					invalRect = tab.RectXYUtil.clone(rect);
				}
				else {
					invalRect = tab.RectXYUtil.union(this.get_dirtyRect(), rect);
				}
				if (invalRect.x < 0) {
					invalRect.x = 0;
				}
				if (invalRect.x + invalRect.w > this.get_effectiveViewSize().w) {
					invalRect.w = this.get_effectiveViewSize().w - invalRect.x;
				}
				if (invalRect.y < 0) {
					invalRect.y = 0;
				}
				if (invalRect.y + invalRect.h > this.get_effectiveViewSize().h) {
					invalRect.h = this.get_effectiveViewSize().h - invalRect.y;
				}
				this.set_dirtyRect(invalRect);
				this.$triggerRedraw(immediateRedraw);
			},
			setXPos: function CanvasView$SetXPos(xPos) {
				this.set_scrollPos({ x: xPos, y: this.get_scrollPos().y });
			},
			setYPos: function CanvasView$SetYPos(yPos) {
				this.set_scrollPos({ x: this.get_scrollPos().x, y: yPos });
			},
			redraw: null,
			redrawFinished: null,
			$triggerRedraw: function CanvasView$TriggerRedraw(immediate) {
				if (immediate) {
					this.$incrementWait();
					this.redraw();
					this.$decrementWait();
					if (ss.isValue(this.$redrawTimer)) {
						tab.WindowHelper.cancelAnimationFrame(ss.unbox(this.$redrawTimer));
						this.$redrawTimer = null;
					}
					this.redrawFinished();
				}
				else if (ss.isNullOrUndefined(this.$redrawTimer)) {
					this.$incrementWait();
					this.$redrawTimer = tab.WindowHelper.requestAnimationFrame(ss.mkdel(this, this.$redrawIfDirty));
				}
			},
			$redrawIfDirty: function CanvasView$RedrawIfDirty() {
				if (tab.AnimationUtil.isUpdating() || ss.isValue(this.$redrawTimer)) {
					this.$triggerRedraw(true);
				}
			},
			$incrementWait: function CanvasView$IncrementWait() {
				this.$waitHandler = this.$waitHandler || tab.BaseSession.get_waitHandler();
				var incrementWait = !this.$incrementedWH && this.$waitHandler.isBusy();
				if (incrementWait) {
					this.$waitHandler.addref(false, true);
					this.$incrementedWH = true;
					return true;
				}
				if (ss.isNullOrUndefined(this.$completionMonitorToken)) {
					this.$completionMonitorToken = tab.CompletionMonitor.get_instance().hold(1);
				}
				return false;
			},
			$decrementWait: function CanvasView$DecrementWait() {
				if (this.$incrementedWH) {
					this.$waitHandler = this.$waitHandler || tab.BaseSession.get_waitHandler();
					this.$waitHandler.release();
					this.$incrementedWH = false;
				}
				if (ss.isValue(this.$completionMonitorToken)) {
					this.$completionMonitorToken.dispose();
					this.$completionMonitorToken = null;
				}
			}
		}, function() {
			return ss.makeGenericType(spiff.BaseView$1, [TViewModel]);
		}, function() {
			return [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [TViewModel]), spiff.IScrollable];
		});
		return $type;
	};
	$tab_CanvasView$1.__typeName = 'tab.CanvasView$1';
	ss.initGenericClass($tab_CanvasView$1, $asm, 1);
	global.tab.CanvasView$1 = $tab_CanvasView$1;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.CircleShapeSelector
	var $tab_CircleShapeSelector = function(svgSize, radialDistModel) {
		this.$dragCircle = null;
		this.$hitTestCircle = null;
		this.$radialDistanceModel = null;
		$tab_ShapeSelectorBase.call(this, svgSize, $tab_CircleShapeSelector.$htmlTemplate, $tab_CircleShapeSelector.$divClassName);
		this.$dragCircle = { center: { x: 0, y: 0 }, radius: 0 };
		this.$hitTestCircle = { center: { x: 0, y: 0 }, radius: 0 };
		this.$radialDistanceModel = radialDistModel;
	};
	$tab_CircleShapeSelector.__typeName = 'tab.CircleShapeSelector';
	global.tab.CircleShapeSelector = $tab_CircleShapeSelector;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.CircleShapeState
	var $tab_CircleShapeState = function() {
		this.$currentState = null;
		this.$lastState = null;
		$tab_ShapeStateBase.call(this);
		this.$currentState = { center: { x: 0, y: 0 }, radius: 0 };
		this.$lastState = { center: { x: 0, y: 0 }, radius: 0 };
	};
	$tab_CircleShapeState.__typeName = 'tab.CircleShapeState';
	global.tab.CircleShapeState = $tab_CircleShapeState;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.DisplayList2DRenderer
	var $tab_DisplayList2DRenderer = function(canvas, context, colorModel) {
		this.$interactionColors = null;
		tab.CanvasRenderer.call(this, canvas, context);
		this.$interactionColors = colorModel || $tab_InteractionColorModel.defaultColors;
	};
	$tab_DisplayList2DRenderer.__typeName = 'tab.DisplayList2DRenderer';
	$tab_DisplayList2DRenderer.setTextProperties = function DisplayList2DRenderer$SetTextProperties(context, textStyle, fontSize) {
		context.set_textFillStyle(textStyle.color);
		var fontDescription = new ss.StringBuilder();
		if (textStyle.fontStyle === 'font-style-italic') {
			fontDescription.append('italic ');
		}
		if (textStyle.fontWeight === 'font-weight-bold') {
			fontDescription.append('bold ');
		}
		if (ss.isValue(textStyle.textDecoration) && textStyle.textDecoration === 'text-decoration-underline') {
			context.set_shouldUnderlineText(true);
		}
		ss.Debug.assert(ss.isNullOrUndefined(textStyle.textDecoration) || textStyle.textDecoration === 'text-decoration-none' || textStyle.textDecoration === 'text-decoration-underline', 'Canvas does not support decorations (though we kind of support underline)');
		if (ss.isNullOrUndefined(fontSize) || fontSize <= 0) {
			fontSize = textStyle.fontSize;
		}
		var fontName = tab.FontUtil.createFallbackCanvasFontName(textStyle.fontName);
		fontDescription.append(fontSize + 'pt ' + fontName);
		context.set_font(fontDescription.toString());
		context.set_textBaseline(tab.FormattingConverters.getTextBaseline(textStyle.valign));
	};
	$tab_DisplayList2DRenderer.resolveLineCap = function DisplayList2DRenderer$ResolveLineCap(linePattern, drawPenLineCap) {
		var lineCap = 'butt';
		if (linePattern !== 'dashed' && linePattern !== 'dotted') {
			lineCap = (ss.isValue(drawPenLineCap) ? tab.CanvasRenderer.toCanvasLineCap(drawPenLineCap) : tab.TabRenderContext2D.defaultLineCap);
		}
		return lineCap;
	};
	$tab_DisplayList2DRenderer.$applyDrawTextProps = function DisplayList2DRenderer$ApplyDrawTextProps(context, item) {
		var textProperties = item;
		context.set_textFillStyle(tab.ColorModel.convertColorForCanvas(textProperties.color));
		if (ss.isValue(textProperties.angle)) {
			var angleInRad = textProperties.angle * Math.PI / 180;
			context.set_textAngle(angleInRad);
		}
		else {
			context.set_textAngle(tab.TabRenderContext2D.defaultTextAngle);
		}
		var fontDescription = new ss.StringBuilder();
		if (textProperties.isItalics) {
			fontDescription.append('italic ');
		}
		if (textProperties.isBold) {
			fontDescription.append('bold ');
		}
		if (textProperties.isStrikeThrough) {
		}
		var textAlign = tab.TabRenderContext2D.defaultTextAlign;
		if (context.get_isTextAngleHorizontal()) {
			var horizAlign = textProperties.horizontalLabelAlignment || 'h-align-left';
			if (horizAlign === 'h-align-right') {
				textAlign = 'end';
			}
		}
		else {
			var vertAlign = textProperties.verticalLabelAlignment || 'v-align-top';
			if (context.get_textAngle() < 0 && vertAlign === 'v-align-top' || context.get_textAngle() > 0 && vertAlign === 'v-align-bottom') {
				textAlign = 'end';
			}
		}
		context.set_textAlign(textAlign);
		context.set_shouldUnderlineText(textProperties.isUnderlined || tab.TabRenderContext2D.defaultTextUnderline);
		var fontName = textProperties.fontName || tab.TabRenderContext2D.defaultFontName;
		fontName = tab.FontUtil.createFallbackCanvasFontName(fontName);
		var fontSize = textProperties.pointSize || 8;
		fontDescription.append(fontSize + 'pt ' + fontName);
		context.set_font(fontDescription.toString());
	};
	$tab_DisplayList2DRenderer.$drawEllipse = function DisplayList2DRenderer$DrawEllipse(context, item, shouldFill) {
		ss.Debug.assert(item.type === 'draw-fill-ellipse' || item.type === 'draw-ellipse', 'This method assumes we are drawing an ellipse');
		var drawPoints = item;
		if (drawPoints.points.length !== 4) {
			return;
		}
		var width = drawPoints.points[2] - drawPoints.points[0];
		var height = drawPoints.points[3] - drawPoints.points[1];
		var centerX = drawPoints.points[0] + width / 2;
		var centerY = drawPoints.points[1] + height / 2;
		var radius = ((width < height) ? width : height) / 2;
		var scaleX = ((width < height) ? 1 : (width / height));
		var scaleY = ((height < width) ? 1 : (height / width));
		context.save();
		context.beginPath();
		context.translate(centerX, centerY);
		context.scale(scaleX, scaleY);
		context.arc(0, 0, radius, 0, tab.CanvasRenderer.twoPI, false);
		context.closePath();
		if (shouldFill) {
			context.fill();
		}
		else {
			context.stroke();
		}
		context.restore();
	};
	$tab_DisplayList2DRenderer.$drawPath = function DisplayList2DRenderer$DrawPath(context, drawPathPM, fill) {
		var points = drawPathPM.pointsF;
		if (!fill && Math.round(context.get_lineWidth()) % 2 === 1) {
			points = ss.arrayClone(points);
			for (var ii = 0, len = points.length; ii < len; ++ii) {
				points[ii] += 0.5;
			}
		}
		var instructions = drawPathPM.pathElements;
		var numPoints = Math.floor(points.length / 2);
		if (numPoints < 2) {
			return;
		}
		context.beginPath();
		var pc = 0;
		for (var $t1 = 0; $t1 < instructions.length; $t1++) {
			var instruction = instructions[$t1];
			switch (instruction) {
				case 'moveto': {
					{
						context.moveTo(points[pc], points[pc + 1]);
						pc += 2;
					}
					break;
				}
				case 'lineto': {
					{
						context.lineTo(points[pc], points[pc + 1]);
						pc += 2;
					}
					break;
				}
				case 'curveto': {
					{
						context.bezierCurveTo(points[pc], points[pc + 1], points[pc + 2], points[pc + 3], points[pc + 4], points[pc + 5]);
						pc += 6;
					}
					break;
				}
				default: {
					{
						ss.Debug.fail('Unknown path instruction: ' + instruction);
					}
					break;
				}
			}
		}
		if (fill) {
			context.fill();
		}
		else {
			context.stroke();
		}
	};
	$tab_DisplayList2DRenderer.$isPropertyItem = function DisplayList2DRenderer$IsPropertyItem(item) {
		switch (ss.cast(item.type, String)) {
			case 'draw-pen':
			case 'draw-solid-brush':
			case 'draw-gradient-brush':
			case 'clip-rect':
			case 'draw-text-props':
			case 'transform':
			case 'transform-pop':
			case 'transform-push':
			case 'draw-antialias': {
				return true;
			}
		}
		return false;
	};
	$tab_DisplayList2DRenderer.$modifyDrawItemOrderForRightAlignedText = function DisplayList2DRenderer$ModifyDrawItemOrderForRightAlignedText(drawItems, isAnnotationPart) {
		if (!isAnnotationPart) {
			return drawItems;
		}
		var rightTextInfo = $tab_DisplayList2DRenderer.$getAnnotationMultipleRightAlignedTextRunInfo(drawItems);
		if (rightTextInfo.length === 0) {
			return drawItems;
		}
		var toRet = ss.arrayClone(drawItems);
		var swapArrayVals = function(p1, p2) {
			var temp = toRet[p1];
			toRet[p1] = toRet[p2];
			toRet[p2] = temp;
		};
		for (var $t1 = 0; $t1 < rightTextInfo.length; $t1++) {
			var line = rightTextInfo[$t1];
			for (var runNum = 0; runNum < ss.Int32.div(line.length, 2); ++runNum) {
				var otherRunNum = line.length - 1 - runNum;
				swapArrayVals(line[runNum].item1, line[otherRunNum].item1);
				swapArrayVals(line[runNum].item2, line[otherRunNum].item2);
			}
		}
		return toRet;
	};
	$tab_DisplayList2DRenderer.$getAnnotationMultipleRightAlignedTextRunInfo = function DisplayList2DRenderer$GetAnnotationMultipleRightAlignedTextRunInfo(drawItems) {
		var lineRunPositions = [];
		var prevYPos = -99999999;
		var rightAligned = false;
		var textPropsIndex = -1;
		var curLine = [];
		for (var ii = 0; ii < drawItems.length; ii++) {
			var drawItem = drawItems[ii];
			if (drawItem.type === 'draw-text-props') {
				var textPropsItem = drawItem;
				rightAligned = ss.isValue(textPropsItem.horizontalLabelAlignment) && textPropsItem.horizontalLabelAlignment === 'h-align-right';
				textPropsIndex = ii;
			}
			else if (rightAligned && drawItem.type === 'draw-text') {
				var textItem = drawItem;
				var yPos = textItem.points[1];
				if (yPos !== prevYPos) {
					if (curLine.length >= 2) {
						lineRunPositions.push(curLine);
					}
					curLine = [];
				}
				curLine.push({ item1: textPropsIndex, item2: ii });
				prevYPos = yPos;
			}
		}
		if (curLine.length >= 2) {
			lineRunPositions.push(curLine);
		}
		return lineRunPositions;
	};
	global.tab.DisplayList2DRenderer = $tab_DisplayList2DRenderer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.DisplayList2DUtils
	var $tab_DisplayList2DUtils = function() {
	};
	$tab_DisplayList2DUtils.__typeName = 'tab.DisplayList2DUtils';
	$tab_DisplayList2DUtils.rectXYFromDrawRect = function DisplayList2DUtils$RectXYFromDrawRect(points) {
		ss.Debug.assert(points.length === 4, 'the draw item for a rectangle should always specify 4 values.');
		return { x: points[0], y: points[1], w: points[2] - points[0], h: points[3] - points[1] };
	};
	$tab_DisplayList2DUtils.rectXYFromRoundedRect = function DisplayList2DUtils$RectXYFromRoundedRect(points, elements) {
		if (!(points.length === 26 && elements.length === 5) || points.length === 30 && elements.length === 7 || points.length === 34 && elements.length === 9) {
			ss.Debug.writeln('the draw item for a rounded rect should have either 26, 30, or 34 values.');
			return null;
		}
		var xmin = 2147483647;
		var xmax = -2147483648;
		var ymin = 2147483647;
		var ymax = -2147483648;
		var index = 0;
		for (var $t1 = 0; $t1 < elements.length; $t1++) {
			var element = elements[$t1];
			switch (element) {
				case 'lineto':
				case 'moveto': {
					index += 2;
					break;
				}
				case 'curveto': {
					index += 4;
					xmin = Math.min(xmin, ss.Int32.trunc(points[index]));
					xmax = Math.max(xmax, ss.Int32.trunc(points[index]));
					ymin = Math.min(ymin, ss.Int32.trunc(points[index + 1]));
					ymax = Math.max(ymax, ss.Int32.trunc(points[index + 1]));
					index += 2;
					break;
				}
				default: {
					break;
				}
			}
		}
		var corners = [xmin, ymin, xmax, ymax];
		return $tab_DisplayList2DUtils.rectXYFromDrawRect(corners);
	};
	global.tab.DisplayList2DUtils = $tab_DisplayList2DUtils;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.DownloadQueue
	var $tab_DownloadQueue = function() {
		this.$workers = null;
		this.$runningWorkers = 0;
		this.$imageQueue = null;
		this.$1$CompleteField = null;
		this.$1$ImageLoadedField = null;
		this.$1$ImageTimedOutField = null;
		this.$workers = [];
		this.$imageQueue = new Array();
	};
	$tab_DownloadQueue.__typeName = 'tab.DownloadQueue';
	global.tab.DownloadQueue = $tab_DownloadQueue;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.EmptyContentProvider
	var $tab_EmptyContentProvider = function() {
	};
	$tab_EmptyContentProvider.__typeName = 'tab.EmptyContentProvider';
	global.tab.EmptyContentProvider = $tab_EmptyContentProvider;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.FloatingMenuFlyoutButtonComponent
	var $tab_FloatingMenuFlyoutButtonComponent = function(props, context) {
		React.Component.call(this, props, context);
	};
	$tab_FloatingMenuFlyoutButtonComponent.__typeName = 'tab.FloatingMenuFlyoutButtonComponent';
	global.tab.FloatingMenuFlyoutButtonComponent = $tab_FloatingMenuFlyoutButtonComponent;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.FloatingToolbarButton
	var $tab_FloatingToolbarButton = function() {
	};
	$tab_FloatingToolbarButton.__typeName = 'tab.FloatingToolbarButton';
	global.tab.FloatingToolbarButton = $tab_FloatingToolbarButton;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.FloatingToolbarButtonPressEventProperties
	var $tab_FloatingToolbarButtonPressEventProperties = function() {
	};
	$tab_FloatingToolbarButtonPressEventProperties.__typeName = 'tab.FloatingToolbarButtonPressEventProperties';
	global.tab.FloatingToolbarButtonPressEventProperties = $tab_FloatingToolbarButtonPressEventProperties;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.FloatingToolbarContainerComponent
	var $tab_FloatingToolbarContainerComponent = function(props, context) {
		React.Component.call(this, props, context);
	};
	$tab_FloatingToolbarContainerComponent.__typeName = 'tab.FloatingToolbarContainerComponent';
	global.tab.FloatingToolbarContainerComponent = $tab_FloatingToolbarContainerComponent;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.FloatingToolbarContainerViewModel
	var $tab_FloatingToolbarContainerViewModel = function(toolModeViewModel) {
		this.$showToolbar = false;
		this.$showTools = false;
		this.$showMapsSearch = false;
		this.$showPanAndZoom = false;
		this.$isFlyoutCollapsed = true;
		this.$isZoomHomeHidden = true;
		this.$getAnchorPosition = null;
		this.$currentlySelectedButtonId = 'rectangleSelect';
		this.$flyoutMenuButtonProps = null;
		this.$selectedButtonProps = null;
		this.$panButtonProps = null;
		this.$3$DismissRequestedField = null;
		this.$3$ToolSelectionRequestedField = null;
		this.$3$AppendModeSettingRequestedField = null;
		this.$3$ZoomHomeRequestedField = null;
		this.$3$MapsSearchViewModelField = null;
		ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
		this.$flyoutMenuButtonProps = {};
		this.$flyoutMenuButtonProps['radialSelect'] = { iconClassName: 'tab-radial-select-tool', buttonTooltip: tab.Strings.PanZoomSelectToolsRadialSelectionTooltipMobile, onTap: ss.mkdel(this, this.$onRadialSelectTap) };
		this.$flyoutMenuButtonProps['lassoSelect'] = { iconClassName: 'tab-lasso-select-tool', buttonTooltip: tab.Strings.PanZoomSelectToolsLassoSelectionTooltipMobile, onTap: ss.mkdel(this, this.$onLassoSelectTap) };
		this.$flyoutMenuButtonProps['rectangleSelect'] = { iconClassName: 'tab-rectangle-select-tool', buttonTooltip: tab.Strings.PanZoomSelectToolsRectangularSelectionTooltipMobile, isSelected: true, onTap: ss.mkdel(this, this.$onRectangleSelectTap) };
		this.$flyoutMenuButtonProps['appendSelect'] = { iconClassName: 'tab-append-select-tool', buttonTooltip: tab.Strings.PanZoomSelectToolsAppendTooltip, onTap: ss.mkdel(this, this.$onAppendButtonTap) };
		this.$selectedButtonProps = { iconClassName: 'tab-rectangle-select-tool', buttonTooltip: tab.Strings.PanZoomSelectToolsRectangularSelectionTooltipMobile, isSelected: true, onTap: ss.mkdel(this, this.$onSelectedButtonTap), shouldShowFlyoutCaret: true };
		this.$panButtonProps = { iconClassName: 'tab-pan-tool', buttonTooltip: tab.Strings.PanZoomSelectToolsPanTooltipMobile, onTap: ss.mkdel(this, this.$onPanTap) };
		toolModeViewModel.add_toolbarToolModeUpdated(ss.mkdel(this, this.$onToolModeUpdated));
		this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
			toolModeViewModel.remove_toolbarToolModeUpdated(ss.mkdel(this, this.$onToolModeUpdated));
		})));
		this.$onToolModeUpdated(toolModeViewModel.get_currentPointerToolMode());
		toolModeViewModel.add_appendModeUpdated(ss.mkdel(this, this.$onAppendModeUpdated));
		this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
			toolModeViewModel.remove_appendModeUpdated(ss.mkdel(this, this.$onAppendModeUpdated));
		})));
		this.$onAppendModeUpdated(toolModeViewModel.get_isAppendMode());
	};
	$tab_FloatingToolbarContainerViewModel.__typeName = 'tab.FloatingToolbarContainerViewModel';
	$tab_FloatingToolbarContainerViewModel.$buttonForTool = function FloatingToolbarContainerViewModel$ButtonForTool(tool) {
		switch (tool) {
			case 'pan-map': {
				return 'pan';
			}
			case 'radial-selection': {
				return 'radialSelect';
			}
			case 'lasso-selection': {
				return 'lassoSelect';
			}
			case 'rectangular-selection':
			default: {
				return 'rectangleSelect';
			}
		}
	};
	$tab_FloatingToolbarContainerViewModel.$toolForButton = function FloatingToolbarContainerViewModel$ToolForButton(buttonId) {
		switch (buttonId) {
			case 'pan': {
				return 'pan-map';
			}
			case 'radialSelect': {
				return 'radial-selection';
			}
			case 'lassoSelect': {
				return 'lasso-selection';
			}
			case 'rectangleSelect': {
				return 'rectangular-selection';
			}
			default: {
				return 'no-tools';
			}
		}
	};
	global.tab.FloatingToolbarContainerViewModel = $tab_FloatingToolbarContainerViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.FloatingToolbarPositioningComponent
	var $tab_FloatingToolbarPositioningComponent = function(props, context) {
		this.$boundContainerElementRef = null;
		this.$containerElement = null;
		this.$delayedRepositionRequestId = 0;
		this.$delayedRepositionStartTime = 0;
		React.Component.call(this, props, context);
		this.$boundContainerElementRef = ss.mkdel(this, function(element) {
			this.$containerElement = element;
		});
	};
	$tab_FloatingToolbarPositioningComponent.__typeName = 'tab.FloatingToolbarPositioningComponent';
	global.tab.FloatingToolbarPositioningComponent = $tab_FloatingToolbarPositioningComponent;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.FloatingToolbarShowEventProperties
	var $tab_FloatingToolbarShowEventProperties = function() {
	};
	$tab_FloatingToolbarShowEventProperties.__typeName = 'tab.FloatingToolbarShowEventProperties';
	global.tab.FloatingToolbarShowEventProperties = $tab_FloatingToolbarShowEventProperties;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.FloatingToolbarTelemetry
	var $tab_FloatingToolbarTelemetry = function() {
	};
	$tab_FloatingToolbarTelemetry.__typeName = 'tab.FloatingToolbarTelemetry';
	$tab_FloatingToolbarTelemetry.get_$floatingToolbarTelemetryEnabled = function FloatingToolbarTelemetry$get_FloatingToolbarTelemetryEnabled() {
		return tab.OnlineAnalyticsClient.get_telemetryEnabled() && tab.FeatureFlags.isEnabled('GestureModelTelemetry') && tab.GestureModelSettings.get_newModelEnabled();
	};
	$tab_FloatingToolbarTelemetry.trackButtonPress = function FloatingToolbarTelemetry$TrackButtonPress(buttonName) {
		if ($tab_FloatingToolbarTelemetry.get_$floatingToolbarTelemetryEnabled()) {
			tab.OnlineAnalyticsClient.logEvent($tab_FloatingToolbarButtonPressEventProperties.type, ss.mkdict([$tab_FloatingToolbarButtonPressEventProperties.buttonName, buttonName]));
		}
	};
	$tab_FloatingToolbarTelemetry.trackShow = function FloatingToolbarTelemetry$TrackShow(mapsSearchShown, toolsShown, panAvailable, homeShown) {
		if ($tab_FloatingToolbarTelemetry.get_$floatingToolbarTelemetryEnabled()) {
			tab.OnlineAnalyticsClient.logEvent($tab_FloatingToolbarShowEventProperties.type, ss.mkdict([$tab_FloatingToolbarShowEventProperties.mapsSearchShown, mapsSearchShown, $tab_FloatingToolbarShowEventProperties.toolsShown, toolsShown, $tab_FloatingToolbarShowEventProperties.panAvailable, panAvailable, $tab_FloatingToolbarShowEventProperties.homeShown, homeShown]));
		}
	};
	global.tab.FloatingToolbarTelemetry = $tab_FloatingToolbarTelemetry;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.FloatingZoomToolbar
	var $tab_FloatingZoomToolbar = function(containerDiv, zoomFuncs, type, topOffset, geoSearchEnabled) {
		this.parent = null;
		this.buttonContainer = null;
		this.flyOutContainer = null;
		this.flyOutButtons = null;
		this.zoomInButton = null;
		this.zoomOutButton = null;
		this.zoomHomeButton = null;
		this.flyOutButton = null;
		this.zoomAreaButton = null;
		this.rectSelectButton = null;
		this.radialSelectButton = null;
		this.lassoSelectButton = null;
		this.panButton = null;
		this.api = null;
		this.canZoomHome = false;
		this.geoSearchEnabled = false;
		this.$currentToolMode = null;
		this.toolbarType = null;
		this.$acceptingInteraction = true;
		spiff.Widget.call(this, $($tab_FloatingZoomToolbar.$toolbarHtml));
		this.parent = $(containerDiv);
		this.api = zoomFuncs;
		this.toolbarType = type;
		this.canZoomHome = false;
		this.geoSearchEnabled = geoSearchEnabled;
		this.element.css({ top: topOffset + 'px' });
	};
	$tab_FloatingZoomToolbar.__typeName = 'tab.FloatingZoomToolbar';
	global.tab.FloatingZoomToolbar = $tab_FloatingZoomToolbar;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.FloatingZoomToolbarView
	var $tab_FloatingZoomToolbarView = function(zoomToolbarContainer) {
		this.zoomToolbar = null;
		this.$zoomToolbarVisibility = null;
		this.$zoomToolbarContainer = null;
		this.$zoomToolbarContainer = zoomToolbarContainer;
	};
	$tab_FloatingZoomToolbarView.__typeName = 'tab.FloatingZoomToolbarView';
	global.tab.FloatingZoomToolbarView = $tab_FloatingZoomToolbarView;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.GeometryUtil
	var $tab_GeometryUtil = function() {
	};
	$tab_GeometryUtil.__typeName = 'tab.GeometryUtil';
	$tab_GeometryUtil.domainToPixelGeometry = function GeometryUtil$DomainToPixelGeometry(geometryPM, domainExtents, pixelExtents, cullCoincident) {
		switch (geometryPM.geometryType) {
			case 'multiPolygon': {
				$tab_GeometryUtil.domainToPixelMultipolygon(geometryPM.multiPolygon, domainExtents, pixelExtents, cullCoincident);
				break;
			}
			case 'multiPoint': {
				var MinimumCoordinateCount = 0;
				var multipointPM = geometryPM.multiPoint;
				$tab_GeometryUtil.domainToPixelCoordinateArray(multipointPM.pointsF, domainExtents, pixelExtents, cullCoincident, MinimumCoordinateCount);
				break;
			}
			case 'multiLineString': {
				var multilinePM = geometryPM.multiLine;
				$tab_GeometryUtil.domainToPixelMultiline(multilinePM, domainExtents, pixelExtents, cullCoincident);
				break;
			}
			default: {
				break;
			}
		}
	};
	$tab_GeometryUtil.domainToPixelMultipolygon = function GeometryUtil$DomainToPixelMultipolygon(multipolygon, domainExtents, pixelExtents, cullCoincident) {
		var polygons = multipolygon.polygonList;
		var polyCount = polygons.length;
		var MinimumCoordinateCount = 6;
		for (var polyIdx = 0; polyIdx < polyCount; polyIdx++) {
			var lines = polygons[polyIdx].lineList;
			var lineCount = lines.length;
			for (var lineIdx = 0; lineIdx < lineCount; lineIdx++) {
				var coords = lines[lineIdx].pointsF;
				$tab_GeometryUtil.domainToPixelCoordinateArray(coords, domainExtents, pixelExtents, cullCoincident, MinimumCoordinateCount);
			}
		}
	};
	$tab_GeometryUtil.domainToPixelMultiline = function GeometryUtil$DomainToPixelMultiline(lines, domainExtents, pixelExtents, cullCoincident) {
		var lineCount = lines.lineList.length;
		var MinimumCoordinateCount = 4;
		for (var lineIdx = 0; lineIdx < lineCount; lineIdx++) {
			var coords = lines.lineList[lineIdx].pointsF;
			$tab_GeometryUtil.domainToPixelCoordinateArray(coords, domainExtents, pixelExtents, cullCoincident, MinimumCoordinateCount);
		}
	};
	$tab_GeometryUtil.domainToPixelCoordinateArray = function GeometryUtil$DomainToPixelCoordinateArray(coords, domainExtents, pixelExtents, cullCoincident, minimumCoordinateCount) {
		var PixelGridSize = 3;
		var xRatio = pixelExtents.w / domainExtents.w;
		var yRatio = pixelExtents.h / domainExtents.h;
		var coordCount = coords.length;
		if (coordCount < 2) {
			return;
		}
		var prevXSubPixelLoc = null;
		var prevYSubPixelLoc = null;
		var j = 0;
		for (var i = 0; i < coordCount; i += 2) {
			var xVal = $tab_GeometryUtil.$domainToPixel(coords[i], domainExtents.x, pixelExtents.x, xRatio);
			var yVal = $tab_GeometryUtil.$domainToPixel(coords[i + 1], domainExtents.y, pixelExtents.y, yRatio);
			var maximumPossibleCoordinates = j + coordCount - i;
			if (cullCoincident && maximumPossibleCoordinates > minimumCoordinateCount) {
				var xSubPixelLoc = xVal * 3 << 0;
				var ySubPixelLoc = yVal * 3 << 0;
				if (xSubPixelLoc === prevXSubPixelLoc && ySubPixelLoc === prevYSubPixelLoc) {
					continue;
				}
				prevXSubPixelLoc = xSubPixelLoc;
				prevYSubPixelLoc = ySubPixelLoc;
			}
			coords[j] = xVal;
			coords[j + 1] = yVal;
			j += 2;
		}
		coords.length = j;
	};
	$tab_GeometryUtil.isGeometryPresModelFeatureEmpty = function GeometryUtil$IsGeometryPresModelFeatureEmpty(geometryPM) {
		switch (geometryPM.geometryType) {
			case 'multiPoint': {
				return geometryPM.multiPoint.pointsF.length === 0;
			}
			case 'multiPolygon': {
				return geometryPM.multiPolygon.polygonList.length === 0;
			}
			case 'multiLineString': {
				return geometryPM.multiLine.lineList.length === 0;
			}
			default: {
				return false;
			}
		}
	};
	$tab_GeometryUtil.$domainToPixel = function GeometryUtil$DomainToPixel(val, domainOffset, pixelOffset, ratio) {
		return (val - domainOffset) * ratio + pixelOffset;
	};
	$tab_GeometryUtil.isPointInPoly = function GeometryUtil$IsPointInPoly(poly, p, inflatePixels) {
		if (ss.isValue(inflatePixels) && inflatePixels !== 0) {
			return $tab_GeometryUtil.polygonIntersectsDoubleRect(poly, { x: p.x - ss.unbox(inflatePixels), y: p.y - ss.unbox(inflatePixels), w: ss.unbox(inflatePixels) * 2, h: ss.unbox(inflatePixels) * 2 });
		}
		var wn = 0;
		var coordCount = poly.length;
		for (var ii = 0; ii < coordCount; ii += 2) {
			var x0 = poly[ii];
			var y0 = poly[ii + 1];
			var nextIndex = (ii + 2) % coordCount;
			var x1 = poly[nextIndex];
			var y1 = poly[nextIndex + 1];
			if (y0 <= p.y) {
				if (y1 > p.y) {
					if ($tab_GeometryUtil.$isLeft(x0, y0, x1, y1, p.x, p.y) > 0) {
						++wn;
					}
				}
			}
			else if (y1 <= p.y) {
				if ($tab_GeometryUtil.$isLeft(x0, y0, x1, y1, p.x, p.y) < 0) {
					--wn;
				}
			}
		}
		return wn !== 0;
	};
	$tab_GeometryUtil.isPointInPolygon = function GeometryUtil$IsPointInPolygon(polygon, p) {
		var result = false;
		var i = 0;
		for (var $t1 = 0; $t1 < polygon.lineList.length; $t1++) {
			var ring = polygon.lineList[$t1];
			var isInRing = $tab_GeometryUtil.isPointInPoly(ring.pointsF, p, null);
			if (i === 0) {
				if (isInRing) {
					result = true;
				}
				else {
					break;
				}
			}
			else if (isInRing) {
				result = false;
				break;
			}
			i++;
		}
		return result;
	};
	$tab_GeometryUtil.isPointInMultipolygon = function GeometryUtil$IsPointInMultipolygon(multipolygon, p) {
		var result = false;
		for (var $t1 = 0; $t1 < multipolygon.polygonList.length; $t1++) {
			var polygon = multipolygon.polygonList[$t1];
			result = $tab_GeometryUtil.isPointInPolygon(polygon, p);
			if (result) {
				break;
			}
		}
		return result;
	};
	$tab_GeometryUtil.lineToQuad = function GeometryUtil$LineToQuad(lineSegment, lineWidth) {
		var length = lineWidth / 2;
		var startPt = { x: lineSegment[0], y: lineSegment[1] };
		var endPt = { x: lineSegment[2], y: lineSegment[3] };
		var deltaX = endPt.x - startPt.x;
		var deltaY = endPt.y - startPt.y;
		var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
		if (distance === 0) {
			return $tab_GeometryUtil.makeQuadFromPoints(startPt, startPt, startPt, startPt);
		}
		var startToEndVec = { x: length * (deltaX / distance), y: length * (deltaY / distance) };
		var perpendicularVec = { x: -startToEndVec.y, y: startToEndVec.x };
		var c1 = { x: startPt.x + perpendicularVec.x, y: startPt.y + perpendicularVec.y };
		var c2 = { x: startPt.x - perpendicularVec.x, y: startPt.y - perpendicularVec.y };
		var c3 = { x: endPt.x + perpendicularVec.x, y: endPt.y + perpendicularVec.y };
		var c4 = { x: endPt.x - perpendicularVec.x, y: endPt.y - perpendicularVec.y };
		return $tab_GeometryUtil.makeQuadFromPoints(c1, c2, c4, c3);
	};
	$tab_GeometryUtil.makeQuadFromPoints = function GeometryUtil$MakeQuadFromPoints(p1, p2, p3, p4) {
		var quad = new Array(8);
		quad[0] = p1.x;
		quad[1] = p1.y;
		quad[2] = p2.x;
		quad[3] = p2.y;
		quad[4] = p3.x;
		quad[5] = p3.y;
		quad[6] = p4.x;
		quad[7] = p4.y;
		return quad;
	};
	$tab_GeometryUtil.isPointInMultiLineString = function GeometryUtil$IsPointInMultiLineString(multiline, p, width) {
		var lines = multiline.lineList;
		var lineCount = lines.length;
		for (var lineIdx = 0; lineIdx < lineCount; lineIdx++) {
			var coords = lines[lineIdx].pointsF;
			var coordCount = coords.length;
			if (coordCount < 4 || coordCount % 2 === 1) {
				continue;
			}
			for (var i = 0; i < coordCount - 2; i += 2) {
				var lineSegment = new Array(4);
				lineSegment[0] = coords[i];
				lineSegment[1] = coords[i + 1];
				lineSegment[2] = coords[i + 2];
				lineSegment[3] = coords[i + 3];
				if ($tab_GeometryUtil.isPointInPoly($tab_GeometryUtil.lineToQuad(lineSegment, width), p, null)) {
					return true;
				}
				if (i >= 2) {
					var jointPoint = { x: coords[i], y: coords[i + 1] };
					var jointCircle = { center: jointPoint, radius: width / 2 };
					if ($tab_GeometryUtil.isPointInCircle(p, jointCircle)) {
						return true;
					}
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.isPointInMultipoint = function GeometryUtil$IsPointInMultipoint(multipoint, p, radius) {
		var coords = multipoint.pointsF;
		var pointCircle = { center: p, radius: radius };
		for (var i = 0; i < coords.length; i = i + 2) {
			var x = coords[i];
			var y = coords[i + 1];
			var currPoint = { x: x, y: y };
			if ($tab_GeometryUtil.isPointInCircle(currPoint, pointCircle)) {
				return true;
			}
		}
		return false;
	};
	$tab_GeometryUtil.getGeometrySelectionTransform = function GeometryUtil$GetGeometrySelectionTransform(hasPixelGeometry, x, y, size) {
		if (!hasPixelGeometry) {
			return tab.Transform.pixelToDomain(x, y, size);
		}
		return tab.Transform.none();
	};
	$tab_GeometryUtil.multipolygonIntersectsDoubleRect = function GeometryUtil$MultipolygonIntersectsDoubleRect(multipolygon, rect) {
		for (var $t1 = 0; $t1 < multipolygon.polygonList.length; $t1++) {
			var polygon = multipolygon.polygonList[$t1];
			for (var $t2 = 0; $t2 < polygon.lineList.length; $t2++) {
				var ring = polygon.lineList[$t2];
				if ($tab_GeometryUtil.polygonIntersectsDoubleRect(ring.pointsF, rect)) {
					return true;
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multiLineStringIntersectsDoubleRect = function GeometryUtil$MultiLineStringIntersectsDoubleRect(multiline, rect, width) {
		for (var $t1 = 0; $t1 < multiline.lineList.length; $t1++) {
			var line = multiline.lineList[$t1];
			var coords = line.pointsF;
			var coordCount = coords.length;
			if (coordCount < 4 || coordCount % 2 === 1) {
				continue;
			}
			for (var i = 0; i < coordCount - 2; i += 2) {
				var lineSegment = new Array(4);
				lineSegment[0] = coords[i];
				lineSegment[1] = coords[i + 1];
				lineSegment[2] = coords[i + 2];
				lineSegment[3] = coords[i + 3];
				if ($tab_GeometryUtil.polygonIntersectsDoubleRect($tab_GeometryUtil.lineToQuad(lineSegment, width), rect)) {
					return true;
				}
				if (i >= 2) {
					var jointPoint = { x: coords[i], y: coords[i + 1] };
					var jointCircle = { center: jointPoint, radius: width / 2 };
					var selectionRect = $tab_GeometryUtil.$clockwiseCornersFromDoubleRect(rect);
					if ($tab_GeometryUtil.polygonIntersectsCircle(selectionRect, jointCircle)) {
						return true;
					}
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multipointIntersectsDoubleRect = function GeometryUtil$MultipointIntersectsDoubleRect(multipoint, rect, placeholderRadius) {
		return $tab_GeometryUtil.multipointIntersectsPolygon(multipoint, $tab_GeometryUtil.$clockwiseCornersFromDoubleRect(rect), placeholderRadius);
	};
	$tab_GeometryUtil.multipolygonIntersectsPolygon = function GeometryUtil$MultipolygonIntersectsPolygon(multipolygon, polygonB) {
		for (var $t1 = 0; $t1 < multipolygon.polygonList.length; $t1++) {
			var polygon = multipolygon.polygonList[$t1];
			for (var $t2 = 0; $t2 < polygon.lineList.length; $t2++) {
				var ring = polygon.lineList[$t2];
				if ($tab_GeometryUtil.$polygonIntersectsPolygon(ring.pointsF, polygonB)) {
					return true;
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multiLineStringIntersectsPolygon = function GeometryUtil$MultiLineStringIntersectsPolygon(multiline, polygon, width) {
		for (var $t1 = 0; $t1 < multiline.lineList.length; $t1++) {
			var line = multiline.lineList[$t1];
			var coords = line.pointsF;
			var coordCount = coords.length;
			if (coordCount < 4 || coordCount % 2 === 1) {
				continue;
			}
			for (var i = 0; i < coordCount - 2; i += 2) {
				var lineSegment = new Array(4);
				lineSegment[0] = coords[i];
				lineSegment[1] = coords[i + 1];
				lineSegment[2] = coords[i + 2];
				lineSegment[3] = coords[i + 3];
				if ($tab_GeometryUtil.$polygonIntersectsPolygon($tab_GeometryUtil.lineToQuad(lineSegment, width), polygon)) {
					return true;
				}
				if (i >= 2) {
					var jointPoint = { x: coords[i], y: coords[i + 1] };
					var jointCircle = { center: jointPoint, radius: width / 2 };
					if ($tab_GeometryUtil.polygonIntersectsCircle(polygon, jointCircle)) {
						return true;
					}
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multipointIntersectsPolygon = function GeometryUtil$MultipointIntersectsPolygon(multipoint, polygon, radius) {
		var coords = multipoint.pointsF;
		var pointCircle = { center: { x: 0, y: 0 }, radius: radius };
		for (var i = 0; i < coords.length; i = i + 2) {
			var x = coords[i];
			var y = coords[i + 1];
			var currPoint = { x: x, y: y };
			pointCircle.center = currPoint;
			if ($tab_GeometryUtil.polygonIntersectsCircle(polygon, pointCircle)) {
				return true;
			}
		}
		return false;
	};
	$tab_GeometryUtil.polygonIntersectsRect = function GeometryUtil$PolygonIntersectsRect(polygon, rect) {
		return $tab_GeometryUtil.$polygonIntersectsPolygon(polygon, $tab_GeometryUtil.$clockwiseCornersFromRect(rect));
	};
	$tab_GeometryUtil.polygonIntersectsDoubleRect = function GeometryUtil$PolygonIntersectsDoubleRect(pointList, rect) {
		return $tab_GeometryUtil.$polygonIntersectsPolygon(pointList, $tab_GeometryUtil.$clockwiseCornersFromDoubleRect(rect));
	};
	$tab_GeometryUtil.$polygonIntersectsPolygon = function GeometryUtil$PolygonIntersectsPolygon(polyA, polyB) {
		if (polyA.length === 0 || polyB.length === 0) {
			return false;
		}
		if ($tab_GeometryUtil.isPointInPoly(polyB, { x: polyA[0], y: polyA[1] }, null)) {
			return true;
		}
		if ($tab_GeometryUtil.isPointInPoly(polyA, { x: polyB[0], y: polyB[1] }, null)) {
			return true;
		}
		if (polyA.length > polyB.length) {
			var temp = polyA;
			polyA = polyB;
			polyB = temp;
		}
		for (var i = 0, l = polyA.length; i < l; i += 2) {
			var nextIndex = (i + 2) % l;
			if ($tab_GeometryUtil.$polygonIntersectsSegment(polyB, polyA[i], polyA[i + 1], polyA[nextIndex], polyA[nextIndex + 1])) {
				return true;
			}
		}
		return false;
	};
	$tab_GeometryUtil.$polygonIntersectsSegment = function GeometryUtil$PolygonIntersectsSegment(poly, aX, aY, bX, bY) {
		var baX = bX - aX;
		var baY = bY - aY;
		var count = poly.length;
		for (var i = 0; i < count; i += 2) {
			var nextIndex = (i + 2) % count;
			var uX = poly[i];
			var uY = poly[i + 1];
			var vX = poly[nextIndex];
			var vY = poly[nextIndex + 1];
			var whichSideU = baX * (uY - bY) - baY * (uX - bX);
			var whichSideV = baX * (vY - bY) - baY * (vX - bX);
			if (whichSideU < 0 && whichSideV < 0 || whichSideU > 0 && whichSideV > 0) {
				continue;
			}
			var vuX = vX - uX;
			var vuY = vY - uY;
			var whichSideA = vuX * (aY - vY) - vuY * (aX - vX);
			var whichSideB = vuX * (bY - vY) - vuY * (bX - vX);
			if (whichSideU !== 0 && whichSideV !== 0) {
				if (whichSideA < 0 && whichSideB > 0 || whichSideA > 0 && whichSideB < 0) {
					return true;
				}
				else if (whichSideA !== 0 && whichSideB !== 0) {
					continue;
				}
			}
			var whichSides = [whichSideA, whichSideB, whichSideU, whichSideV];
			var coords = [aX, aY, bX, bY, uX, uY, vX, vY];
			if ($tab_GeometryUtil.$doLineSegmentsIntersectHelper(whichSides, coords)) {
				return true;
			}
		}
		return false;
	};
	$tab_GeometryUtil.$doLineSegmentsIntersectHelper = function GeometryUtil$DoLineSegmentsIntersectHelper(whichSides, coords) {
		var correspondingLineEndpoint1 = [4, 4, 0, 0];
		var correspondingLineEndpoint2 = [6, 6, 2, 2];
		for (var i = 0, coordIndex = 0, l = 4; i < l; i++, coordIndex += 2) {
			if (whichSides[i] === 0) {
				var aX = coords[coordIndex];
				var aY = coords[coordIndex + 1];
				var uX = coords[correspondingLineEndpoint1[i]];
				var uY = coords[correspondingLineEndpoint1[i] + 1];
				var vX = coords[correspondingLineEndpoint2[i]];
				var vY = coords[correspondingLineEndpoint2[i] + 1];
				if (aX >= Math.min(uX, vX) && aX <= Math.max(uX, vX) && aY >= Math.min(uY, vY) && aY <= Math.max(uY, vY)) {
					return true;
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multipolygonIntersectsCircle = function GeometryUtil$MultipolygonIntersectsCircle(multipolygon, circle) {
		for (var $t1 = 0; $t1 < multipolygon.polygonList.length; $t1++) {
			var polygon = multipolygon.polygonList[$t1];
			for (var $t2 = 0; $t2 < polygon.lineList.length; $t2++) {
				var ring = polygon.lineList[$t2];
				if ($tab_GeometryUtil.polygonIntersectsCircle(ring.pointsF, circle)) {
					return true;
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multiLineStringIntersectsCircle = function GeometryUtil$MultiLineStringIntersectsCircle(multiline, circle, width) {
		for (var $t1 = 0; $t1 < multiline.lineList.length; $t1++) {
			var line = multiline.lineList[$t1];
			var coords = line.pointsF;
			var coordCount = coords.length;
			if (coordCount < 4 || coordCount % 2 === 1) {
				continue;
			}
			for (var i = 0; i < coordCount - 2; i += 2) {
				var lineSegment = new Array(4);
				lineSegment[0] = coords[i];
				lineSegment[1] = coords[i + 1];
				lineSegment[2] = coords[i + 2];
				lineSegment[3] = coords[i + 3];
				if ($tab_GeometryUtil.polygonIntersectsCircle($tab_GeometryUtil.lineToQuad(lineSegment, width), circle)) {
					return true;
				}
				if (i >= 2) {
					var jointPoint = { x: coords[i], y: coords[i + 1] };
					var jointCircle = { center: jointPoint, radius: width / 2 };
					if ($tab_GeometryUtil.circleIntersectsCircle(circle, jointCircle)) {
						return true;
					}
				}
			}
		}
		return false;
	};
	$tab_GeometryUtil.multipointIntersectsCircle = function GeometryUtil$MultipointIntersectsCircle(multipoint, circle, radius) {
		var coords = multipoint.pointsF;
		var pointCircle = { center: { x: 0, y: 0 }, radius: radius };
		for (var i = 0; i < coords.length; i = i + 2) {
			var x = coords[i];
			var y = coords[i + 1];
			var currPoint = { x: x, y: y };
			pointCircle.center = currPoint;
			if ($tab_GeometryUtil.circleIntersectsCircle(circle, pointCircle)) {
				return true;
			}
		}
		return false;
	};
	$tab_GeometryUtil.circleIntersectsCircle = function GeometryUtil$CircleIntersectsCircle(c1, c2) {
		var distanceSquared = Math.pow(c1.center.x - c2.center.x, 2) + Math.pow(c1.center.y - c2.center.y, 2);
		return Math.pow(c1.radius + c2.radius, 2) >= distanceSquared;
	};
	$tab_GeometryUtil.polygonIntersectsCircle = function GeometryUtil$PolygonIntersectsCircle(poly, circle) {
		if (poly.length === 0 || circle.radius === 0) {
			return false;
		}
		if ($tab_GeometryUtil.isPointInPoly(poly, circle.center, null)) {
			return true;
		}
		if ($tab_GeometryUtil.isPointInCircle({ x: poly[0], y: poly[1] }, circle)) {
			return true;
		}
		var radiusSquared = circle.radius * circle.radius;
		for (var i = 0, l = poly.length; i < l; i += 2) {
			var x0 = poly[i];
			var y0 = poly[i + 1];
			var nextIndex = (i + 2) % l;
			var x1 = poly[nextIndex];
			var y1 = poly[nextIndex + 1];
			var dy = y1 - y0;
			var dx = x1 - x0;
			var distanceSquared = dx * dx + dy * dy;
			var projectionRatio = ((circle.center.x - x0) * dx + (circle.center.y - y0) * dy) / distanceSquared;
			projectionRatio = Math.min(1, Math.max(0, projectionRatio));
			var projectedX = x0 + projectionRatio * dx;
			var projectedY = y0 + projectionRatio * dy;
			dx = projectedX - circle.center.x;
			dy = projectedY - circle.center.y;
			distanceSquared = dx * dx + dy * dy;
			if (radiusSquared > distanceSquared) {
				return true;
			}
		}
		return false;
	};
	$tab_GeometryUtil.circleIntersectsRect = function GeometryUtil$CircleIntersectsRect(circle, rect) {
		if (circle.radius <= 0) {
			return false;
		}
		var rectCorners = $tab_GeometryUtil.$clockwiseCornerPointsFromRect(rect);
		for (var $t1 = 0; $t1 < rectCorners.length; $t1++) {
			var corner = rectCorners[$t1];
			if ($tab_GeometryUtil.isPointInCircle(corner, circle)) {
				return true;
			}
		}
		if (tab.RectXYUtil.inRectPointF(rect, circle.center)) {
			return true;
		}
		var halfWidth = rect.w / 2;
		var halfHeight = rect.h / 2;
		var rectCenter = { x: rect.x + halfWidth, y: rect.y + halfHeight };
		if (circle.center.y < rect.y || circle.center.y >= rect.y + rect.h) {
			return circle.center.x > rect.x && circle.center.x < rect.x + rect.w && Math.abs(rectCenter.y - circle.center.y) < halfHeight + circle.radius;
		}
		if (circle.center.x < rect.x || circle.center.x >= rect.x + rect.w) {
			return circle.center.y > rect.y && circle.center.y < rect.y + rect.h && Math.abs(rectCenter.x - circle.center.x) < halfWidth + circle.radius;
		}
		return false;
	};
	$tab_GeometryUtil.normalizeAngle = function GeometryUtil$NormalizeAngle(radians) {
		var newAngle = radians % $tab_GeometryUtil.twoPI;
		if (newAngle < 0) {
			newAngle += $tab_GeometryUtil.twoPI;
		}
		return newAngle;
	};
	$tab_GeometryUtil.isInBetweenAngles = function GeometryUtil$IsInBetweenAngles(target, angle1, angle2) {
		var flipped = false;
		if (angle1 > angle2) {
			var temp = angle1;
			angle1 = angle2;
			angle2 = temp;
			flipped = true;
		}
		if (angle1 <= target && angle2 >= target) {
			return !flipped;
		}
		return flipped;
	};
	$tab_GeometryUtil.isPointInCircle = function GeometryUtil$IsPointInCircle(p, circle) {
		var squareDist = Math.pow(p.x - circle.center.x, 2) + Math.pow(p.y - circle.center.y, 2);
		var squareRadius = circle.radius * circle.radius;
		var inside = squareDist < squareRadius;
		return inside;
	};
	$tab_GeometryUtil.isPointInWedge = function GeometryUtil$IsPointInWedge(p, wedgeCircle, startangle, endangle) {
		if (!$tab_GeometryUtil.isPointInCircle(p, wedgeCircle)) {
			return false;
		}
		var dx = p.x - wedgeCircle.center.x;
		var dy = p.y - wedgeCircle.center.y;
		var phi = Math.atan2(dy, dx);
		phi = $tab_GeometryUtil.normalizeAngle(phi);
		return $tab_GeometryUtil.isInBetweenAngles(phi, startangle, endangle);
	};
	$tab_GeometryUtil.rectIntersectsWedge = function GeometryUtil$RectIntersectsWedge(rect, wedgeCircle, startangle, endangle) {
		var rectCorners = $tab_GeometryUtil.$clockwiseCornerPointsFromRect(rect);
		for (var $t1 = 0; $t1 < rectCorners.length; $t1++) {
			var rectCorner = rectCorners[$t1];
			if ($tab_GeometryUtil.isPointInWedge(rectCorner, wedgeCircle, startangle, endangle)) {
				return true;
			}
		}
		if (tab.RectXYUtil.inRectPointF(rect, wedgeCircle.center)) {
			return true;
		}
		var polygon = $tab_GeometryUtil.$convertWedgeToPolygon(wedgeCircle, startangle, endangle);
		return $tab_GeometryUtil.polygonIntersectsRect(polygon, rect);
	};
	$tab_GeometryUtil.polygonIntersectsWedge = function GeometryUtil$PolygonIntersectsWedge(polygon, wedgeCircle, startangle, endangle) {
		if (polygon.length === 0) {
			return false;
		}
		if ($tab_GeometryUtil.isPointInWedge({ x: polygon[0], y: polygon[1] }, wedgeCircle, startangle, endangle)) {
			return true;
		}
		if ($tab_GeometryUtil.isPointInPoly(polygon, wedgeCircle.center, null)) {
			return true;
		}
		var wedgePoly = $tab_GeometryUtil.$convertWedgeToPolygon(wedgeCircle, startangle, endangle);
		return $tab_GeometryUtil.$polygonIntersectsPolygon(wedgePoly, polygon);
	};
	$tab_GeometryUtil.circleIntersectsWedge = function GeometryUtil$CircleIntersectsWedge(circle, wedgeCircle, startangle, endangle) {
		if (circle.radius <= 0) {
			return false;
		}
		if ($tab_GeometryUtil.isPointInWedge(circle.center, wedgeCircle, startangle, endangle)) {
			return true;
		}
		if ($tab_GeometryUtil.isPointInCircle(wedgeCircle.center, circle)) {
			return true;
		}
		var polygon = $tab_GeometryUtil.$convertWedgeToPolygon(wedgeCircle, startangle, endangle);
		return $tab_GeometryUtil.polygonIntersectsCircle(polygon, circle);
	};
	$tab_GeometryUtil.$convertWedgeToPolygon = function GeometryUtil$ConvertWedgeToPolygon(wedgeCircle, startangle, endangle) {
		while (startangle > endangle) {
			endangle += $tab_GeometryUtil.twoPI;
		}
		var sliceStart = startangle;
		var polygon = new Array(4);
		polygon[0] = wedgeCircle.center.x;
		polygon[1] = wedgeCircle.center.y;
		polygon[2] = wedgeCircle.center.x + Math.cos(sliceStart) * wedgeCircle.radius;
		polygon[3] = wedgeCircle.center.y + Math.sin(sliceStart) * wedgeCircle.radius;
		while (sliceStart < endangle) {
			var sliceEnd = Math.min(sliceStart + $tab_GeometryUtil.$maxWedgeIntersectionAngle, endangle);
			polygon.push(wedgeCircle.center.x + Math.cos(sliceEnd) * wedgeCircle.radius);
			polygon.push(wedgeCircle.center.y + Math.sin(sliceEnd) * wedgeCircle.radius);
			sliceStart = sliceEnd;
		}
		return polygon;
	};
	$tab_GeometryUtil.areRectanglesIntersecting = function GeometryUtil$AreRectanglesIntersecting(rect1, rect2) {
		return tab.RectXYUtil.intersectsWith(rect1, rect2);
	};
	$tab_GeometryUtil.getSquaredDistanceToCenter = function GeometryUtil$GetSquaredDistanceToCenter(bound, selectionPoint) {
		var centerX = bound.x + bound.w / 2;
		var centerY = bound.y + bound.h / 2;
		var dx = centerX - selectionPoint.x;
		var dy = centerY - selectionPoint.y;
		return dx * dx + dy * dy;
	};
	$tab_GeometryUtil.getSquaredDistanceToNearestSide = function GeometryUtil$GetSquaredDistanceToNearestSide(bound, selectionPoint) {
		var top = bound.y;
		var bottom = bound.y + bound.h;
		var left = bound.x;
		var right = bound.x + bound.w;
		var dx, dy;
		if (selectionPoint.x < left) {
			dx = left - selectionPoint.x;
		}
		else if (selectionPoint.x > right) {
			dx = selectionPoint.x - right;
		}
		else {
			dx = 0;
		}
		if (selectionPoint.y < top) {
			dy = top - selectionPoint.y;
		}
		else if (selectionPoint.y > bottom) {
			dy = selectionPoint.y - bottom;
		}
		else {
			dy = 0;
		}
		return dx * dx + dy * dy;
	};
	$tab_GeometryUtil.getSquaredDistanceToCircumference = function GeometryUtil$GetSquaredDistanceToCircumference(bound, selectionPoint) {
		var distance = Math.sqrt($tab_GeometryUtil.getSquaredDistanceToCenter(bound, selectionPoint)) - Math.min(bound.w, bound.h) / 2;
		distance = Math.max(distance, 0);
		return distance * distance;
	};
	$tab_GeometryUtil.getSquaredDistanceToLineSegment = function GeometryUtil$GetSquaredDistanceToLineSegment(selectionPoint, a, b) {
		var dx, dy;
		if (b.x < a.x) {
			var temp = a;
			a = b;
			b = temp;
		}
		var diffX = b.x - a.x;
		var diffY = b.y - a.y;
		var magnitudeAB = diffX * diffX + diffY * diffY;
		if (magnitudeAB === 0) {
			dx = selectionPoint.x - a.x;
			dy = selectionPoint.y - a.y;
			return dx * dx + dy * dy;
		}
		var t = ((selectionPoint.x - a.x) * diffX + (selectionPoint.y - a.y) * diffY) / magnitudeAB;
		var intersectX;
		var intersectY;
		if (t < 0) {
			intersectX = a.x;
			intersectY = a.y;
		}
		else if (t > 1) {
			intersectX = b.x;
			intersectY = b.y;
		}
		else {
			intersectX = a.x + t * diffX;
			intersectY = a.y + t * diffY;
		}
		dx = selectionPoint.x - intersectX;
		dy = selectionPoint.y - intersectY;
		return dx * dx + dy * dy;
	};
	$tab_GeometryUtil.degreeToRad = function GeometryUtil$DegreeToRad(degrees) {
		return degrees * (Math.PI / 180);
	};
	$tab_GeometryUtil.radToDegree = function GeometryUtil$RadToDegree(radians) {
		return radians * (180 / Math.PI);
	};
	$tab_GeometryUtil.haversineDistance = function GeometryUtil$HaversineDistance(lonLat1, lonLat2, radius) {
		var lonDeltaRad = $tab_GeometryUtil.degreeToRad(lonLat2.item1 - lonLat1.item1);
		var lat1Rad = $tab_GeometryUtil.degreeToRad(lonLat1.item2);
		var lat2Rad = $tab_GeometryUtil.degreeToRad(lonLat2.item2);
		var latDeltaRad = lat2Rad - lat1Rad;
		var a = Math.pow(Math.sin(latDeltaRad / 2), 2) + Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.pow(Math.sin(lonDeltaRad / 2), 2);
		var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return c * radius;
	};
	$tab_GeometryUtil.$isLeft = function GeometryUtil$IsLeft(x0, y0, x1, y1, x2, y2) {
		return (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0);
	};
	$tab_GeometryUtil.$clockwiseCornerPointsFromRect = function GeometryUtil$ClockwiseCornerPointsFromRect(rect) {
		var corners = new Array(4);
		corners[0] = { x: rect.x, y: rect.y };
		corners[1] = { x: rect.x + rect.w, y: rect.y };
		corners[2] = { x: rect.x + rect.w, y: rect.y + rect.h };
		corners[3] = { x: rect.x, y: rect.y + rect.h };
		return corners;
	};
	$tab_GeometryUtil.$clockwiseCornersFromRect = function GeometryUtil$ClockwiseCornersFromRect(rect) {
		var corners = new Array(8);
		corners[0] = rect.x;
		corners[1] = rect.y;
		corners[2] = rect.x + rect.w;
		corners[3] = rect.y;
		corners[4] = corners[2];
		corners[5] = rect.y + rect.h;
		corners[6] = rect.x;
		corners[7] = corners[5];
		return corners;
	};
	$tab_GeometryUtil.$clockwiseCornersFromDoubleRect = function GeometryUtil$ClockwiseCornersFromDoubleRect(rect) {
		var corners = new Array(8);
		corners[0] = rect.x;
		corners[1] = rect.y;
		corners[2] = rect.x + rect.w;
		corners[3] = rect.y;
		corners[4] = corners[2];
		corners[5] = rect.y + rect.h;
		corners[6] = rect.x;
		corners[7] = corners[5];
		return corners;
	};
	global.tab.GeometryUtil = $tab_GeometryUtil;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.GotoMyLocationButton
	var $tab_GotoMyLocationButton = function(visualIdPresModel) {
		this.$visualIdPresModel = null;
		this.$button = null;
		spiff.Widget.call(this, $($tab_GotoMyLocationButton.$htmlTemplate));
		if (!BrowserSupport.BrowserSupport.IsGeolocationSupported() || tab.ApplicationModel.get_instance().get_isOffline()) {
			return;
		}
		this.$visualIdPresModel = visualIdPresModel;
		this.$button = spiff.LabelButton.newNativeButton();
		this.get_button().addClass('tabGotoMyLocationButton');
		this.get_button().element.attr('title', tab.Strings.GotoMyLocationTooltip);
		this.get_button().add_click(ss.mkdel(this, this.$handleButtonClick));
		this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
			this.get_button().remove_click(ss.mkdel(this, this.$handleButtonClick));
		})));
		this.get_button().addToDom(this.element);
	};
	$tab_GotoMyLocationButton.__typeName = 'tab.GotoMyLocationButton';
	$tab_GotoMyLocationButton.$browserRequiresSSLForLocationRequests = function GotoMyLocationButton$BrowserRequiresSSLForLocationRequests() {
		if (BrowserSupport.BrowserSupport.IsChrome() && BrowserSupport.BrowserSupport.GoogleChromeVersion() >= 50) {
			return true;
		}
		if (BrowserSupport.BrowserSupport.IsIos() && BrowserSupport.BrowserSupport.IosVersion() >= 10) {
			return true;
		}
		if (BrowserSupport.BrowserSupport.IsSafari() && BrowserSupport.BrowserSupport.SafariVersion() >= 10) {
			return true;
		}
		return false;
	};
	global.tab.GotoMyLocationButton = $tab_GotoMyLocationButton;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.GridLinesRenderer
	var $tab_GridLinesRenderer = function(canvasElt, context) {
		tab.CanvasRenderer.call(this, canvasElt, context);
	};
	$tab_GridLinesRenderer.__typeName = 'tab.GridLinesRenderer';
	$tab_GridLinesRenderer.$linesToRender = function GridLinesRenderer$LinesToRender(gridlines, tickPlacement, colIndex, yIndex) {
		return $tab_GridLinesRenderer.$tickPlacementInDataStore(tickPlacement) && ($tab_GridLinesRenderer.$gridLinesInDataStoreX(gridlines) || $tab_GridLinesRenderer.$gridLinesInDataStoreY(gridlines)) || $tab_GridLinesRenderer.$zeroLineInDataStoreX(gridlines, colIndex) || $tab_GridLinesRenderer.$zeroLineInDataStoreY(gridlines, yIndex);
	};
	$tab_GridLinesRenderer.$tickPlacementInDataStore = function GridLinesRenderer$TickPlacementInDataStore(tickPlacement) {
		return !ss.isNullOrUndefined(tickPlacement);
	};
	$tab_GridLinesRenderer.$gridLinesInDataStoreX = function GridLinesRenderer$GridLinesInDataStoreX(gridlines) {
		return !ss.isNullOrUndefined(gridlines.X) && !ss.isNullOrUndefined(gridlines.X.LineWidth);
	};
	$tab_GridLinesRenderer.$gridLinesInDataStoreY = function GridLinesRenderer$GridLinesInDataStoreY(gridlines) {
		return !ss.isNullOrUndefined(gridlines.Y) && !ss.isNullOrUndefined(gridlines.Y.LineWidth);
	};
	$tab_GridLinesRenderer.$isReverseX = function GridLinesRenderer$IsReverseX(axisOutput, index) {
		var isReversed = axisOutput.XAxisTable.IsReversed;
		return isReversed.length >= index + 1 && isReversed[index];
	};
	$tab_GridLinesRenderer.$isReverseY = function GridLinesRenderer$IsReverseY(axisOutput, index) {
		var isReversed = axisOutput.YAxisTable.IsReversed;
		return isReversed.length >= index + 1 && isReversed[index];
	};
	$tab_GridLinesRenderer.$zeroLineInDataStoreX = function GridLinesRenderer$ZeroLineInDataStoreX(gridlines, index) {
		return gridlines.IsQuantitativeTickType[index] && !ss.isNullOrUndefined(gridlines.X) && !ss.isNullOrUndefined(gridlines.X.ZeroLineWidth);
	};
	$tab_GridLinesRenderer.$zeroLineInDataStoreY = function GridLinesRenderer$ZeroLineInDataStoreY(gridlines, index) {
		return gridlines.IsQuantitativeTickType[index] && !ss.isNullOrUndefined(gridlines.Y) && !ss.isNullOrUndefined(gridlines.Y.ZeroLineWidth);
	};
	$tab_GridLinesRenderer.$domainToCoord = function GridLinesRenderer$DomainToCoord(pt, reversed) {
		return (reversed ? (1 - pt) : pt);
	};
	$tab_GridLinesRenderer.$domainToPixelX = function GridLinesRenderer$DomainToPixelX(paneRect, pt, reversed) {
		return $tab_GridLinesRenderer.$domainToCoord(pt, reversed) * paneRect.w;
	};
	$tab_GridLinesRenderer.$domainToPixelY = function GridLinesRenderer$DomainToPixelY(paneRect, pt, reversed) {
		return $tab_GridLinesRenderer.$domainToCoord(pt, reversed) * paneRect.h;
	};
	$tab_GridLinesRenderer.$calculatePointX = function GridLinesRenderer$CalculatePointX(paneRect, pt, reversed) {
		return ss.round(paneRect.x + $tab_GridLinesRenderer.$domainToPixelX(paneRect, pt, reversed));
	};
	$tab_GridLinesRenderer.$calculatePointY = function GridLinesRenderer$CalculatePointY(paneRect, pt, reversed) {
		return ss.round(paneRect.y + paneRect.h - $tab_GridLinesRenderer.$domainToPixelY(paneRect, pt, reversed));
	};
	global.tab.GridLinesRenderer = $tab_GridLinesRenderer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.HackyShapeSwatchRenderer
	var $tab_HackyShapeSwatchRenderer = function(canvas, context, xPos, yPos, swatchWidth, swatchHeight, swatchBgColor) {
		this.$fakePaneDrawInfo = null;
		this.$shapeToMarkMap = null;
		this.$context = null;
		$tab_MarksRenderer.call(this, canvas, context);
		this.$shapeToMarkMap = {};
		var customShapes = tab.ApplicationModel.get_instance().get_shapeManager().get_imageKeys();
		var markCount = ss.getKeyCount(tab.SceneDataUtil.shapeMapping) + customShapes.length;
		var ShapeSwatchStrokeWidth = 2;
		var defaultSwatchWidth = swatchWidth - 4;
		var defaultSwatchHeight = swatchHeight - 4;
		var defaultLeft = xPos - defaultSwatchWidth / 2;
		var defaultTop = yPos - defaultSwatchHeight / 2;
		var customSwatchWidth = swatchWidth - 1;
		var customSwatchHeight = swatchHeight - 1;
		var customLeft = xPos - customSwatchWidth / 2;
		var customTop = yPos - customSwatchHeight / 2;
		var tupleCol = this.$createBlankDataColumnPresModel(markCount);
		var dataCol = this.$createBlankDataColumnPresModel(markCount);
		var widthColumn = this.$createBlankDataColumnPresModel(markCount);
		var heightColumn = this.$createBlankDataColumnPresModel(markCount);
		var leftColumn = this.$createBlankDataColumnPresModel(markCount);
		var topColumn = this.$createBlankDataColumnPresModel(markCount);
		for (var markNum = 0; markNum < markCount; markNum++) {
			var key;
			if (markNum < ss.getKeyCount(tab.SceneDataUtil.shapeMapping)) {
				key = _.keys(tab.SceneDataUtil.shapeMapping)[markNum];
				widthColumn.dataValues[markNum] = defaultSwatchWidth;
				heightColumn.dataValues[markNum] = defaultSwatchHeight;
				leftColumn.dataValues[markNum] = defaultLeft;
				topColumn.dataValues[markNum] = defaultTop;
			}
			else {
				key = customShapes[markNum - ss.getKeyCount(tab.SceneDataUtil.shapeMapping)];
				widthColumn.dataValues[markNum] = customSwatchWidth;
				heightColumn.dataValues[markNum] = customSwatchHeight;
				leftColumn.dataValues[markNum] = customLeft;
				topColumn.dataValues[markNum] = customTop;
			}
			this.$shapeToMarkMap[key] = markNum;
			dataCol.dataValues[markNum] = key;
			tupleCol.dataValues[markNum] = markNum.toString();
		}
		var dataStore = {};
		var pdKey = 'pdKey';
		dataStore.PDMarks = {};
		dataStore.PDMarks[pdKey] = {};
		var markLayout = dataStore.PDMarks[pdKey];
		var encodings = { shape_id: dataCol.dataValues, tuple_id: tupleCol.dataValues, size: widthColumn.dataValues, width: widthColumn.dataValues, height: heightColumn.dataValues };
		var encodingsDict = encodings;
		encodingsDict['left'] = leftColumn.dataValues;
		encodingsDict['top'] = topColumn.dataValues;
		markLayout.Encodings = encodings;
		markLayout.color = (new tab.ColorModel(0, 0, 0, 1)).toArgbInt();
		var markLayoutData = { Parameters: {} };
		var parameters = markLayoutData.Parameters;
		parameters.background_color = swatchBgColor.toArgbInt();
		parameters.PrimitiveType = 4;
		markLayout.MarkLayoutData = markLayoutData;
		encodings.x = new Array(encodings.width.length);
		encodings.y = new Array(encodings.width.length);
		for (var i = 0; i < encodings.x.length; ++i) {
			encodings.x[i] = xPos;
			encodings.y[i] = yPos;
		}
		var pane = { Rect: [0, 0, swatchWidth, swatchHeight] };
		var paneMarks = new tab.PaneMarksInfo(0, markCount);
		var sceneInfo = new $tab_SceneInfo();
		dataStore.PDMarks = {};
		dataStore.PDMarks['pdKey'] = markLayout;
		this.$fakePaneDrawInfo = new $tab_PaneDrawInfo.$ctor1('pdKey', sceneInfo, pane, paneMarks, null, 'pdKey', dataStore, 0);
	};
	$tab_HackyShapeSwatchRenderer.__typeName = 'tab.HackyShapeSwatchRenderer';
	global.tab.HackyShapeSwatchRenderer = $tab_HackyShapeSwatchRenderer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.HitResultHitType
	var $tab_HitResultHitType = function() {
	};
	$tab_HitResultHitType.__typeName = 'tab.HitResultHitType';
	global.tab.HitResultHitType = $tab_HitResultHitType;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.HitTargetNode
	var $tab_HitTargetNode = function(boundingBox, nodeType, objectId, labelBoundingBox, worldOffset) {
		this.$children = null;
		this.$boundingBox = null;
		this.$nodeType = 0;
		this.$objectId = 0;
		this.$labelBoundingBox = null;
		this.$worldOffset = 0;
		this.$parent = null;
		this.$paneKey = null;
		this.$paneIndex = 0;
		this.$paneOrderIndex = 0;
		this.$boundingBox = boundingBox;
		if (ss.isNullOrUndefined(labelBoundingBox) || tab.RectXYUtil.isEmpty(labelBoundingBox)) {
			this.$labelBoundingBox = null;
		}
		else {
			this.$labelBoundingBox = labelBoundingBox;
		}
		this.$objectId = objectId;
		this.$worldOffset = worldOffset;
		this.$nodeType = nodeType;
		this.$children = [];
	};
	$tab_HitTargetNode.__typeName = 'tab.HitTargetNode';
	$tab_HitTargetNode.findPaneNode = function HitTargetNode$FindPaneNode(node) {
		if (ss.isNullOrUndefined(node)) {
			return null;
		}
		while (node.$nodeType !== 0) {
			if (node.get_nodeType() === 1) {
				return node;
			}
			node = node.get_parent();
		}
		return null;
	};
	$tab_HitTargetNode.createRootNode = function HitTargetNode$CreateRootNode() {
		return new $tab_HitTargetNode({ x: 0, y: 0, w: 9999999, h: 9999999 }, 0, -1, null, 0);
	};
	global.tab.HitTargetNode = $tab_HitTargetNode;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.HitTestChain
	var $tab_HitTestChain = function(tapOrder, hoverOrder, hitTestDict) {
		this.$hitTestLinkDictionary = null;
		this.$hoverHitTestOrder = null;
		this.$tapHitTestOrder = null;
		this.$hitTestLinkDictionary = hitTestDict;
		this.$hoverHitTestOrder = hoverOrder;
		this.$tapHitTestOrder = tapOrder;
	};
	$tab_HitTestChain.__typeName = 'tab.HitTestChain';
	$tab_HitTestChain.$buildHitTestDictionary = function HitTestChain$BuildHitTestDictionary(order, ptvm, sceneInfo) {
		var hitTestLinkDictionary = {};
		for (var $t1 = 0; $t1 < order.length; $t1++) {
			var type = order[$t1];
			if (ss.keyExists(hitTestLinkDictionary, type)) {
				continue;
			}
			switch (type) {
				case 0: {
					hitTestLinkDictionary[type] = new $tab_AnnotationHitTestLink(ptvm);
					break;
				}
				case 1: {
					hitTestLinkDictionary[type] = new $tab_RefLineHitTestLink(ptvm, sceneInfo);
					break;
				}
				case 2: {
					hitTestLinkDictionary[type] = new $tab_TrendLineHitTestLink(ptvm);
					break;
				}
				case 3: {
					hitTestLinkDictionary[type] = new $tab_MarksHitTestLink(ptvm, sceneInfo);
					break;
				}
			}
		}
		return hitTestLinkDictionary;
	};
	$tab_HitTestChain.$createHitTestChain$1 = function HitTestChain$CreateHitTestChain(tapOrder, hoverOrder, ptvm, sceneInfo) {
		if (!ss.isValue(tapOrder) || !ss.isValue(hoverOrder)) {
			return null;
		}
		var hitTestLinkDictionary = $tab_HitTestChain.$buildHitTestDictionary(tapOrder.concat(hoverOrder), ptvm, sceneInfo);
		return new $tab_HitTestChain(tapOrder, hoverOrder, hitTestLinkDictionary);
	};
	$tab_HitTestChain.$createHitTestChain = function HitTestChain$CreateHitTestChain(order, ptvm, sceneInfo) {
		if (!ss.isValue(order)) {
			return null;
		}
		var hitTestLinkDictionary = $tab_HitTestChain.$buildHitTestDictionary(order, ptvm, sceneInfo);
		return new $tab_HitTestChain(order, order, hitTestLinkDictionary);
	};
	$tab_HitTestChain.createHitTestChain = function HitTestChain$CreateHitTestChain(ptvm, sceneInfo) {
		if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
			return $tab_HitTestChain.$buildLocalTapHitTestChain(ptvm, sceneInfo);
		}
		else {
			return $tab_HitTestChain.$buildServerHitTestChain(ptvm);
		}
	};
	$tab_HitTestChain.$buildServerHitTestChain = function HitTestChain$BuildServerHitTestChain(ptvm) {
		return $tab_HitTestChain.$createHitTestChain($tab_HitTestChain.$serverHitTestOrder, ptvm, null);
	};
	$tab_HitTestChain.$buildLocalTapHitTestChain = function HitTestChain$BuildLocalTapHitTestChain(ptvm, sceneInfo) {
		return ($tab_AnnotationSelectionChromeViewModel.canAnnotationInCurrentSheetType() ? $tab_HitTestChain.$createHitTestChain$1($tab_HitTestChain.$localTapHitTestOrder, $tab_HitTestChain.$localHoverHitTestOrder, ptvm, sceneInfo) : $tab_HitTestChain.$createHitTestChain($tab_HitTestChain.$localStoryHitTestOrder, ptvm, sceneInfo));
	};
	global.tab.HitTestChain = $tab_HitTestChain;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.HitTestDebugger
	var $tab_HitTestDebugger = function() {
		this.$oldPosSetting = null;
		this.$vizCanvasEl = null;
		this.$debugCanvasEl = null;
		this.$canvasParentContainer = null;
		var obj = $('.tab-tvView .tabCanvas');
		var $t1 = obj.get(0);
		this.$vizCanvasEl = ss.cast($t1, ss.isValue($t1) && (ss.isInstanceOfType($t1, Element) && $t1.tagName === 'CANVAS'));
		this.$oldPosSetting = this.$vizCanvasEl.style.position;
		this.$vizCanvasEl.style.position = 'absolute';
		var $t2 = document.createElement('canvas');
		this.$debugCanvasEl = ss.cast($t2, ss.isValue($t2) && (ss.isInstanceOfType($t2, Element) && $t2.tagName === 'CANVAS'));
		this.$debugCanvasEl.width = this.$vizCanvasEl.width;
		this.$debugCanvasEl.height = this.$vizCanvasEl.height;
		this.$debugCanvasEl.style.position = 'absolute';
		this.$canvasParentContainer = ss.cast(this.$vizCanvasEl.parentNode, HTMLElement);
		this.$canvasParentContainer.appendChild(this.$debugCanvasEl);
	};
	$tab_HitTestDebugger.__typeName = 'tab.HitTestDebugger';
	$tab_HitTestDebugger.get_instance = function HitTestDebugger$get_Instance() {
		if (ss.isNullOrUndefined($tab_HitTestDebugger.$instance)) {
			$tab_HitTestDebugger.$instance = new $tab_HitTestDebugger();
		}
		return $tab_HitTestDebugger.$instance;
	};
	global.tab.HitTestDebugger = $tab_HitTestDebugger;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.HitTester
	var $tab_HitTester = function(root) {
		this.$root = null;
		this.$root = root;
	};
	$tab_HitTester.__typeName = 'tab.HitTester';
	$tab_HitTester.$exactHit = function HitTester$ExactHit(paneDrawInfo, selection, markIndex, pixelWorldOffset, primitiveType) {
		switch (primitiveType) {
			case 'area': {
				return $tab_MarksRenderer.areaMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'line': {
				return $tab_MarksRenderer.lineMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'multipolygon': {
				return $tab_MarksRenderer.multipolygonMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'pie': {
				return $tab_MarksRenderer.pieMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'shape': {
				return $tab_MarksRenderer.shapeMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'bar':
			case 'square': {
				return $tab_MarksRenderer.barMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'text': {
				return $tab_MarksRenderer.textMarkExactHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			default: {
				var offsetSelection = { x: selection.x - Math.round(pixelWorldOffset), y: selection.y, w: selection.w, h: selection.h };
				return tab.RectXYUtil.intersectsWith(offsetSelection, paneDrawInfo.getMarkBounds(markIndex));
			}
		}
	};
	$tab_HitTester.$nearHit = function HitTester$NearHit(paneDrawInfo, selection, markIndex, pixelWorldOffset, primitiveType) {
		switch (primitiveType) {
			case 'line': {
				return $tab_MarksRenderer.lineMarkNearHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'multipolygon': {
				return $tab_MarksRenderer.multipolygonMarkNearHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'shape': {
				return $tab_MarksRenderer.shapeMarkNearHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'bar':
			case 'square': {
				return $tab_MarksRenderer.barMarkNearHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'text': {
				return $tab_MarksRenderer.textMarkNearHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			case 'area': {
				return $tab_MarksRenderer.areaMarkNearHitTest(paneDrawInfo, selection.x - pixelWorldOffset, selection.y, markIndex);
			}
			default: {
				return false;
			}
		}
	};
	$tab_HitTester.rectangleAreaHit = function HitTester$RectangleAreaHit(paneDrawInfo, markBoundingBox, selection, markIndex, t, primitiveType) {
		var offsetSelection = (t.get_isNull() ? selection : tab.RectXYUtil.offsetRectF(selection, { x: -t.get_translateX(), y: -t.get_translateY() }));
		switch (primitiveType) {
			case 'area': {
				return $tab_MarksRenderer.areaMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			case 'line': {
				return $tab_MarksRenderer.lineMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			case 'multipolygon': {
				return $tab_MarksRenderer.multipolygonMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			case 'pie': {
				return $tab_MarksRenderer.pieMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			case 'shape': {
				return $tab_MarksRenderer.shapeMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			case 'text': {
				return $tab_MarksRenderer.textMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			case 'bar':
			case 'square': {
				return $tab_MarksRenderer.barMarkRectangleAreaHitTest(paneDrawInfo, offsetSelection, markIndex);
			}
			default: {
				return tab.RectXYUtil.intersectsWith(selection, markBoundingBox);
			}
		}
	};
	$tab_HitTester.circleAreaHit = function HitTester$CircleAreaHit(paneDrawInfo, markBoundingBox, selection, markIndex, t, primitiveType, radialDistanceHitTest) {
		var offsetCircle = (t.get_isNull() ? selection : tab.CircleUtil.offsetCircle(selection, { x: -t.get_translateX(), y: -t.get_translateY() }));
		var markOffsetBBox = (t.get_isNull() ? markBoundingBox : tab.RectXYUtil.offsetRectF(markBoundingBox, { x: -t.get_translateX(), y: -t.get_translateY() }));
		switch (primitiveType) {
			case 'area': {
				return $tab_MarksRenderer.areaMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, markOffsetBBox, radialDistanceHitTest);
			}
			case 'line': {
				return $tab_MarksRenderer.lineMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, markOffsetBBox, radialDistanceHitTest);
			}
			case 'multipolygon': {
				return $tab_MarksRenderer.multipolygonMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, markOffsetBBox, radialDistanceHitTest);
			}
			case 'pie': {
				return $tab_MarksRenderer.pieMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, radialDistanceHitTest);
			}
			case 'shape': {
				return $tab_MarksRenderer.shapeMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, radialDistanceHitTest);
			}
			case 'text': {
				return $tab_MarksRenderer.textMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, markOffsetBBox, radialDistanceHitTest);
			}
			case 'bar':
			case 'square': {
				return $tab_MarksRenderer.barMarkCircleAreaHitTest(paneDrawInfo, offsetCircle, markIndex, markOffsetBBox, radialDistanceHitTest);
			}
			default: {
				return $tab_GeometryUtil.circleIntersectsRect(selection, markBoundingBox);
			}
		}
	};
	$tab_HitTester.polyAreaHit = function HitTester$PolyAreaHit(paneDrawInfo, markBoundingBox, offsetSelectionPts, markIndex, t, primitiveType) {
		var markOffsetBBox = (t.get_isNull() ? markBoundingBox : tab.RectXYUtil.offsetRectF(markBoundingBox, { x: -t.get_translateX(), y: -t.get_translateY() }));
		switch (primitiveType) {
			case 'area': {
				return $tab_MarksRenderer.areaMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex, markOffsetBBox);
			}
			case 'line': {
				return $tab_MarksRenderer.lineMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex, markOffsetBBox);
			}
			case 'multipolygon': {
				return $tab_MarksRenderer.multipolygonMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex, markOffsetBBox);
			}
			case 'pie': {
				return $tab_MarksRenderer.pieMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex);
			}
			case 'shape': {
				return $tab_MarksRenderer.shapeMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex);
			}
			case 'text': {
				return $tab_MarksRenderer.textMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex, markOffsetBBox);
			}
			case 'bar':
			case 'square': {
				return $tab_MarksRenderer.barMarkPolygonAreaHitTest(paneDrawInfo, offsetSelectionPts, markIndex, markOffsetBBox);
			}
			default: {
				return $tab_GeometryUtil.polygonIntersectsRect(offsetSelectionPts, markOffsetBBox);
			}
		}
	};
	$tab_HitTester.getTransformInfo = function HitTester$GetTransformInfo(paneDrawInfo, node) {
		var paneRect = paneDrawInfo.paneRect;
		var worldOffsetPixels = node.get_worldOffset();
		return tab.Transform.offset(paneRect.x + worldOffsetPixels, paneRect.y);
	};
	global.tab.HitTester = $tab_HitTester;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.HitTestLink
	var $tab_HitTestLink = function(ptvm) {
		this.paneTableVM = null;
		this.paneTableVM = ptvm;
	};
	$tab_HitTestLink.__typeName = 'tab.HitTestLink';
	global.tab.HitTestLink = $tab_HitTestLink;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.HitTestLinkType
	var $tab_HitTestLinkType = function() {
	};
	$tab_HitTestLinkType.__typeName = 'tab.HitTestLinkType';
	global.tab.HitTestLinkType = $tab_HitTestLinkType;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.HitTestResult
	var $tab_HitTestResult = function(sceneElement) {
		$tab_HitTestResult.$ctor1.call(this, ((sceneElement.get_visualPart() === 'marks') ? sceneElement.get_tupleId() : sceneElement.get_index()), (ss.keyExists($tab_HitTestResult.$visualPartMap, sceneElement.get_visualPart()) ? $tab_HitTestResult.$visualPartMap[sceneElement.get_visualPart()] : 1), (ss.keyExists($tab_HitTestResult.$hitTypeMap, sceneElement.get_hitType()) ? $tab_HitTestResult.$hitTypeMap[sceneElement.get_hitType()] : 0));
	};
	$tab_HitTestResult.__typeName = 'tab.HitTestResult';
	$tab_HitTestResult.$ctor1 = function(objectId, objType, hitType) {
		this.$id = 0;
		this.$hitObjectType = 0;
		this.$hitType = 0;
		this.$shouldRenderOverlay = false;
		this.$id = objectId;
		this.$hitObjectType = objType;
		this.$hitType = hitType;
		this.$shouldRenderOverlay = hitType !== 0;
	};
	$tab_HitTestResult.createEmptyHitTestResult = function HitTestResult$CreateEmptyHitTestResult() {
		return new $tab_HitTestResult.$ctor1(0, 0, 0);
	};
	$tab_HitTestResult.tieBreak = function HitTestResult$TieBreak(htr1, htr2) {
		if (htr1.get_hitType() > htr2.get_hitType() || htr1.get_hitType() === htr2.get_hitType() && (htr1.get_hitObjectType() > htr2.get_hitObjectType() || htr1.get_hitObjectType() === htr2.get_hitObjectType() && htr1.get_id() > htr2.get_id())) {
			return htr1;
		}
		return htr2;
	};
	$tab_HitTestResult.getIdsFromHitTestResults = function HitTestResult$GetIdsFromHitTestResults(objectHitsInfo, sort) {
		var set = new Set();
		for (var $t1 = 0; $t1 < objectHitsInfo.length; $t1++) {
			var objectHitInfo = objectHitsInfo[$t1];
			set.add(objectHitInfo.get_id());
		}
		var ids = tab.SetUtilities.getValues(ss.Int32).call(null, set);
		if (sort) {
			ids.sort(function(a, b) {
				return a - b;
			});
		}
		return ids;
	};
	$tab_HitTestResult.hasExactHit = function HitTestResult$HasExactHit(hitInfoArray) {
		for (var $t1 = 0; $t1 < hitInfoArray.length; $t1++) {
			var objectHitInfo = hitInfoArray[$t1];
			if (objectHitInfo.get_hitType() === 3) {
				return true;
			}
		}
		return false;
	};
	$tab_HitTestResult.tieBreakHits = function HitTestResult$TieBreakHits(firstResult, secondResult) {
		var toRet1 = $tab_HitTestResult.createEmptyHitTestResult();
		var toRet2 = $tab_HitTestResult.createEmptyHitTestResult();
		for (var $t1 = 0; $t1 < firstResult.length; $t1++) {
			var htr = firstResult[$t1];
			if (htr.get_hitType() === 3) {
				return htr;
			}
			if (htr.get_hitType() !== 0 && toRet1.get_hitType() === 0) {
				toRet1 = htr;
			}
		}
		for (var $t2 = 0; $t2 < secondResult.length; $t2++) {
			var htr1 = secondResult[$t2];
			if (htr1.get_hitType() === 3) {
				return htr1;
			}
			if (htr1.get_hitType() !== 0 && toRet2.get_hitType() === 0) {
				toRet2 = htr1;
			}
		}
		if (toRet1.get_hitType() !== 0) {
			return toRet1;
		}
		if (toRet2.get_hitType() !== 0) {
			return toRet2;
		}
		return $tab_HitTestResult.createEmptyHitTestResult();
	};
	global.tab.HitTestResult = $tab_HitTestResult;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.HitTestStructureBuilder
	var $tab_HitTestStructureBuilder = function() {
	};
	$tab_HitTestStructureBuilder.__typeName = 'tab.HitTestStructureBuilder';
	$tab_HitTestStructureBuilder.buildBinnedHitTestStructure = function HitTestStructureBuilder$BuildBinnedHitTestStructure(sceneInfo, binCount) {
		ss.Debug.assert(!ss.isNullOrUndefined(sceneInfo), "Parameter 'sceneInfo' is required to build HitTestStructure.");
		ss.Debug.assert(binCount > 0, "Parameter 'binCount' must be greater than or equal to zero.");
		var root = $tab_HitTargetNode.createRootNode();
		var markPaneOrderIndexCounter = 0;
		var panes = sceneInfo.get_runtimeData().get_annexedData().Panes;
		for (var $t1 = 0; $t1 < panes.length; $t1++) {
			var pane = panes[$t1];
			var paneMarkInfos = $tab_HitTestStructureBuilder.$getChildPaneMarkInfos(sceneInfo, pane);
			for (var $t2 = 0; $t2 < paneMarkInfos.length; $t2++) {
				var paneMarksInfo = paneMarkInfos[$t2];
				var paneDrawInfo = sceneInfo.getPaneDrawInfo(paneMarksInfo);
				var paneRect = paneDrawInfo.get_mapExtentOrPaneRect();
				var paneNode = new $tab_HitTargetNode(paneRect, 1, -1, null, 0);
				var paneKey = $tab_SceneInfo.getPaneMarksKey(paneMarksInfo);
				paneNode.set_paneKey(paneKey);
				paneNode.set_paneIndex(paneMarksInfo.get_paneIndex());
				paneNode.set_paneOrderIndex(markPaneOrderIndexCounter++);
				root.addNode(paneNode);
				var binWidth = Math.ceil(paneRect.w / binCount);
				for (var b = 0; b < binCount; ++b) {
					var binX = b * binWidth + paneRect.x;
					var binY = paneRect.y;
					var binW = binWidth;
					var binH = paneRect.h;
					var binNode = new $tab_HitTargetNode({ x: binX, y: binY, w: binW, h: binH }, 2, -1, null, 0);
					paneNode.addNode(binNode);
				}
				var markNodes = $tab_HitTestStructureBuilder.buildMarkBounds(paneDrawInfo, 0, paneDrawInfo.markCount - 1, paneDrawInfo.getAllMarkBounds());
				for (var $t3 = 0; $t3 < markNodes.length; $t3++) {
					var markNode = markNodes[$t3];
					var $t4 = paneNode.get_children();
					for (var $t5 = 0; $t5 < $t4.length; $t5++) {
						var binNode1 = $t4[$t5];
						if (tab.RectXYUtil.intersectsWith(markNode.get_boundingBox(), binNode1.get_boundingBox())) {
							binNode1.addNode(markNode);
						}
					}
				}
			}
		}
		return root;
	};
	$tab_HitTestStructureBuilder.buildLinearHitTestStructure = function HitTestStructureBuilder$BuildLinearHitTestStructure(sceneInfo) {
		ss.Debug.assert(!ss.isNullOrUndefined(sceneInfo), "Parameter 'sceneInfo' is required to build HitTestStructure.");
		var root = $tab_HitTargetNode.createRootNode();
		var markPaneOrderIndexCounter = 0;
		var panes = sceneInfo.get_runtimeData().safeFetchMarkPanes();
		for (var $t1 = 0; $t1 < panes.length; $t1++) {
			var pane = panes[$t1];
			var paneMarkInfos = $tab_HitTestStructureBuilder.$getChildPaneMarkInfos(sceneInfo, pane);
			for (var $t2 = 0; $t2 < paneMarkInfos.length; $t2++) {
				var paneMarkInfo = paneMarkInfos[$t2];
				var paneDrawInfo = sceneInfo.getPaneDrawInfo(paneMarkInfo);
				if (!ss.isValue(paneDrawInfo)) {
					continue;
				}
				var paneNode = $tab_HitTestStructureBuilder.$buildPaneHitTestStructure(paneMarkInfo, paneDrawInfo, markPaneOrderIndexCounter);
				root.addNode(paneNode);
				markPaneOrderIndexCounter++;
			}
		}
		return root;
	};
	$tab_HitTestStructureBuilder.buildTrendLineHitTestStructure = function HitTestStructureBuilder$BuildTrendLineHitTestStructure(trendLineDrawPath, lineWidth, objectId) {
		var points = trendLineDrawPath.pointsF;
		var instructions = trendLineDrawPath.pathElements;
		var numPoints = Math.floor(points.length / 2);
		if (numPoints < 2) {
			tab.Logger.lazyGetLogger($tab_HitTestStructureBuilder).error('Bad trend line. There are less then 2 points in the draw path.', []);
			return new $tab_HitTargetNode({ x: 0, y: 0, w: 0, h: 0 }, 0, -1, null, 0);
		}
		var lineSegmentNodes = [];
		var pc = 0;
		for (var $t1 = 0; $t1 < instructions.length; $t1++) {
			var instruction = instructions[$t1];
			switch (instruction) {
				case 'moveto': {
					{
						pc += 2;
					}
					break;
				}
				case 'lineto': {
					{
						if (ss.isValue(points[pc + 3])) {
							var line = [points[pc], points[pc + 1], points[pc + 2], points[pc + 3]];
							var rectX = ss.Int32.trunc(Math.min(line[0], line[2]));
							var rectY = ss.Int32.trunc(Math.min(line[1], line[3]));
							var rectW = ss.Int32.trunc(Math.max(line[0], line[2])) - rectX;
							var rectH = ss.Int32.trunc(Math.max(line[1], line[3])) - rectY;
							var bb = { x: rectX, y: rectY, w: rectW, h: rectH };
							bb = tab.RectXYUtil.dialate(bb, ss.Int32.trunc(lineWidth));
							var lineSegmentNode = new $tab_HitTargetNode(bb, 5, objectId, null, 0);
							lineSegmentNodes.push(lineSegmentNode);
						}
						pc += 2;
					}
					break;
				}
				case 'curveto': {
					{
						tab.Logger.lazyGetLogger($tab_HitTestStructureBuilder).debug("There's an unexpected %s instruction in trendline's draw path", ['curveto']);
						pc += 6;
					}
					break;
				}
				default: {
					{
						ss.Debug.fail('Unknown path instruction: ' + instruction);
					}
					break;
				}
			}
		}
		var root = $tab_HitTestStructureBuilder.$buildRectUnionHierarchy(lineSegmentNodes, 4);
		return root;
	};
	$tab_HitTestStructureBuilder.buildMarkBounds = function HitTestStructureBuilder$BuildMarkBounds(paneDrawInfo, startIdx, endIdx, markBounds) {
		var markCount = endIdx - startIdx + 1;
		var markNodes = [];
		var nodeCount = 0;
		for (var markIndex = startIdx; markIndex <= endIdx; ++markIndex) {
			var bb = markBounds[markIndex].item1;
			var lbb = markBounds[markIndex].item2;
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var newBound = bb;
				var newLabelBound = lbb;
				var offset = offsets[index];
				if (offset !== 0) {
					var intOffset = ss.Int32.trunc(offset);
					newBound = tab.RectXYUtil.offsetRectXY(bb, intOffset, 0);
					newLabelBound = (ss.isValue(lbb) ? tab.RectXYUtil.offsetRectXY(lbb, intOffset, 0) : null);
				}
				markNodes[nodeCount] = new $tab_HitTargetNode(newBound, 3, markIndex, newLabelBound, offset);
				++nodeCount;
			}
		}
		return markNodes;
	};
	$tab_HitTestStructureBuilder.print = function HitTestStructureBuilder$Print(node, lv) {
		var indent = '';
		var indentCount = lv;
		while (indentCount > 0) {
			indent += ' ';
			--indentCount;
		}
		console.log(indent + node.get_objectId());
		if (node.get_nodeType() !== 3) {
			node.get_children().forEach(function(n) {
				$tab_HitTestStructureBuilder.print(n, lv + 1);
			});
		}
	};
	$tab_HitTestStructureBuilder.$getChildPaneMarkInfos = function HitTestStructureBuilder$GetChildPaneMarkInfos(sceneInfo, pane) {
		var paneMarks = [];
		var drawPanes = pane.DrawPanes;
		for (var $t1 = 0; $t1 < drawPanes.length; $t1++) {
			var visualList = drawPanes[$t1];
			var panePartArray = visualList;
			var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
			if (visualPart === 'marks') {
				var paneIndex = panePartArray[1];
				var paneMarksInfo = new tab.PaneMarksInfo.$ctor1(sceneInfo.get_runtimeData().get_finalDataStore().Viewpoint.PerPaneExtents, sceneInfo.get_runtimeData().get_paneStoreTable(), paneIndex, sceneInfo.$currentPage, pane.Row, pane.Column);
				paneMarks.push(paneMarksInfo);
			}
		}
		return paneMarks;
	};
	$tab_HitTestStructureBuilder.$buildRectUnionHierarchy = function HitTestStructureBuilder$BuildRectUnionHierarchy(orderedLineSegmentNodes, unionSize) {
		var previousLevel = orderedLineSegmentNodes;
		while (previousLevel.length > 1) {
			var newLevel = [];
			for (var ii = 0; ii < previousLevel.length; ii += unionSize) {
				var howManyToUnion = unionSize;
				var remaining = previousLevel.length - ii;
				if (remaining < unionSize) {
					howManyToUnion = remaining;
				}
				var childrenOfUnion = [];
				var unionRect = null;
				for (var cc = 0; cc < howManyToUnion; ++cc) {
					var node = previousLevel[ii + cc];
					childrenOfUnion.push(node);
					if (cc === 0) {
						unionRect = { x: node.get_boundingBox().x, y: node.get_boundingBox().y, w: node.get_boundingBox().w, h: node.get_boundingBox().h };
					}
					else {
						unionRect = tab.RectXYUtil.union(unionRect, childrenOfUnion[cc].get_boundingBox());
					}
				}
				var parentOfUnion = new $tab_HitTargetNode(unionRect, 4, -1, null, 0);
				parentOfUnion.addNodes(childrenOfUnion);
				newLevel.push(parentOfUnion);
			}
			previousLevel = newLevel;
		}
		if (previousLevel.length !== 1) {
			tab.Logger.lazyGetLogger($tab_HitTestStructureBuilder).debug('Top rect hierarchy got more than 1 node (%i). This is most likely a bug.', [previousLevel.length]);
		}
		var root = $tab_HitTargetNode.createRootNode();
		root.addNodes(previousLevel);
		return root;
	};
	$tab_HitTestStructureBuilder.$buildPaneHitTestStructure = function HitTestStructureBuilder$BuildPaneHitTestStructure(paneMarksPM, paneDrawInfo, paneIndex) {
		var paneRect = paneDrawInfo.get_mapExtentOrPaneRect();
		var paneNode = new $tab_HitTargetNode(paneRect, 1, -1, null, 0);
		var paneKey = $tab_SceneInfo.getPaneMarksKey(paneMarksPM);
		paneNode.set_paneKey(paneKey);
		paneNode.set_paneIndex(paneMarksPM.get_paneIndex());
		paneNode.set_paneOrderIndex(paneIndex);
		var userPaneCount = (paneDrawInfo.hasUserPanes ? paneDrawInfo.userPaneCount : 1);
		var wholePaneX = paneDrawInfo.paneRect.x;
		var wholePaneY = paneDrawInfo.paneRect.y;
		var markBounds = paneDrawInfo.getAllMarkBounds();
		for (var i = 0; i < userPaneCount; ++i) {
			var userPaneRect = tab.RectXYUtil.offsetRectXY(paneDrawInfo.getUserPaneRectByIndex(i), wholePaneX, wholePaneY);
			var userPaneNode = new $tab_HitTargetNode(userPaneRect, 6, -1, null, 0);
			var range = paneDrawInfo.getUserPaneMarkRange(i);
			var markBoundingBoxNodes = $tab_HitTestStructureBuilder.buildMarkBounds(paneDrawInfo, range.firstMark, range.lastMark, markBounds);
			userPaneNode.addNodes(markBoundingBoxNodes);
			paneNode.addNode(userPaneNode);
		}
		return paneNode;
	};
	global.tab.HitTestStructureBuilder = $tab_HitTestStructureBuilder;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.IHitTestLink
	var $tab_IHitTestLink = function() {
	};
	$tab_IHitTestLink.__typeName = 'tab.IHitTestLink';
	global.tab.IHitTestLink = $tab_IHitTestLink;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ImageDownloaderImageData
	var $tab_ImageDownloaderImageData = function(imgNode, idx, src, bounds, version) {
		this.$imgNode = null;
		this.$idx = 0;
		this.$src = null;
		this.$bounds = null;
		this.$version = 0;
		this.$imgNode = imgNode;
		this.$idx = idx;
		this.$src = src;
		this.$bounds = bounds;
		this.$version = version;
	};
	$tab_ImageDownloaderImageData.__typeName = 'tab.ImageDownloaderImageData';
	global.tab.ImageDownloaderImageData = $tab_ImageDownloaderImageData;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ImageLoadedEventArgs
	var $tab_ImageLoadedEventArgs = function(image) {
		this.$image = null;
		ss.EventArgs.call(this);
		this.$image = image;
	};
	$tab_ImageLoadedEventArgs.__typeName = 'tab.ImageLoadedEventArgs';
	global.tab.ImageLoadedEventArgs = $tab_ImageLoadedEventArgs;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.IMapControl
	var $tab_IMapControl = function() {
	};
	$tab_IMapControl.__typeName = 'tab.IMapControl';
	global.tab.IMapControl = $tab_IMapControl;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.IMapsSearchViewTemplate
	var $tab_IMapsSearchViewTemplate = function() {
	};
	$tab_IMapsSearchViewTemplate.__typeName = 'tab.IMapsSearchViewTemplate';
	global.tab.IMapsSearchViewTemplate = $tab_IMapsSearchViewTemplate;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.InteractionColorModel
	var $tab_InteractionColorModel = function() {
		this.highlightBgColor = null;
		this.selectionBgColor = null;
		this.highlightTextColor = null;
		this.selectionTextColor = null;
		this.highlightBgColor = $tab_InteractionColorModel.defaultHighlightBgColor;
		this.selectionBgColor = $tab_InteractionColorModel.defaultSelectionBgColor;
		this.highlightTextColor = $tab_InteractionColorModel.defaultHighlightTextColor;
		this.selectionTextColor = $tab_InteractionColorModel.defaultSelectionTextColor;
	};
	$tab_InteractionColorModel.__typeName = 'tab.InteractionColorModel';
	$tab_InteractionColorModel.extractInteractionColors = function InteractionColorModel$ExtractInteractionColors(presModel) {
		var hasHighlightBgColor = ss.isValue(presModel) && !ss.isNullOrEmptyString(presModel.highlightBgColor);
		var hasHighlightTextColor = ss.isValue(presModel) && !ss.isNullOrEmptyString(presModel.highlightTextColor);
		var hasSelectionBgColor = ss.isValue(presModel) && !ss.isNullOrEmptyString(presModel.selectBgColor);
		var hasSelectionTextColor = ss.isValue(presModel) && !ss.isNullOrEmptyString(presModel.selectionTextColor);
		if (!hasHighlightBgColor && !hasSelectionBgColor && !hasSelectionTextColor && !hasHighlightTextColor) {
			return $tab_InteractionColorModel.defaultColors;
		}
		var colorModel = new $tab_InteractionColorModel();
		colorModel.highlightBgColor = (hasHighlightBgColor ? tab.ColorModel.fromColorCode(presModel.highlightBgColor) : colorModel.highlightBgColor);
		colorModel.selectionBgColor = (hasSelectionBgColor ? tab.ColorModel.fromColorCode(presModel.selectBgColor) : colorModel.selectionBgColor);
		colorModel.highlightTextColor = (hasHighlightTextColor ? tab.ColorModel.fromColorCode(presModel.highlightTextColor) : colorModel.highlightTextColor);
		colorModel.selectionTextColor = (hasSelectionTextColor ? tab.ColorModel.fromColorCode(presModel.selectionTextColor) : colorModel.selectionTextColor);
		return colorModel;
	};
	global.tab.InteractionColorModel = $tab_InteractionColorModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.IRuntimeUIModule
	var $tab_IRuntimeUIModule = function() {
	};
	$tab_IRuntimeUIModule.__typeName = 'tab.IRuntimeUIModule';
	global.tab.IRuntimeUIModule = $tab_IRuntimeUIModule;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.IVizContextMenuItemsHandler
	var $tab_IVizContextMenuItemsHandler = function() {
	};
	$tab_IVizContextMenuItemsHandler.__typeName = 'tab.IVizContextMenuItemsHandler';
	global.tab.IVizContextMenuItemsHandler = $tab_IVizContextMenuItemsHandler;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.IZoomToolbarContainer
	var $tab_IZoomToolbarContainer = function() {
	};
	$tab_IZoomToolbarContainer.__typeName = 'tab.IZoomToolbarContainer';
	global.tab.IZoomToolbarContainer = $tab_IZoomToolbarContainer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.LeafletMapControl
	var $tab_LeafletMapControl = function() {
		this.$deferredMap = null;
		this.$marksOverlay = null;
		this.$mapData = null;
		this.$localMapData = null;
		this.$mapSize = { w: 100, h: 100 };
		this.$mapTileLayer = null;
		this.$template = null;
		this.$touchAnimationFrame = 0;
		this.$pinching = false;
		this.$deltaAlreadyAccoundtedFor = null;
	};
	$tab_LeafletMapControl.__typeName = 'tab.LeafletMapControl';
	$tab_LeafletMapControl.$buildConstantColorDataUrl = function LeafletMapControl$BuildConstantColorDataUrl(colorCode) {
		var Size = 256;
		var $t1 = document.createElement('canvas');
		var canvas = ss.cast($t1, ss.isValue($t1) && (ss.isInstanceOfType($t1, Element) && $t1.tagName === 'CANVAS'));
		canvas.width = Size;
		canvas.height = Size;
		var context = tab.CanvasRenderer.getRenderContext(canvas, 'transparent');
		context.set_shapeFillStyle(colorCode);
		context.fillRect(0, 0, 256, 256);
		var toRet = canvas.toDataURL('png', null);
		return toRet;
	};
	$tab_LeafletMapControl.$latLngFromTuple = function LeafletMapControl$LatLngFromTuple(tuple) {
		return new L.LatLng(tuple.item1, tuple.item2);
	};
	global.tab.LeafletMapControl = $tab_LeafletMapControl;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.LineAttribute
	var $tab_LineAttribute = function(startIndex) {
		this.startIndex = 0;
		this.endIndex = 0;
		this.selectedCount = 0;
		this.highlightedCount = 0;
		this.marksNeedingDraw = [];
		this.worldOffsets = null;
		this.boundingBox = { x: 0, y: 0, w: 0, h: 0 };
		this.sloppyBoundingBox = { x: 0, y: 0, w: 0, h: 0 };
		this.startIndex = startIndex;
		this.endIndex = -1;
		this.selectedCount = 0;
		this.highlightedCount = 0;
	};
	$tab_LineAttribute.__typeName = 'tab.LineAttribute';
	global.tab.LineAttribute = $tab_LineAttribute;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.LineMarkDrawState
	var $tab_LineMarkDrawState = function(paneDrawInfo) {
		this.$lineAttributes = null;
		this.$lineAttributes = [];
		this.$reCompute(paneDrawInfo);
	};
	$tab_LineMarkDrawState.__typeName = 'tab.LineMarkDrawState';
	global.tab.LineMarkDrawState = $tab_LineMarkDrawState;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.LocalRenderVizHitTestDebouncer
	var $tab_LocalRenderVizHitTestDebouncer = function(paneTable, region, hitTester) {
		this.$hitTester = null;
		$tab_VizHitTestDebouncer.call(this, paneTable, region);
		this.$hitTester = hitTester;
	};
	$tab_LocalRenderVizHitTestDebouncer.__typeName = 'tab.LocalRenderVizHitTestDebouncer';
	global.tab.LocalRenderVizHitTestDebouncer = $tab_LocalRenderVizHitTestDebouncer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.LocalRenderVizHitTester
	var $tab_LocalRenderVizHitTester = function(hitTestChain, sceneInfo) {
		this.$hitTestChain = null;
		this.$sceneInfo = null;
		this.$hitTestChain = hitTestChain;
		this.$sceneInfo = sceneInfo;
	};
	$tab_LocalRenderVizHitTester.__typeName = 'tab.LocalRenderVizHitTester';
	global.tab.LocalRenderVizHitTester = $tab_LocalRenderVizHitTester;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.LocalRenderVizSelectionDispatcher
	var $tab_LocalRenderVizSelectionDispatcher = function() {
	};
	$tab_LocalRenderVizSelectionDispatcher.__typeName = 'tab.LocalRenderVizSelectionDispatcher';
	$tab_LocalRenderVizSelectionDispatcher.doSingleSelect = function LocalRenderVizSelectionDispatcher$DoSingleSelect(htr, coords, action, toolTipCallback, behavior, visualId, isZoneMultiSelect) {
		switch (htr.get_tooltipTargetType()) {
			case 'mark': {
				tab.SelectionClientCommands.selectMarksLocal([htr.get_id()], visualId, action, false, function() {
					toolTipCallback(htr);
				});
				break;
			}
			case 'refline': {
				tab.SelectionClientCommands.selectRefLinesLocal([htr.get_id()], visualId, action, function() {
					toolTipCallback(htr);
				});
				break;
			}
			case 'visualparts': {
				var selRect = { x: coords.x, y: coords.y, w: 1, h: 1 };
				tab.SelectionClientCommands.selectRectRegionAndDoUbertip('viz', selRect, action, visualId, function() {
					toolTipCallback(htr);
				}, behavior, null);
				break;
			}
			default: {
				if (htr.get_hitType() !== 0) {
					toolTipCallback(htr);
				}
				var shouldClearSelections = behavior === 'always-clear' || behavior === 'default' && action === 'simple';
				if (tab.FeatureFlags.isEnabled('MultiSelect') && isZoneMultiSelect) {
					var zoneId = tab.ModelUtils.getZoneIdForSheetName(visualId.worksheet);
					tab.SelectionClientCommands.setActiveZone(zoneId, 'add', null);
				}
				else if (shouldClearSelections) {
					tab.SelectionClientCommands.clearAllSelections(visualId);
				}
				break;
			}
		}
	};
	$tab_LocalRenderVizSelectionDispatcher.doMultiSelect = function LocalRenderVizSelectionDispatcher$DoMultiSelect(hitTestResults, action, tooltipCallback, visualId) {
		var objectIds = $tab_HitTestResult.getIdsFromHitTestResults(hitTestResults, false);
		if (tab.MiscUtil.isNullOrEmpty$2(objectIds)) {
			if (action === 'simple') {
				tab.SelectionClientCommands.clearAllSelections(visualId);
			}
			return false;
		}
		else {
			tab.SelectionClientCommands.selectMarksLocal(objectIds, visualId, action, true, tooltipCallback);
			return true;
		}
	};
	global.tab.LocalRenderVizSelectionDispatcher = $tab_LocalRenderVizSelectionDispatcher;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.MapAttributionTemplate
	var $tab_MapAttributionTemplate = function() {
		this.attributionBackground = null;
		this.attributionLink = null;
		this.attributionLink2 = null;
		spiff.Template.call(this, $($tab_MapAttributionTemplate.$htmlTemplate));
		this.attributionBackground = this.getElementBySelector('.tabMapAttributionBackground');
		this.attributionLink = this.getElementBySelector('.tabMapAttributionLink');
		this.attributionLink2 = this.getElementBySelector('.tabMapAttributionLink2');
	};
	$tab_MapAttributionTemplate.__typeName = 'tab.MapAttributionTemplate';
	global.tab.MapAttributionTemplate = $tab_MapAttributionTemplate;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.MapboxExpression
	var $tab_MapboxExpression = function() {
	};
	$tab_MapboxExpression.__typeName = 'tab.MapboxExpression';
	$tab_MapboxExpression.replaceString = function MapboxExpression$ReplaceString(expression, keyword, replacement) {
		if (tab.MiscUtil.isNullOrEmpty$3(replacement)) {
			return expression;
		}
		var str = ss.safeCast(expression, String);
		if (ss.isValue(str)) {
			if (ss.referenceEquals(str, keyword)) {
				return replacement;
			}
			else {
				return str;
			}
		}
		var list = ss.safeCast(expression, Array);
		if (ss.isNullOrUndefined(list)) {
			return expression;
		}
		var newExpression = ss.arrayClone(list);
		for (var i = 0; i < newExpression.length; ++i) {
			newExpression[i] = $tab_MapboxExpression.replaceString(newExpression[i], keyword, replacement);
		}
		return newExpression;
	};
	global.tab.MapboxExpression = $tab_MapboxExpression;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.MapboxMapControl
	var $tab_MapboxMapControl = function() {
		this.$deferredMap = null;
		this.$mapData = null;
		this.$localMapData = null;
		this.$mapSize = { w: 100, h: 100 };
		this.$interactable = false;
		this.$loaded = false;
		this.$renderer = 'unknown';
	};
	$tab_MapboxMapControl.__typeName = 'tab.MapboxMapControl';
	$tab_MapboxMapControl.$updateURL = function MapboxMapControl$UpdateURL(url, baseUrl, accessToken) {
		if (url.indexOf('access_token=') !== -1) {
			url = url.replace($tab_MapboxMapControl.$urlAccessTokenRegExp, 'access_token=' + accessToken);
		}
		if (!tab.MiscUtil.isNullOrEmpty$3(baseUrl)) {
			url = url.replace($tab_MapboxMapControl.$urlHostRegExp, baseUrl);
		}
		var $t1 = {};
		$t1['url'] = url;
		return $t1;
	};
	$tab_MapboxMapControl.$createAdjustedCanvasRect = function MapboxMapControl$CreateAdjustedCanvasRect(canvas, left, top, width, height, borderInset) {
		var pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
		if (!tab.CanvasUtil.canvasDensified(canvas)) {
			pixelRatio = 1;
		}
		var adjustedRect = { x: ss.Int32.trunc((left + borderInset) * pixelRatio), y: ss.Int32.trunc((top + borderInset) * pixelRatio), w: Math.max(ss.Int32.trunc((width - 2 * borderInset) * pixelRatio), 1), h: Math.max(ss.Int32.trunc((height - 2 * borderInset) * pixelRatio), 1) };
		return adjustedRect;
	};
	global.tab.MapboxMapControl = $tab_MapboxMapControl;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.MapControlMetrics
	var $tab_MapControlMetrics = function() {
	};
	$tab_MapControlMetrics.__typeName = 'tab.MapControlMetrics';
	$tab_MapControlMetrics.createLoadMapContext = function MapControlMetrics$CreateLoadMapContext(mapControlType, vizName) {
		var extraInfo = ss.mkdict(['viz', vizName]);
		return tabBootstrap.MetricsController.createContext(mapControlType + '_CreateMap', 32, JSON.stringify(extraInfo));
	};
	$tab_MapControlMetrics.createInteractiveContext = function MapControlMetrics$CreateInteractiveContext(mapControlType, vizName) {
		var extraInfo = ss.mkdict(['viz', vizName]);
		return tabBootstrap.MetricsController.createContext(mapControlType + '_FirstInteractive', 32, JSON.stringify(extraInfo));
	};
	global.tab.MapControlMetrics = $tab_MapControlMetrics;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.MapControlTelemetry
	var $tab_MapControlTelemetry = function() {
	};
	$tab_MapControlTelemetry.__typeName = 'tab.MapControlTelemetry';
	$tab_MapControlTelemetry.logMapCreateDone = function MapControlTelemetry$LogMapCreateDone(mapRecordPairs) {
		tab.OnlineAnalyticsClient.logEvent($tab_MapControlTelemetry.$createMapDoneEvent, mapRecordPairs);
	};
	global.tab.MapControlTelemetry = $tab_MapControlTelemetry;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.MapControlType
	var $tab_MapControlType = function() {
	};
	$tab_MapControlType.__typeName = 'tab.MapControlType';
	global.tab.MapControlType = $tab_MapControlType;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.MapRenderType
	var $tab_MapRenderType = function() {
	};
	$tab_MapRenderType.__typeName = 'tab.MapRenderType';
	global.tab.MapRenderType = $tab_MapRenderType;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.MapsSearchComponent
	var $tab_MapsSearchComponent = function(props, context) {
		ss.makeGenericType(spiff.ReactSpiffAdapter$3, [$tab_MapsSearchView, Object, Object]).call(this, tab.ObjectRegistry.newView($tab_MapsSearchView).call(null, [props.viewModel]), props, context);
		this.get_widget().set_isVisible(true);
		this.get_widget().set_isCollapsed(true);
	};
	$tab_MapsSearchComponent.__typeName = 'tab.MapsSearchComponent';
	global.tab.MapsSearchComponent = $tab_MapsSearchComponent;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.MapsSearchView
	var $tab_MapsSearchView = function(vm, mapsSearchViewTemplate) {
		this.mapsSearchViewModel = null;
		this.mapsSearchViewTemplate = null;
		this.$compositeSearchWidget = null;
		this.mapsSearchView = null;
		this.gotoMyLocationButton = null;
		this.$suggestionsListItemViewModels = null;
		this.$isCollapsed = false;
		this.$isVisible = true;
		this.queryDelayTimer = null;
		ss.makeGenericType(spiff.BaseView$1, [$tab_MapsSearchViewModel]).call(this, vm, mapsSearchViewTemplate.get_template());
		this.mapsSearchViewModel = vm;
		this.mapsSearchViewTemplate = mapsSearchViewTemplate;
		this.mapsSearchView = mapsSearchViewTemplate.get_template().domRoot.find('.tabMapsSearchView');
		this.set_isVisible(false);
		this.$compositeSearchWidget = tab.ObjectRegistry.newWidget(spiff.CompositeSearchWidget).call(null);
		this.mapsSearchViewTemplate.get_mapsSearchViewRootElement().append(this.$compositeSearchWidget.get_domRoot());
		this.$compositeSearchWidget.addClass('tabMapsSearchView-searchControlsContainer');
		this.get_compositeSearchWidget().setPlaceholderText(tab.Strings.MapsSearchViewInitialText);
		this.mapsSearchView.addClass($tab_MapsSearchView.widgetClassNameTranslucent);
		this.get_compositeSearchWidget().get_textInputView().add_enterKeyPressed(ss.mkdel(this, this.handleEnterKeyPress));
		this.get_compositeSearchWidget().get_searchButton().add_click(ss.mkdel(this, this.handleSearchButtonClick));
		this.get_compositeSearchWidget().add_listItemClicked(ss.mkdel(this, this.handleListItemClick));
		this.get_compositeSearchWidget().add_inputTextChanged(ss.mkdel(this, this.$handleInputTextChange));
		this.mapsSearchViewModel.add_receivedNewSuggestions(ss.mkdel(this, this.showNewSuggestions));
		this.mapsSearchViewModel.add_updateTextInputValue(ss.mkdel(this, this.updateSearchTextValue));
		this.mapsSearchViewModel.add_searchWidgetCollapsed(ss.mkdel(this, this.handleCollapseSearchWidget));
		this.mapsSearchViewModel.add_visibilityChanged(ss.mkdel(this, this.$handleSetVisible));
		this.mapsSearchViewModel.add_userInteractionEnabled(ss.mkdel(this, this.handleEnableUserInteraction));
		this.mapsSearchViewModel.add_initialTextInputValueRestored(ss.mkdel(this, this.$handleRestoreInitialTextInputValue));
		this.mapsSearchViewModel.add_suggestionListRemoved(ss.mkdel(this, this.handleRemoveSuggestionList));
		this.mapsSearchViewModel.add_blurInputElementCalled(ss.mkdel(this, this.$handleBlurInputElement));
		this.$setInputElementHandlers();
		this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
			this.get_compositeSearchWidget().get_textInputView().remove_enterKeyPressed(ss.mkdel(this, this.handleEnterKeyPress));
			this.get_compositeSearchWidget().get_searchButton().remove_click(ss.mkdel(this, this.handleSearchButtonClick));
			this.get_compositeSearchWidget().remove_listItemClicked(ss.mkdel(this, this.handleListItemClick));
			this.get_compositeSearchWidget().remove_inputTextChanged(ss.mkdel(this, this.$handleInputTextChange));
			this.mapsSearchViewModel.remove_receivedNewSuggestions(ss.mkdel(this, this.showNewSuggestions));
			this.mapsSearchViewModel.remove_updateTextInputValue(ss.mkdel(this, this.updateSearchTextValue));
			this.mapsSearchViewModel.remove_searchWidgetCollapsed(ss.mkdel(this, this.handleCollapseSearchWidget));
			this.mapsSearchViewModel.remove_visibilityChanged(ss.mkdel(this, this.$handleSetVisible));
			this.mapsSearchViewModel.remove_userInteractionEnabled(ss.mkdel(this, this.handleEnableUserInteraction));
			this.mapsSearchViewModel.remove_initialTextInputValueRestored(ss.mkdel(this, this.$handleRestoreInitialTextInputValue));
			this.mapsSearchViewModel.remove_suggestionListRemoved(ss.mkdel(this, this.handleRemoveSuggestionList));
			this.mapsSearchViewModel.remove_blurInputElementCalled(ss.mkdel(this, this.$handleBlurInputElement));
			this.$removeQueryDelayTimer();
		})));
		this.disposables.add$1(spiff.EventUtil.bindWithDispose(this.get_compositeSearchWidget().get_textInputView().get_inputElement(), 'focus', ss.mkdel(this, this.$onInputElementFocusIn)));
		this.disposables.add$1(spiff.EventUtil.bindWithDispose(this.get_compositeSearchWidget().get_textInputView().get_inputElement(), 'focusout', ss.mkdel(this, this.$onInputElementFocusOut)));
		if (this.mapsSearchViewModel.get_gotoMyLocationButtonEnabled()) {
			this.gotoMyLocationButton = new $tab_GotoMyLocationButton(this.get_viewModel().get_visualID());
			this.gotoMyLocationButton.addClass($tab_MapsSearchView.suppressVizTooltipsAndOverlays);
			this.gotoMyLocationButton.addToDom(this.element);
		}
	};
	$tab_MapsSearchView.__typeName = 'tab.MapsSearchView';
	$tab_MapsSearchView.newMapsSearchViewTemplate = function MapsSearchView$NewMapsSearchViewTemplate() {
		return new $tab_$MapsSearchViewTemplate();
	};
	global.tab.MapsSearchView = $tab_MapsSearchView;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.MapsSearchViewModel
	var $tab_MapsSearchViewModel = function(visualIdPresModel) {
		this.$visualIdPresModel = null;
		this.$2$ReceivedNewSuggestionsField = null;
		this.$2$UpdateTextInputValueField = null;
		this.$2$OnMoveMapToBoundsField = null;
		this.$2$SearchWidgetCollapsedField = null;
		this.$2$VisibilityChangedField = null;
		this.$2$UserInteractionEnabledField = null;
		this.$2$InitialTextInputValueRestoredField = null;
		this.$2$SuggestionListRemovedField = null;
		this.$2$BlurInputElementCalledField = null;
		this.$2$FocusInHandlerField = null;
		this.$2$FocusOutHandlerField = null;
		this.$2$KeypressHandlerField = null;
		spiff.BaseViewModel.call(this);
		this.$visualIdPresModel = visualIdPresModel;
	};
	$tab_MapsSearchViewModel.__typeName = 'tab.MapsSearchViewModel';
	global.tab.MapsSearchViewModel = $tab_MapsSearchViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.MarkRange
	var $tab_MarkRange = function() {
	};
	$tab_MarkRange.__typeName = 'tab.MarkRange';
	$tab_MarkRange.isInstanceOfType = function() {
		return true;
	};
	global.tab.MarkRange = $tab_MarkRange;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.MarksHitTestLink
	var $tab_MarksHitTestLink = function(ptvm, sceneInfo) {
		this.$hitTester = null;
		this.$sceneInfo = null;
		$tab_HitTestLink.call(this, ptvm);
		this.$sceneInfo = sceneInfo;
	};
	$tab_MarksHitTestLink.__typeName = 'tab.MarksHitTestLink';
	$tab_MarksHitTestLink.hitTestMarks = function MarksHitTestLink$HitTestMarks(selRect, isSingleSelect, hitTester, sceneInfo, shapeSelector) {
		if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
			return [];
		}
		var selected;
		{
			var mc = tabBootstrap.MetricsController.createContext('HitTestMarks', 256, null);
			try {
				var ht = (ss.isValue(hitTester) ? hitTester : $tab_MarksHitTestLink.buildHitTester(sceneInfo));
				selected = (ss.isValue(shapeSelector) ? shapeSelector.hitTest(ht, isSingleSelect, sceneInfo) : ht.hitTest(selRect, isSingleSelect, sceneInfo));
			}
			finally {
				if (ss.isValue(mc)) {
					mc.dispose();
				}
			}
		}
		if (selected.length > 0) {
			tab.Logger.getLogger($tab_TiledViewerRegion, null).debug('Marks: %o)', [selected.join(' ')]);
			return selected;
		}
		else {
			return [];
		}
	};
	$tab_MarksHitTestLink.buildHitTester = function MarksHitTestLink$BuildHitTester(sceneInfo) {
		var rootHitTargetNode = $tab_HitTestStructureBuilder.buildLinearHitTestStructure(sceneInfo);
		return new $tab_HitTester(rootHitTargetNode);
	};
	$tab_MarksHitTestLink.getPaneKeysByHitTesting = function MarksHitTestLink$GetPaneKeysByHitTesting(selectionAnchor, sceneInfo) {
		var ht = $tab_MarksHitTestLink.buildHitTester(sceneInfo);
		var selectionAnchorRect = { x: selectionAnchor.x, y: selectionAnchor.y, w: 1, h: 1 };
		var paneKeys = ht.hitTestPanes(selectionAnchorRect);
		return paneKeys;
	};
	global.tab.MarksHitTestLink = $tab_MarksHitTestLink;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.MarksRenderer
	var $tab_MarksRenderer = function(canvas, context) {
		tab.CanvasRenderer.call(this, canvas, context);
	};
	$tab_MarksRenderer.__typeName = 'tab.MarksRenderer';
	$tab_MarksRenderer.multipolygonMarkBuildMarkBound = function MarksRenderer$MultipolygonMarkBuildMarkBound(paneDrawInfo, markIndex) {
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				var bbox = { x: 0, y: 0, w: 0, h: 0 };
				{
					var transform = (paneDrawInfo.hasPixelGeometry ? tab.Transform.none() : tab.Transform.domainToPixel(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex)));
					$tab_MarksRenderer.bBoxGeometry(bbox, transform, 0, paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex)));
				}
				return bbox;
				break;
			}
			case 'multiLineString': {
				var bbox1 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var transform1 = (paneDrawInfo.hasPixelGeometry ? tab.Transform.none() : tab.Transform.domainToPixel(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex)));
					$tab_MarksRenderer.bBoxGeometry(bbox1, transform1, paneDrawInfo.c.get('size').gv(markIndex) / 2, paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex)));
				}
				return bbox1;
				break;
			}
			case 'multiPoint': {
				var bbox2 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var transform2 = (paneDrawInfo.hasPixelGeometry ? tab.Transform.none() : tab.Transform.domainToPixel(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex)));
					$tab_MarksRenderer.bBoxGeometry(bbox2, transform2, 3.5, paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex)));
				}
				return bbox2;
				break;
			}
			case 'empty': {
				var bbox3 = { x: 0, y: 0, w: 0, h: 0 };
				{
					tab.RectXYUtil.encompassCircleInPlace(bbox3, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), 3.5);
				}
				return bbox3;
				break;
			}
			default: {
				break;
			}
		}
		return { x: 0, y: 0, w: 0, h: 0 };
	};
	$tab_MarksRenderer.multipolygonMarkExactHitTest = function MarksRenderer$MultipolygonMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		var transform = $tab_GeometryUtil.getGeometrySelectionTransform(paneDrawInfo.hasPixelGeometry, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				{
					if ($tab_GeometryUtil.isPointInMultipolygon(geometryPM.multiPolygon, transform.transformPoint({ x: x, y: y }))) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiLineString': {
				{
					if ($tab_GeometryUtil.isPointInMultiLineString(geometryPM.multiLine, transform.transformPoint({ x: x, y: y }), paneDrawInfo.c.get('size').gv(markIndex))) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiPoint': {
				{
					if ($tab_GeometryUtil.isPointInMultipoint(geometryPM.multiPoint, transform.transformPoint({ x: x, y: y }), 3.5)) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'empty': {
				{
					if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 3 })) {
						return true;
					}
				}
				return false;
				break;
			}
			default: {
				break;
			}
		}
		return true;
	};
	$tab_MarksRenderer.multipolygonMarkNearHitTest = function MarksRenderer$MultipolygonMarkNearHitTest(paneDrawInfo, x, y, markIndex) {
		var transform = $tab_GeometryUtil.getGeometrySelectionTransform(paneDrawInfo.hasPixelGeometry, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				return false;
				break;
			}
			case 'multiLineString': {
				{
					if ($tab_GeometryUtil.isPointInMultiLineString(geometryPM.multiLine, transform.transformPoint({ x: x, y: y }), paneDrawInfo.c.get('size').gv(markIndex) + 20)) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiPoint': {
				return false;
				break;
			}
			case 'empty': {
				return false;
				break;
			}
			default: {
				break;
			}
		}
		return false;
	};
	$tab_MarksRenderer.multipolygonMarkGetHitTestExpansion = function MarksRenderer$MultipolygonMarkGetHitTestExpansion(paneDrawInfo, markIndex) {
		var expansion = null;
		{
			expansion = { w: 10, h: 10 };
		}
		return expansion;
		return { w: 0, h: 0 };
	};
	$tab_MarksRenderer.multipolygonMarkGetDistanceToMark = function MarksRenderer$MultipolygonMarkGetDistanceToMark(paneDrawInfo, x, y, markIndex) {
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				return $tab_GeometryUtil.getSquaredDistanceToCenter(paneDrawInfo.getMarkBounds(markIndex), { x: x, y: y });
				break;
			}
			case 'multiLineString': {
				return $tab_GeometryUtil.getSquaredDistanceToCenter(paneDrawInfo.getMarkBounds(markIndex), { x: x, y: y });
				break;
			}
			case 'multiPoint': {
				return $tab_GeometryUtil.getSquaredDistanceToCenter(paneDrawInfo.getMarkBounds(markIndex), { x: x, y: y });
				break;
			}
			case 'empty': {
				return $tab_GeometryUtil.getSquaredDistanceToCenter(paneDrawInfo.getMarkBounds(markIndex), { x: x, y: y });
				break;
			}
			default: {
				break;
			}
		}
		return $tab_GeometryUtil.getSquaredDistanceToCenter(paneDrawInfo.getMarkBounds(markIndex), { x: x, y: y });
	};
	$tab_MarksRenderer.multipolygonMarkRectangleAreaHitTest = function MarksRenderer$MultipolygonMarkRectangleAreaHitTest(paneDrawInfo, selection, markIndex) {
		var transform = $tab_GeometryUtil.getGeometrySelectionTransform(paneDrawInfo.hasPixelGeometry, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				{
					if ($tab_GeometryUtil.multipolygonIntersectsDoubleRect(geometryPM.multiPolygon, transform.transformRect(selection))) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiLineString': {
				{
					if ($tab_GeometryUtil.multiLineStringIntersectsDoubleRect(geometryPM.multiLine, transform.transformRect(selection), paneDrawInfo.c.get('size').gv(markIndex))) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiPoint': {
				{
					if ($tab_GeometryUtil.multipointIntersectsDoubleRect(geometryPM.multiPoint, transform.transformRect(selection), 3.5)) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'empty': {
				{
					if ($tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 3 }, selection)) {
						return true;
					}
				}
				return false;
				break;
			}
			default: {
				break;
			}
		}
		return true;
	};
	$tab_MarksRenderer.multipolygonMarkCircleAreaHitTest = function MarksRenderer$MultipolygonMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, markOffsetBBox, radialDistanceHitTest) {
		var transform = $tab_GeometryUtil.getGeometrySelectionTransform(paneDrawInfo.hasPixelGeometry, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
		if (radialDistanceHitTest) {
			var geometryType = 'empty';
			var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
			if (ss.isValue(geometryPM)) {
				geometryType = geometryPM.geometryType;
			}
			switch (geometryType) {
				case 'multiPolygon': {
					break;
				}
				case 'multiLineString': {
					{
						{
							if ($tab_GeometryUtil.multiLineStringIntersectsCircle(geometryPM.multiLine, transform.transformCircle(circle), 0)) {
								return true;
							}
						}
						return false;
					}
					break;
				}
				case 'multiPoint': {
					{
						{
							if ($tab_GeometryUtil.multipointIntersectsCircle(geometryPM.multiPoint, transform.transformCircle(circle), 0)) {
								return true;
							}
						}
						return false;
					}
					break;
				}
				case 'empty': {
					{
						{
							return $tab_GeometryUtil.isPointInCircle({ x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, circle);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		}
		{
			var geometryType1 = 'empty';
			var geometryPM1 = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
			if (ss.isValue(geometryPM1)) {
				geometryType1 = geometryPM1.geometryType;
			}
			switch (geometryType1) {
				case 'multiPolygon': {
					{
						if ($tab_GeometryUtil.multipolygonIntersectsCircle(geometryPM1.multiPolygon, transform.transformCircle(circle))) {
							return true;
						}
					}
					return false;
					break;
				}
				case 'multiLineString': {
					{
						if ($tab_GeometryUtil.multiLineStringIntersectsCircle(geometryPM1.multiLine, transform.transformCircle(circle), paneDrawInfo.c.get('size').gv(markIndex))) {
							return true;
						}
					}
					return false;
					break;
				}
				case 'multiPoint': {
					{
						if ($tab_GeometryUtil.multipointIntersectsCircle(geometryPM1.multiPoint, transform.transformCircle(circle), 3.5)) {
							return true;
						}
					}
					return false;
					break;
				}
				case 'empty': {
					{
						if ($tab_GeometryUtil.circleIntersectsCircle(circle, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 3 })) {
							return true;
						}
					}
					return false;
					break;
				}
				default: {
					break;
				}
			}
		}
		return $tab_GeometryUtil.circleIntersectsRect(circle, markOffsetBBox);
	};
	$tab_MarksRenderer.multipolygonMarkPolygonAreaHitTest = function MarksRenderer$MultipolygonMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex, markOffsetBBox) {
		var transform = $tab_GeometryUtil.getGeometrySelectionTransform(paneDrawInfo.hasPixelGeometry, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				{
					if ($tab_GeometryUtil.multipolygonIntersectsPolygon(geometryPM.multiPolygon, transform.transformPolygon(selectionPointsInclWorldOffset))) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiLineString': {
				{
					if ($tab_GeometryUtil.multiLineStringIntersectsPolygon(geometryPM.multiLine, transform.transformPolygon(selectionPointsInclWorldOffset), paneDrawInfo.c.get('size').gv(markIndex))) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'multiPoint': {
				{
					if ($tab_GeometryUtil.multipointIntersectsPolygon(geometryPM.multiPoint, transform.transformPolygon(selectionPointsInclWorldOffset), 3.5)) {
						return true;
					}
				}
				return false;
				break;
			}
			case 'empty': {
				{
					if ($tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 3 })) {
						return true;
					}
				}
				return false;
				break;
			}
			default: {
				break;
			}
		}
		return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, markOffsetBBox);
	};
	$tab_MarksRenderer.areaMarkBuildMarkBound = function MarksRenderer$AreaMarkBuildMarkBound(paneDrawInfo, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var mode = paneDrawInfo.lineInterpolation;
		var bbox = { x: 0, y: 0, w: 0, h: 0 };
		if (left !== -1) {
			var rect1 = tab.RectXYUtil.rectXYFromCorners$2(paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), (paneDrawInfo.c.get('x_next').gv(left) + paneDrawInfo.c.get('x_prev').gv(markIndex)) / 2, (paneDrawInfo.c.get('y_next').gv(left) + paneDrawInfo.c.get('y_prev').gv(markIndex)) / 2);
			tab.RectXYUtil.unionInPlace(bbox, rect1);
			var rect2 = tab.RectXYUtil.rectXYFromCorners$2((paneDrawInfo.c.get('x1').gv(left) + paneDrawInfo.c.get('x1').gv(markIndex)) / 2, (paneDrawInfo.c.get('y1').gv(left) + paneDrawInfo.c.get('y1').gv(markIndex)) / 2, paneDrawInfo.c.get('x_prev').gv(markIndex), paneDrawInfo.c.get('y_prev').gv(markIndex));
			tab.RectXYUtil.unionInPlace(bbox, rect2);
			tab.RectXYUtil.outsetRectInPlace(bbox, 10, 10);
		}
		if (right !== -1) {
			var rect11 = tab.RectXYUtil.rectXYFromCorners$2(paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), (paneDrawInfo.c.get('x_prev').gv(right) + paneDrawInfo.c.get('x_next').gv(markIndex)) / 2, (paneDrawInfo.c.get('y_prev').gv(right) + paneDrawInfo.c.get('y_next').gv(markIndex)) / 2);
			tab.RectXYUtil.unionInPlace(bbox, rect11);
			var rect21 = tab.RectXYUtil.rectXYFromCorners$2((paneDrawInfo.c.get('x1').gv(right) + paneDrawInfo.c.get('x1').gv(markIndex)) / 2, (paneDrawInfo.c.get('y1').gv(right) + paneDrawInfo.c.get('y1').gv(markIndex)) / 2, paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex));
			tab.RectXYUtil.unionInPlace(bbox, rect21);
			tab.RectXYUtil.outsetRectInPlace(bbox, 10, 10);
		}
		if (left === -1 && right === -1) {
			var rect12 = tab.RectXYUtil.rectXYFromCorners$2(paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
			{
				var outsetX = 20 - rect12.w;
				var outsetY = 20 - rect12.h;
				if (outsetX > 0 || outsetY > 0) {
					rect12 = tab.RectXYUtil.outsetRect(rect12, Math.max(0, Math.ceil(outsetX / 2)), Math.max(0, Math.ceil(outsetY / 2)));
				}
			}
			tab.RectXYUtil.unionInPlace(bbox, rect12);
		}
		return bbox;
	};
	$tab_MarksRenderer.areaMarkExactHitTest = function MarksRenderer$AreaMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var mode = paneDrawInfo.lineInterpolation;
		if (left !== -1) {
			var points = new Array(8);
			points[0] = paneDrawInfo.c.get('x1').gv(markIndex);
			points[1] = paneDrawInfo.c.get('y1').gv(markIndex);
			points[2] = (paneDrawInfo.c.get('x1').gv(left) + paneDrawInfo.c.get('x1').gv(markIndex)) / 2;
			points[3] = (paneDrawInfo.c.get('y1').gv(left) + paneDrawInfo.c.get('y1').gv(markIndex)) / 2;
			points[4] = (paneDrawInfo.c.get('x_next').gv(left) + paneDrawInfo.c.get('x_prev').gv(markIndex)) / 2;
			points[5] = (paneDrawInfo.c.get('y_next').gv(left) + paneDrawInfo.c.get('y_prev').gv(markIndex)) / 2;
			points[6] = paneDrawInfo.c.get('x_prev').gv(markIndex);
			points[7] = paneDrawInfo.c.get('y_prev').gv(markIndex);
			if ($tab_GeometryUtil.isPointInPoly(points, { x: x, y: y }, 0)) {
				return true;
			}
		}
		if (right !== -1) {
			var points1 = new Array(8);
			points1[0] = paneDrawInfo.c.get('x1').gv(markIndex);
			points1[1] = paneDrawInfo.c.get('y1').gv(markIndex);
			points1[2] = (paneDrawInfo.c.get('x1').gv(right) + paneDrawInfo.c.get('x1').gv(markIndex)) / 2;
			points1[3] = (paneDrawInfo.c.get('y1').gv(right) + paneDrawInfo.c.get('y1').gv(markIndex)) / 2;
			points1[4] = (paneDrawInfo.c.get('x_prev').gv(right) + paneDrawInfo.c.get('x_next').gv(markIndex)) / 2;
			points1[5] = (paneDrawInfo.c.get('y_prev').gv(right) + paneDrawInfo.c.get('y_next').gv(markIndex)) / 2;
			points1[6] = paneDrawInfo.c.get('x_next').gv(markIndex);
			points1[7] = paneDrawInfo.c.get('y_next').gv(markIndex);
			if ($tab_GeometryUtil.isPointInPoly(points1, { x: x, y: y }, 0)) {
				return true;
			}
		}
		if (left === -1 && right === -1) {
			return true;
		}
		return false;
	};
	$tab_MarksRenderer.areaMarkNearHitTest = function MarksRenderer$AreaMarkNearHitTest(paneDrawInfo, x, y, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var mode = paneDrawInfo.lineInterpolation;
		if (left !== -1) {
			var points = new Array(8);
			points[0] = paneDrawInfo.c.get('x1').gv(markIndex);
			points[1] = paneDrawInfo.c.get('y1').gv(markIndex);
			points[2] = (paneDrawInfo.c.get('x1').gv(left) + paneDrawInfo.c.get('x1').gv(markIndex)) / 2;
			points[3] = (paneDrawInfo.c.get('y1').gv(left) + paneDrawInfo.c.get('y1').gv(markIndex)) / 2;
			points[4] = (paneDrawInfo.c.get('x_next').gv(left) + paneDrawInfo.c.get('x_prev').gv(markIndex)) / 2;
			points[5] = (paneDrawInfo.c.get('y_next').gv(left) + paneDrawInfo.c.get('y_prev').gv(markIndex)) / 2;
			points[6] = paneDrawInfo.c.get('x_prev').gv(markIndex);
			points[7] = paneDrawInfo.c.get('y_prev').gv(markIndex);
			if ($tab_GeometryUtil.isPointInPoly(points, { x: x, y: y }, 10)) {
				return true;
			}
		}
		if (right !== -1) {
			var points1 = new Array(8);
			points1[0] = paneDrawInfo.c.get('x1').gv(markIndex);
			points1[1] = paneDrawInfo.c.get('y1').gv(markIndex);
			points1[2] = (paneDrawInfo.c.get('x1').gv(right) + paneDrawInfo.c.get('x1').gv(markIndex)) / 2;
			points1[3] = (paneDrawInfo.c.get('y1').gv(right) + paneDrawInfo.c.get('y1').gv(markIndex)) / 2;
			points1[4] = (paneDrawInfo.c.get('x_prev').gv(right) + paneDrawInfo.c.get('x_next').gv(markIndex)) / 2;
			points1[5] = (paneDrawInfo.c.get('y_prev').gv(right) + paneDrawInfo.c.get('y_next').gv(markIndex)) / 2;
			points1[6] = paneDrawInfo.c.get('x_next').gv(markIndex);
			points1[7] = paneDrawInfo.c.get('y_next').gv(markIndex);
			if ($tab_GeometryUtil.isPointInPoly(points1, { x: x, y: y }, 10)) {
				return true;
			}
		}
		if (left === -1 && right === -1) {
			return true;
		}
		return false;
	};
	$tab_MarksRenderer.areaMarkGetHitTestExpansion = function MarksRenderer$AreaMarkGetHitTestExpansion(paneDrawInfo, markIndex) {
		return { w: 0, h: 0 };
	};
	$tab_MarksRenderer.areaMarkGetDistanceToMark = function MarksRenderer$AreaMarkGetDistanceToMark(paneDrawInfo, x, y, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var x0 = paneDrawInfo.c.get('x1').gv(markIndex);
		var y0 = paneDrawInfo.c.get('y1').gv(markIndex);
		var xp = paneDrawInfo.c.get('x_prev').gv(markIndex);
		var yp = paneDrawInfo.c.get('y_prev').gv(markIndex);
		var xn = paneDrawInfo.c.get('x_next').gv(markIndex);
		var yn = paneDrawInfo.c.get('y_next').gv(markIndex);
		var distance;
		{
			var dx = x - x0;
			var dy = y - y0;
			var singlePointDistance = dx * dx + dy * dy;
			distance = singlePointDistance;
		}
		if (left !== -1) {
			var x1 = (paneDrawInfo.c.get('x1').gv(left) + x0) / 2;
			var y1 = (paneDrawInfo.c.get('y1').gv(left) + y0) / 2;
			var x2 = (paneDrawInfo.c.get('x_next').gv(left) + x0) / 2;
			var y2 = (paneDrawInfo.c.get('y_next').gv(left) + y0) / 2;
			var a = { x: (x0 + xp) / 2, y: (y0 + yp) / 2 };
			var b = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
			var leftSegmentDistance = $tab_GeometryUtil.getSquaredDistanceToLineSegment({ x: x, y: y }, a, b);
			distance = Math.min(distance, leftSegmentDistance);
		}
		else {
			var a1 = { x: x0, y: y0 };
			var b1 = { x: xn, y: yn };
			var leftSegmentDistance1 = $tab_GeometryUtil.getSquaredDistanceToLineSegment({ x: x, y: y }, a1, b1);
			distance = Math.min(distance, leftSegmentDistance1);
		}
		if (right !== -1) {
			var x11 = (paneDrawInfo.c.get('x1').gv(right) + x0) / 2;
			var y11 = (paneDrawInfo.c.get('y1').gv(right) + y0) / 2;
			var x21 = (paneDrawInfo.c.get('x_prev').gv(right) + x0) / 2;
			var y21 = (paneDrawInfo.c.get('y_prev').gv(right) + y0) / 2;
			var a2 = { x: (x0 + xn) / 2, y: (y0 + yn) / 2 };
			var b2 = { x: (x11 + x21) / 2, y: (y11 + y21) / 2 };
			var rightSegmentDistance = $tab_GeometryUtil.getSquaredDistanceToLineSegment({ x: x, y: y }, a2, b2);
			distance = Math.min(distance, rightSegmentDistance);
		}
		else if (left !== -1) {
			var a3 = { x: x0, y: y0 };
			var b3 = { x: xp, y: yp };
			var rightSegmentDistance1 = $tab_GeometryUtil.getSquaredDistanceToLineSegment({ x: x, y: y }, a3, b3);
			distance = Math.min(distance, rightSegmentDistance1);
		}
		return distance;
	};
	$tab_MarksRenderer.areaMarkRectangleAreaHitTest = function MarksRenderer$AreaMarkRectangleAreaHitTest(paneDrawInfo, selection, markIndex) {
		{
			if ($tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 2.5 }, selection)) {
				return true;
			}
		}
		{
			if ($tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x1').gv(markIndex), y: paneDrawInfo.c.get('y1').gv(markIndex) }, radius: 2.5 }, selection)) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.areaMarkCircleAreaHitTest = function MarksRenderer$AreaMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, markOffsetBBox, radialDistanceHitTest) {
		if (radialDistanceHitTest) {
		}
		{
			if ($tab_GeometryUtil.circleIntersectsCircle(circle, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 2.5 })) {
				return true;
			}
		}
		{
			if ($tab_GeometryUtil.circleIntersectsCircle(circle, { center: { x: paneDrawInfo.c.get('x1').gv(markIndex), y: paneDrawInfo.c.get('y1').gv(markIndex) }, radius: 2.5 })) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.areaMarkPolygonAreaHitTest = function MarksRenderer$AreaMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex, markOffsetBBox) {
		{
			if ($tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: 2.5 })) {
				return true;
			}
		}
		{
			if ($tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x1').gv(markIndex), y: paneDrawInfo.c.get('y1').gv(markIndex) }, radius: 2.5 })) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.getMarkLabelBoundingBox = function MarksRenderer$GetMarkLabelBoundingBox(paneDrawInfo, markIndex) {
		var bbox = { x: 0, y: 0, w: 0, h: 0 };
		{
			var x = paneDrawInfo.getMarkLabelProperty('x', markIndex);
			var y = paneDrawInfo.getMarkLabelProperty('y', markIndex);
			var width = paneDrawInfo.getMarkLabelProperty('width', markIndex);
			var height = -paneDrawInfo.getMarkLabelProperty('height', markIndex);
			x += 0;
			y += 0;
			if (height < 0) {
				y += height;
				height = Math.abs(height);
			}
			tab.RectXYUtil.set$1(bbox, Math.floor(x), Math.floor(y), Math.floor(width), Math.floor(height));
		}
		return bbox;
	};
	$tab_MarksRenderer.pieMarkExactHitTest = function MarksRenderer$PieMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		var startangle = paneDrawInfo.c.get('theta').gv(markIndex);
		var endangle = paneDrawInfo.c.get('theta1').gv(markIndex);
		if (startangle > endangle) {
			var temp = startangle;
			startangle = endangle;
			endangle = temp;
		}
		var center = { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) };
		var wedgeCircle = { center: center, radius: radius };
		if (endangle - startangle >= 1) {
			return $tab_GeometryUtil.isPointInCircle({ x: x, y: y }, wedgeCircle);
		}
		startangle = tab.CanvasRenderer.toCanvasAngle(startangle);
		endangle = tab.CanvasRenderer.toCanvasAngle(endangle);
		startangle = $tab_GeometryUtil.normalizeAngle(startangle);
		endangle = $tab_GeometryUtil.normalizeAngle(endangle);
		return $tab_GeometryUtil.isPointInWedge({ x: x, y: y }, wedgeCircle, startangle, endangle);
	};
	$tab_MarksRenderer.pieMarkRectangleAreaHitTest = function MarksRenderer$PieMarkRectangleAreaHitTest(paneDrawInfo, rect, markIndex) {
		var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		var startangle = paneDrawInfo.c.get('theta').gv(markIndex);
		var endangle = paneDrawInfo.c.get('theta1').gv(markIndex);
		if (startangle > endangle) {
			var temp = startangle;
			startangle = endangle;
			endangle = temp;
		}
		var center = { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) };
		var wedgeCircle = { center: center, radius: radius };
		if (endangle - startangle >= 1) {
			return $tab_GeometryUtil.circleIntersectsRect(wedgeCircle, rect);
		}
		startangle = tab.CanvasRenderer.toCanvasAngle(startangle);
		endangle = tab.CanvasRenderer.toCanvasAngle(endangle);
		startangle = $tab_GeometryUtil.normalizeAngle(startangle);
		endangle = $tab_GeometryUtil.normalizeAngle(endangle);
		return $tab_GeometryUtil.rectIntersectsWedge(rect, { center: center, radius: radius }, startangle, endangle);
	};
	$tab_MarksRenderer.pieMarkPolygonAreaHitTest = function MarksRenderer$PieMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex) {
		var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		var startangle = paneDrawInfo.c.get('theta').gv(markIndex);
		var endangle = paneDrawInfo.c.get('theta1').gv(markIndex);
		if (startangle > endangle) {
			var temp = startangle;
			startangle = endangle;
			endangle = temp;
		}
		var center = { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) };
		var wedgeCircle = { center: center, radius: radius };
		if (endangle - startangle >= 1) {
			return $tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, wedgeCircle);
		}
		startangle = tab.CanvasRenderer.toCanvasAngle(startangle);
		endangle = tab.CanvasRenderer.toCanvasAngle(endangle);
		startangle = $tab_GeometryUtil.normalizeAngle(startangle);
		endangle = $tab_GeometryUtil.normalizeAngle(endangle);
		return $tab_GeometryUtil.polygonIntersectsWedge(selectionPointsInclWorldOffset, { center: center, radius: radius }, startangle, endangle);
	};
	$tab_MarksRenderer.pieMarkCircleAreaHitTest = function MarksRenderer$PieMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, radialDistanceHitTest) {
		if (radialDistanceHitTest) {
			{
				{
					return $tab_GeometryUtil.isPointInCircle({ x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, circle);
				}
			}
		}
		var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		var startangle = paneDrawInfo.c.get('theta').gv(markIndex);
		var endangle = paneDrawInfo.c.get('theta1').gv(markIndex);
		if (startangle > endangle) {
			var temp = startangle;
			startangle = endangle;
			endangle = temp;
		}
		var center = { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) };
		var wedgeCircle = { center: center, radius: radius };
		if (endangle - startangle >= 1) {
			return $tab_GeometryUtil.circleIntersectsCircle(wedgeCircle, circle);
		}
		startangle = tab.CanvasRenderer.toCanvasAngle(startangle);
		endangle = tab.CanvasRenderer.toCanvasAngle(endangle);
		startangle = $tab_GeometryUtil.normalizeAngle(startangle);
		endangle = $tab_GeometryUtil.normalizeAngle(endangle);
		return $tab_GeometryUtil.circleIntersectsWedge(circle, { center: center, radius: radius }, startangle, endangle);
	};
	$tab_MarksRenderer.getPieBoundingBox = function MarksRenderer$GetPieBoundingBox(paneDrawInfo, markIndex) {
		var bbox = { x: 0, y: 0, w: 0, h: 0 };
		var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		{
			tab.RectXYUtil.unionInPlace(bbox, $tab_MarksRenderer.$boundWedge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius, paneDrawInfo.c.get('theta').gv(markIndex), paneDrawInfo.c.get('theta1').gv(markIndex)));
		}
		if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
			tab.RectXYUtil.unionInPlace(bbox, $tab_MarksRenderer.$boundWedge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius, paneDrawInfo.c.get('theta').gv(markIndex), paneDrawInfo.c.get('theta1').gv(markIndex)));
		}
		return bbox;
	};
	$tab_MarksRenderer.textMarkBuildMarkBound = function MarksRenderer$TextMarkBuildMarkBound(paneDrawInfo, markIndex) {
		var bbox = { x: 0, y: 0, w: 0, h: 0 };
		if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
			var x = paneDrawInfo.c.get('x').gv(markIndex);
			var y = paneDrawInfo.c.get('y').gv(markIndex);
			var width = paneDrawInfo.c.get('width').gv(markIndex);
			var height = -paneDrawInfo.c.get('height').gv(markIndex);
			x += -paneDrawInfo.c.get('width').gv(markIndex) / 2;
			y += paneDrawInfo.c.get('height').gv(markIndex) / 2;
			if (height < 0) {
				y += height;
				height = Math.abs(height);
			}
			tab.RectXYUtil.set$1(bbox, Math.floor(x), Math.floor(y), Math.floor(width), Math.floor(height));
		}
		if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
			var x1 = paneDrawInfo.c.get('x').gv(markIndex);
			var y1 = paneDrawInfo.c.get('y').gv(markIndex);
			var width1 = paneDrawInfo.c.get('clip_width').gv(markIndex);
			var height1 = -paneDrawInfo.c.get('clip_height').gv(markIndex);
			x1 += -paneDrawInfo.c.get('clip_width').gv(markIndex) / 2;
			y1 += paneDrawInfo.c.get('clip_height').gv(markIndex) / 2;
			if (height1 < 0) {
				y1 += height1;
				height1 = Math.abs(height1);
			}
			tab.RectXYUtil.set$1(bbox, Math.floor(x1), Math.floor(y1), Math.floor(width1), Math.floor(height1));
		}
		return bbox;
	};
	$tab_MarksRenderer.textMarkExactHitTest = function MarksRenderer$TextMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
			return $tab_MarksRenderer.$isPointInExpandedRectHelperF(paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('height').gv(markIndex) / 2, paneDrawInfo.c.get('x').gv(markIndex) + -paneDrawInfo.c.get('width').gv(markIndex) / 2, -paneDrawInfo.c.get('height').gv(markIndex), paneDrawInfo.c.get('width').gv(markIndex), 0, 0, paneDrawInfo.minBarHeight, paneDrawInfo.minBarWidth, x, y);
		}
		if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
			return $tab_MarksRenderer.$isPointInExpandedRectHelperF(paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('clip_height').gv(markIndex) / 2, paneDrawInfo.c.get('x').gv(markIndex) + -paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, -paneDrawInfo.c.get('clip_height').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), 0, 0, paneDrawInfo.minBarHeight, paneDrawInfo.minBarWidth, x, y);
		}
		return false;
	};
	$tab_MarksRenderer.textMarkNearHitTest = function MarksRenderer$TextMarkNearHitTest(paneDrawInfo, x, y, markIndex) {
		if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
			return $tab_MarksRenderer.$isPointInExpandedRectHelperF(paneDrawInfo.c.get('y').gv(markIndex) + (paneDrawInfo.c.get('height').gv(markIndex) / 2 + 10), paneDrawInfo.c.get('x').gv(markIndex) + (-paneDrawInfo.c.get('width').gv(markIndex) / 2 - 10), -paneDrawInfo.c.get('height').gv(markIndex) - 20, paneDrawInfo.c.get('width').gv(markIndex) + 20, 0, 0, paneDrawInfo.minBarHeight, paneDrawInfo.minBarWidth, x, y);
		}
		if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
			return $tab_MarksRenderer.$isPointInExpandedRectHelperF(paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('clip_height').gv(markIndex) / 2, paneDrawInfo.c.get('x').gv(markIndex) + -paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, -paneDrawInfo.c.get('clip_height').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), 0, 0, paneDrawInfo.minBarHeight, paneDrawInfo.minBarWidth, x, y);
		}
		return false;
	};
	$tab_MarksRenderer.textMarkGetHitTestExpansion = function MarksRenderer$TextMarkGetHitTestExpansion(paneDrawInfo, markIndex) {
		var expansion = null;
		if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
			expansion = { w: 10, h: 10 };
		}
		if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 };
		}
		return expansion;
	};
	$tab_MarksRenderer.textMarkGetDistanceToMark = function MarksRenderer$TextMarkGetDistanceToMark(paneDrawInfo, x, y, markIndex) {
		var markBound = paneDrawInfo.getMarkBounds(markIndex);
		return $tab_GeometryUtil.getSquaredDistanceToNearestSide(markBound, { x: x, y: y });
	};
	$tab_MarksRenderer.textMarkRectangleAreaHitTest = function MarksRenderer$TextMarkRectangleAreaHitTest(paneDrawInfo, selection, markIndex) {
		return true;
	};
	$tab_MarksRenderer.textMarkCircleAreaHitTest = function MarksRenderer$TextMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, markOffsetBBox, radialDistanceHitTest) {
		if (radialDistanceHitTest) {
			{
				{
					return $tab_GeometryUtil.isPointInCircle({ x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, circle);
				}
			}
		}
		return $tab_GeometryUtil.circleIntersectsRect(circle, markOffsetBBox);
	};
	$tab_MarksRenderer.textMarkPolygonAreaHitTest = function MarksRenderer$TextMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex, markOffsetBBox) {
		return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, markOffsetBBox);
	};
	$tab_MarksRenderer.barMarkBuildMarkBound = function MarksRenderer$BarMarkBuildMarkBound(paneDrawInfo, markIndex) {
		var bbox = { x: 0, y: 0, w: 0, h: 0 };
		var halfSize = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			var topVal = paneDrawInfo.c.get('y').gv(markIndex);
			var bottomVal = paneDrawInfo.c.get('y1').gv(markIndex);
			var leftVal = paneDrawInfo.c.get('x').gv(markIndex);
			var rightVal = paneDrawInfo.c.get('x1').gv(markIndex);
			$tab_MarksRenderer.$boundingBoxOfBoundFilledBar(paneDrawInfo, bbox, topVal, leftVal, bottomVal, rightVal);
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			var topVal1 = paneDrawInfo.c.get('y').gv(markIndex);
			var bottomVal1 = paneDrawInfo.c.get('y1').gv(markIndex);
			var leftVal1 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize;
			var rightVal1 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize;
			$tab_MarksRenderer.$boundingBoxOfBoundFilledBar(paneDrawInfo, bbox, topVal1, leftVal1, bottomVal1, rightVal1);
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			var topVal2 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize;
			var bottomVal2 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize;
			var leftVal2 = paneDrawInfo.c.get('x').gv(markIndex);
			var rightVal2 = paneDrawInfo.c.get('x1').gv(markIndex);
			$tab_MarksRenderer.$boundingBoxOfBoundFilledBar(paneDrawInfo, bbox, topVal2, leftVal2, bottomVal2, rightVal2);
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			var topVal3 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize;
			var bottomVal3 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize;
			var leftVal3 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize;
			var rightVal3 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize;
			$tab_MarksRenderer.$boundingBoxOfBoundFilledBar(paneDrawInfo, bbox, topVal3, leftVal3, bottomVal3, rightVal3);
		}
		return bbox;
	};
	$tab_MarksRenderer.barMarkExactHitTest = function MarksRenderer$BarMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		var halfWidth = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		var halfHeight = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			var top = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect = { x: left, y: top, w: right - left, h: bottom - top };
			tab.RectXYUtil.outsetRectInPlace(rect, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			var top1 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom1 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left1 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var right1 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var rect1 = { x: left1, y: top1, w: right1 - left1, h: bottom1 - top1 };
			tab.RectXYUtil.outsetRectInPlace(rect1, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect1, x, y)) {
				return true;
			}
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			var top2 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var bottom2 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var left2 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right2 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect2 = { x: left2, y: top2, w: right2 - left2, h: bottom2 - top2 };
			tab.RectXYUtil.outsetRectInPlace(rect2, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect2, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			var top3 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var bottom3 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var left3 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var right3 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var rect3 = { x: left3, y: top3, w: right3 - left3, h: bottom3 - top3 };
			tab.RectXYUtil.outsetRectInPlace(rect3, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect3, x, y)) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.barMarkNearHitTest = function MarksRenderer$BarMarkNearHitTest(paneDrawInfo, x, y, markIndex) {
		var halfCellWidth = paneDrawInfo.c.get('clip_width').gv(markIndex) / 2;
		var halfCellHeight = paneDrawInfo.c.get('clip_height').gv(markIndex) / 2;
		var halfWidth = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		var halfHeight = paneDrawInfo.c.get('size').gv(markIndex) / 2;
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			var top = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect = { x: left, y: top, w: right - left, h: bottom - top };
			tab.RectXYUtil.outsetRectInPlace(rect, Math.ceil(10), Math.ceil(10));
			if (tab.RectXYUtil.inRectPointF$1(rect, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			var top1 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom1 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left1 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var right1 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var rect1 = { x: left1, y: top1, w: right1 - left1, h: bottom1 - top1 };
			tab.RectXYUtil.outsetRectInPlace(rect1, Math.ceil(10), Math.ceil(10));
			if (tab.RectXYUtil.inRectPointF$1(rect1, x, y)) {
				return true;
			}
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			var top2 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var bottom2 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var left2 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right2 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect2 = { x: left2, y: top2, w: right2 - left2, h: bottom2 - top2 };
			tab.RectXYUtil.outsetRectInPlace(rect2, Math.ceil(10), Math.ceil(10));
			if (tab.RectXYUtil.inRectPointF$1(rect2, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			var top3 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom3 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left3 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var right3 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var rect3 = { x: left3, y: top3, w: right3 - left3, h: bottom3 - top3 };
			tab.RectXYUtil.outsetRectInPlace(rect3, Math.ceil(0), Math.ceil(10));
			if (tab.RectXYUtil.inRectPointF$1(rect3, x, y)) {
				return true;
			}
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			var top4 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var bottom4 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var left4 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right4 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect4 = { x: left4, y: top4, w: right4 - left4, h: bottom4 - top4 };
			tab.RectXYUtil.outsetRectInPlace(rect4, Math.ceil(10), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect4, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			var top5 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var bottom5 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var left5 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var right5 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var rect5 = { x: left5, y: top5, w: right5 - left5, h: bottom5 - top5 };
			tab.RectXYUtil.outsetRectInPlace(rect5, Math.ceil(10), Math.ceil(10));
			if (tab.RectXYUtil.inRectPointF$1(rect5, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			var top6 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var bottom6 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfHeight));
			var left6 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var right6 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var rect6 = { x: left6, y: top6, w: right6 - left6, h: bottom6 - top6 };
			tab.RectXYUtil.outsetRectInPlace(rect6, Math.ceil(0), Math.ceil(10));
			if (tab.RectXYUtil.inRectPointF$1(rect6, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			var top7 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var bottom7 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var left7 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var right7 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfWidth));
			var rect7 = { x: left7, y: top7, w: right7 - left7, h: bottom7 - top7 };
			tab.RectXYUtil.outsetRectInPlace(rect7, Math.ceil(10), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect7, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			var top8 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var bottom8 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var left8 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var right8 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var rect8 = { x: left8, y: top8, w: right8 - left8, h: bottom8 - top8 };
			tab.RectXYUtil.outsetRectInPlace(rect8, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect8, x, y)) {
				return true;
			}
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			var top9 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var bottom9 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex) - halfCellHeight, paneDrawInfo.c.get('y').gv(markIndex) + halfCellHeight));
			var left9 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right9 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect9 = { x: left9, y: top9, w: right9 - left9, h: bottom9 - top9 };
			tab.RectXYUtil.outsetRectInPlace(rect9, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect9, x, y)) {
				return true;
			}
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			var top10 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom10 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left10 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var right10 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex) - halfCellWidth, paneDrawInfo.c.get('x').gv(markIndex) + halfCellWidth));
			var rect10 = { x: left10, y: top10, w: right10 - left10, h: bottom10 - top10 };
			tab.RectXYUtil.outsetRectInPlace(rect10, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect10, x, y)) {
				return true;
			}
		}
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			var top11 = Math.floor(Math.min(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var bottom11 = Math.ceil(Math.max(paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex)));
			var left11 = Math.floor(Math.min(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var right11 = Math.ceil(Math.max(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x1').gv(markIndex)));
			var rect11 = { x: left11, y: top11, w: right11 - left11, h: bottom11 - top11 };
			tab.RectXYUtil.outsetRectInPlace(rect11, Math.ceil(0), Math.ceil(0));
			if (tab.RectXYUtil.inRectPointF$1(rect11, x, y)) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.barMarkGetHitTestExpansion = function MarksRenderer$BarMarkGetHitTestExpansion(paneDrawInfo, markIndex) {
		var expansion = null;
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			expansion = { w: 10, h: 10 };
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			expansion = { w: 5, h: 10 };
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			expansion = { w: 10, h: 5 };
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: 10 };
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			expansion = { w: 10, h: paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 };
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			expansion = { w: 5, h: 5 };
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			expansion = { w: 5, h: paneDrawInfo.c.get('clip_height').gv(markIndex) };
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: 10 };
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 };
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 };
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 };
		}
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.paneHasCellsX && paneDrawInfo.paneHasCellsY) {
			expansion = { w: paneDrawInfo.c.get('clip_width').gv(markIndex) / 2, h: paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 };
		}
		return expansion;
	};
	$tab_MarksRenderer.barMarkGetDistanceToMark = function MarksRenderer$BarMarkGetDistanceToMark(paneDrawInfo, x, y, markIndex) {
		var markBound = paneDrawInfo.getMarkBounds(markIndex);
		return $tab_GeometryUtil.getSquaredDistanceToNearestSide(markBound, { x: x, y: y });
	};
	$tab_MarksRenderer.barMarkRectangleAreaHitTest = function MarksRenderer$BarMarkRectangleAreaHitTest(paneDrawInfo, selection, markIndex) {
		return true;
	};
	$tab_MarksRenderer.barMarkCircleAreaHitTest = function MarksRenderer$BarMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, markOffsetBBox, radialDistanceHitTest) {
		if (radialDistanceHitTest) {
			if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !paneDrawInfo.paneHasCellsX && !paneDrawInfo.paneHasCellsY) {
				{
					return $tab_GeometryUtil.isPointInCircle({ x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, circle);
				}
			}
		}
		return $tab_GeometryUtil.circleIntersectsRect(circle, markOffsetBBox);
	};
	$tab_MarksRenderer.barMarkPolygonAreaHitTest = function MarksRenderer$BarMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex, markOffsetBBox) {
		return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, markOffsetBBox);
	};
	$tab_MarksRenderer.lineMarkBuildMarkBound = function MarksRenderer$LineMarkBuildMarkBound(paneDrawInfo, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var mode = paneDrawInfo.lineInterpolation;
		var bbox = { x: 0, y: 0, w: 0, h: 0 };
		{
			tab.RectXYUtil.encompassCircleInPlace(bbox, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), (paneDrawInfo.c.get('size').gv(markIndex) + 20) / 2);
		}
		if (left !== -1 && mode === 'lim-linear') {
			$tab_MarksRenderer.$boundLineEdgeInPlace(bbox, (paneDrawInfo.c.get('x').gv(left) + paneDrawInfo.c.get('x').gv(markIndex)) / 2, (paneDrawInfo.c.get('y').gv(left) + paneDrawInfo.c.get('y').gv(markIndex)) / 2, (paneDrawInfo.c.get('size').gv(left) + paneDrawInfo.c.get('size').gv(markIndex)) / 2 + 20, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20);
		}
		if (right !== -1 && mode === 'lim-linear') {
			$tab_MarksRenderer.$boundLineEdgeInPlace(bbox, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20, (paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('x').gv(right)) / 2, (paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('y').gv(right)) / 2, (paneDrawInfo.c.get('size').gv(markIndex) + paneDrawInfo.c.get('size').gv(right)) / 2 + 20);
		}
		if (right !== -1 && (mode === 'lim-step' || mode === 'lim-jump')) {
			tab.RectXYUtil.encompassCircleInPlace(bbox, paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), (paneDrawInfo.c.get('size').gv(markIndex) + 20) / 2);
		}
		if (left !== -1 && mode === 'lim-step') {
			$tab_MarksRenderer.$boundLineEdgeInPlace(bbox, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(left), paneDrawInfo.c.get('size').gv(left) + 20, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20);
		}
		if (right !== -1 && (mode === 'lim-step' || mode === 'lim-jump')) {
			$tab_MarksRenderer.$boundLineEdgeInPlace(bbox, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20, paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20);
		}
		return bbox;
	};
	$tab_MarksRenderer.lineMarkExactHitTest = function MarksRenderer$LineMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var mode = paneDrawInfo.lineInterpolation;
		{
			if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 })) {
				return true;
			}
		}
		if (left !== -1 && mode === 'lim-linear') {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, (paneDrawInfo.c.get('x').gv(left) + paneDrawInfo.c.get('x').gv(markIndex)) / 2, (paneDrawInfo.c.get('y').gv(left) + paneDrawInfo.c.get('y').gv(markIndex)) / 2, (paneDrawInfo.c.get('size').gv(left) + paneDrawInfo.c.get('size').gv(markIndex)) / 2, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex))) {
				return true;
			}
		}
		if (right !== -1 && mode === 'lim-linear') {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), (paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('x').gv(right)) / 2, (paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('y').gv(right)) / 2, (paneDrawInfo.c.get('size').gv(markIndex) + paneDrawInfo.c.get('size').gv(right)) / 2)) {
				return true;
			}
		}
		if (right !== -1 && (mode === 'lim-step' || mode === 'lim-jump')) {
			if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(right), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 })) {
				return true;
			}
		}
		if (left !== -1 && mode === 'lim-step') {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(left), paneDrawInfo.c.get('size').gv(left), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex))) {
				return true;
			}
		}
		if (right !== -1 && (mode === 'lim-step' || mode === 'lim-jump')) {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex))) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.lineMarkNearHitTest = function MarksRenderer$LineMarkNearHitTest(paneDrawInfo, x, y, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var mode = paneDrawInfo.lineInterpolation;
		{
			if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: (paneDrawInfo.c.get('size').gv(markIndex) + 20) / 2 })) {
				return true;
			}
		}
		if (left !== -1 && mode === 'lim-linear') {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, (paneDrawInfo.c.get('x').gv(left) + paneDrawInfo.c.get('x').gv(markIndex)) / 2, (paneDrawInfo.c.get('y').gv(left) + paneDrawInfo.c.get('y').gv(markIndex)) / 2, (paneDrawInfo.c.get('size').gv(left) + paneDrawInfo.c.get('size').gv(markIndex)) / 2 + 20, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20)) {
				return true;
			}
		}
		if (right !== -1 && mode === 'lim-linear') {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20, (paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('x').gv(right)) / 2, (paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('y').gv(right)) / 2, (paneDrawInfo.c.get('size').gv(markIndex) + paneDrawInfo.c.get('size').gv(right)) / 2 + 20)) {
				return true;
			}
		}
		if (right !== -1 && (mode === 'lim-step' || mode === 'lim-jump')) {
			if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(right), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: (paneDrawInfo.c.get('size').gv(markIndex) + 20) / 2 })) {
				return true;
			}
		}
		if (left !== -1 && mode === 'lim-step') {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(left), paneDrawInfo.c.get('size').gv(left) + 20, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20)) {
				return true;
			}
		}
		if (right !== -1 && (mode === 'lim-step' || mode === 'lim-jump')) {
			if ($tab_MarksRenderer.$lineEdgeContains(x, y, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20, paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 20)) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.lineMarkGetHitTestExpansion = function MarksRenderer$LineMarkGetHitTestExpansion(paneDrawInfo, markIndex) {
		return { w: 0, h: 0 };
	};
	$tab_MarksRenderer.lineMarkGetDistanceToMark = function MarksRenderer$LineMarkGetDistanceToMark(paneDrawInfo, x, y, markIndex) {
		var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
		var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
		var x0 = paneDrawInfo.c.get('x1').gv(markIndex);
		var y0 = paneDrawInfo.c.get('y1').gv(markIndex);
		var distance;
		{
			var dx = x - x0;
			var dy = y - y0;
			var singlePointDistance = dx * dx + dy * dy;
			distance = singlePointDistance;
		}
		if (left !== -1) {
			var a = { x: (paneDrawInfo.c.get('x').gv(left) + x0) / 2, y: (paneDrawInfo.c.get('y').gv(left) + y0) / 2 };
			var b = { x: x0, y: y0 };
			var leftSegmentDistance = $tab_GeometryUtil.getSquaredDistanceToLineSegment({ x: x, y: y }, a, b);
			distance = Math.min(distance, leftSegmentDistance);
		}
		if (right !== -1) {
			var a1 = { x: x0, y: y0 };
			var b1 = { x: (paneDrawInfo.c.get('x').gv(right) + x0) / 2, y: (paneDrawInfo.c.get('y').gv(right) + y0) / 2 };
			var rightSegmentDistance = $tab_GeometryUtil.getSquaredDistanceToLineSegment({ x: x, y: y }, a1, b1);
			distance = Math.min(distance, rightSegmentDistance);
		}
		return distance;
	};
	$tab_MarksRenderer.lineMarkRectangleAreaHitTest = function MarksRenderer$LineMarkRectangleAreaHitTest(paneDrawInfo, selection, markIndex) {
		{
			if ($tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 }, selection)) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.lineMarkCircleAreaHitTest = function MarksRenderer$LineMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, markOffsetBBox, radialDistanceHitTest) {
		if (radialDistanceHitTest) {
			{
				{
					return $tab_GeometryUtil.isPointInCircle({ x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, circle);
				}
			}
		}
		{
			if ($tab_GeometryUtil.circleIntersectsCircle(circle, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 })) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.lineMarkPolygonAreaHitTest = function MarksRenderer$LineMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex, markOffsetBBox) {
		{
			if ($tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 })) {
				return true;
			}
		}
		return false;
	};
	$tab_MarksRenderer.shapeMarkBuildMarkBound = function MarksRenderer$ShapeMarkBuildMarkBound(paneDrawInfo, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				var bbox = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s2 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2);
					var s = 2 * s2;
					tab.RectXYUtil.unionInPlace$1(bbox, x - s2, y - s2, s, s);
				}
				return bbox;
			}
			case 'shapeIDFilledCircle': {
				var bbox1 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x1 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y1 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s21 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 / 2);
					var s1 = 2 * s21;
					tab.RectXYUtil.unionInPlace$1(bbox1, x1 - s21, y1 - s21, s1, s1);
				}
				return bbox1;
			}
			case 'shapeIDUnscaledFilledCircle': {
				var bbox2 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x2 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y2 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s22 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) / 2);
					var s3 = 2 * s22;
					tab.RectXYUtil.unionInPlace$1(bbox2, x2 - s22, y2 - s22, s3, s3);
				}
				return bbox2;
			}
			case 'shapeIDSquare': {
				var bbox3 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x3 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y3 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s23 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s4 = 2 * s23;
					tab.RectXYUtil.unionInPlace$1(bbox3, x3 - s23, y3 - s23, s4, s4);
				}
				return bbox3;
			}
			case 'shapeIDFilledSquare': {
				var bbox4 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x4 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y4 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s24 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s5 = 2 * s24;
					tab.RectXYUtil.unionInPlace$1(bbox4, x4 - s24, y4 - s24, s5, s5);
				}
				return bbox4;
			}
			case 'shapeIDAsterisk': {
				var bbox5 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x5 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y5 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s25 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2);
					var s6 = 2 * s25;
					tab.RectXYUtil.unionInPlace$1(bbox5, x5 - s25, y5 - s25, s6, s6);
				}
				return bbox5;
			}
			case 'shapeIDPlus': {
				var bbox6 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x6 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y6 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s26 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s7 = 2 * s26;
					tab.RectXYUtil.unionInPlace$1(bbox6, x6 - s26, y6 - s26, s7, s7);
				}
				return bbox6;
			}
			case 'shapeIDFilledPlus': {
				var bbox7 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x7 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y7 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s27 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s8 = 2 * s27;
					tab.RectXYUtil.unionInPlace$1(bbox7, x7 - s27, y7 - s27, s8, s8);
				}
				return bbox7;
			}
			case 'shapeIDTimes': {
				var bbox8 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x8 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y8 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s28 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2);
					var s9 = 2 * s28;
					tab.RectXYUtil.unionInPlace$1(bbox8, x8 - s28, y8 - s28, s9, s9);
				}
				return bbox8;
			}
			case 'shapeIDFilledTimes': {
				var bbox9 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x9 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y9 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s29 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s10 = 2 * s29;
					tab.RectXYUtil.unionInPlace$1(bbox9, x9 - s29, y9 - s29, s10, s10);
				}
				return bbox9;
			}
			case 'shapeIDDiamond': {
				var bbox10 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x10 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y10 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s210 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2);
					var s11 = 2 * s210;
					tab.RectXYUtil.unionInPlace$1(bbox10, x10 - s210, y10 - s210, s11, s11);
				}
				return bbox10;
			}
			case 'shapeIDFilledDiamond': {
				var bbox11 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x11 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y11 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s211 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2);
					var s12 = 2 * s211;
					tab.RectXYUtil.unionInPlace$1(bbox11, x11 - s211, y11 - s211, s12, s12);
				}
				return bbox11;
			}
			case 'shapeIDTriangle': {
				var bbox12 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x12 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y12 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s212 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s13 = 2 * s212;
					tab.RectXYUtil.unionInPlace$1(bbox12, x12 - s212, y12 - s212, s13, s13);
				}
				return bbox12;
			}
			case 'shapeIDFilledTriangle': {
				var bbox13 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x13 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y13 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s213 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s14 = 2 * s213;
					tab.RectXYUtil.unionInPlace$1(bbox13, x13 - s213, y13 - s213, s14, s14);
				}
				return bbox13;
			}
			case 'shapeIDDownTriangle': {
				var bbox14 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x14 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y14 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s214 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s15 = 2 * s214;
					tab.RectXYUtil.unionInPlace$1(bbox14, x14 - s214, y14 - s214, s15, s15);
				}
				return bbox14;
			}
			case 'shapeIDFilledDownTriangle': {
				var bbox15 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x15 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y15 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s215 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s16 = 2 * s215;
					tab.RectXYUtil.unionInPlace$1(bbox15, x15 - s215, y15 - s215, s16, s16);
				}
				return bbox15;
			}
			case 'shapeIDLeftTriangle': {
				var bbox16 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x16 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y16 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s216 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s17 = 2 * s216;
					tab.RectXYUtil.unionInPlace$1(bbox16, x16 - s216, y16 - s216, s17, s17);
				}
				return bbox16;
			}
			case 'shapeIDFilledLeftTriangle': {
				var bbox17 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x17 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y17 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s217 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s18 = 2 * s217;
					tab.RectXYUtil.unionInPlace$1(bbox17, x17 - s217, y17 - s217, s18, s18);
				}
				return bbox17;
			}
			case 'shapeIDRightTriangle': {
				var bbox18 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x18 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y18 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s218 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s19 = 2 * s218;
					tab.RectXYUtil.unionInPlace$1(bbox18, x18 - s218, y18 - s218, s19, s19);
				}
				return bbox18;
			}
			case 'shapeIDFilledRightTriangle': {
				var bbox19 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x19 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y19 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s219 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s20 = 2 * s219;
					tab.RectXYUtil.unionInPlace$1(bbox19, x19 - s219, y19 - s219, s20, s20);
				}
				return bbox19;
			}
			case 'shapeIDFilledStar': {
				var bbox20 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x20 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y20 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s220 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667 / 2);
					var s30 = 2 * s220;
					tab.RectXYUtil.unionInPlace$1(bbox20, x20 - s220, y20 - s220, s30, s30);
				}
				return bbox20;
			}
			default: {
				if (shape > 0) {
					var x21 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y21 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var size = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex));
					var halfSize = Math.ceil(size / 2);
					var bbox21 = { x: x21 - halfSize, y: y21 - halfSize, w: size, h: size };
					return bbox21;
				}
				break;
			}
		}
		return { x: 0, y: 0, w: 0, h: 0 };
	};
	$tab_MarksRenderer.shapeMarkExactHitTest = function MarksRenderer$ShapeMarkExactHitTest(paneDrawInfo, x, y, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				{
					if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2 })) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledCircle': {
				{
					if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 / 2 })) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDUnscaledFilledCircle': {
				{
					if ($tab_GeometryUtil.isPointInCircle({ x: x, y: y }, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 })) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDSquare': {
				{
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize, paneDrawInfo.c.get('y').gv(markIndex) - halfSize, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledSquare': {
				{
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize1, paneDrawInfo.c.get('y').gv(markIndex) - halfSize1, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDAsterisk': {
				{
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize2, paneDrawInfo.c.get('y').gv(markIndex) - halfSize2, paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDPlus': {
				{
					var halfSize3 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize3, paneDrawInfo.c.get('y').gv(markIndex) - halfSize3, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledPlus': {
				{
					var halfSize4 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize4, paneDrawInfo.c.get('y').gv(markIndex) - halfSize4, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDTimes': {
				{
					var halfSize5 = paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize5, paneDrawInfo.c.get('y').gv(markIndex) - halfSize5, paneDrawInfo.c.get('size').gv(markIndex) * 0.875, paneDrawInfo.c.get('size').gv(markIndex) * 0.875, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledTimes': {
				{
					var halfSize6 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize6, paneDrawInfo.c.get('y').gv(markIndex) - halfSize6, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDDiamond': {
				{
					var halfSize7 = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize7, paneDrawInfo.c.get('y').gv(markIndex) - halfSize7, paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667, paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledDiamond': {
				{
					var halfSize8 = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize8, paneDrawInfo.c.get('y').gv(markIndex) - halfSize8, paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667, paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDTriangle': {
				{
					var halfSize9 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize9, paneDrawInfo.c.get('y').gv(markIndex) - halfSize9, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledTriangle': {
				{
					var halfSize10 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize10, paneDrawInfo.c.get('y').gv(markIndex) - halfSize10, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDDownTriangle': {
				{
					var halfSize11 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize11, paneDrawInfo.c.get('y').gv(markIndex) - halfSize11, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledDownTriangle': {
				{
					var halfSize12 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize12, paneDrawInfo.c.get('y').gv(markIndex) - halfSize12, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDLeftTriangle': {
				{
					var halfSize13 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize13, paneDrawInfo.c.get('y').gv(markIndex) - halfSize13, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledLeftTriangle': {
				{
					var halfSize14 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize14, paneDrawInfo.c.get('y').gv(markIndex) - halfSize14, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDRightTriangle': {
				{
					var halfSize15 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize15, paneDrawInfo.c.get('y').gv(markIndex) - halfSize15, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledRightTriangle': {
				{
					var halfSize16 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize16, paneDrawInfo.c.get('y').gv(markIndex) - halfSize16, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			case 'shapeIDFilledStar': {
				{
					var halfSize17 = paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667 / 2;
					if (tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize17, paneDrawInfo.c.get('y').gv(markIndex) - halfSize17, paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667, paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667, x, y)) {
						return true;
					}
				}
				return false;
			}
			default: {
				if (shape > 0) {
					var size = paneDrawInfo.c.get('size').gv(markIndex);
					var halfSize18 = size / 2;
					return tab.DoubleRectXYUtil.inRect$1(paneDrawInfo.c.get('x').gv(markIndex) - halfSize18, paneDrawInfo.c.get('y').gv(markIndex) - halfSize18, size, size, x, y);
				}
				break;
			}
		}
		return true;
	};
	$tab_MarksRenderer.shapeMarkNearHitTest = function MarksRenderer$ShapeMarkNearHitTest(paneDrawInfo, x, y, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				return true;
			}
			case 'shapeIDFilledCircle': {
				return true;
			}
			case 'shapeIDUnscaledFilledCircle': {
				return true;
			}
			case 'shapeIDSquare': {
				return true;
			}
			case 'shapeIDFilledSquare': {
				return true;
			}
			case 'shapeIDAsterisk': {
				return true;
			}
			case 'shapeIDPlus': {
				return true;
			}
			case 'shapeIDFilledPlus': {
				return true;
			}
			case 'shapeIDTimes': {
				return true;
			}
			case 'shapeIDFilledTimes': {
				return true;
			}
			case 'shapeIDDiamond': {
				return true;
			}
			case 'shapeIDFilledDiamond': {
				return true;
			}
			case 'shapeIDTriangle': {
				return true;
			}
			case 'shapeIDFilledTriangle': {
				return true;
			}
			case 'shapeIDDownTriangle': {
				return true;
			}
			case 'shapeIDFilledDownTriangle': {
				return true;
			}
			case 'shapeIDLeftTriangle': {
				return true;
			}
			case 'shapeIDFilledLeftTriangle': {
				return true;
			}
			case 'shapeIDRightTriangle': {
				return true;
			}
			case 'shapeIDFilledRightTriangle': {
				return true;
			}
			case 'shapeIDFilledStar': {
				return true;
			}
			default: {
				break;
			}
		}
		return false;
	};
	$tab_MarksRenderer.shapeMarkGetHitTestExpansion = function MarksRenderer$ShapeMarkGetHitTestExpansion(paneDrawInfo, markIndex) {
		var expansion = null;
		{
			expansion = { w: 10, h: 10 };
		}
		return expansion;
	};
	$tab_MarksRenderer.shapeMarkGetDistanceToMark = function MarksRenderer$ShapeMarkGetDistanceToMark(paneDrawInfo, x, y, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				var markBound = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound, { x: x, y: y });
			}
			case 'shapeIDFilledCircle': {
				var markBound1 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound1, { x: x, y: y });
			}
			case 'shapeIDUnscaledFilledCircle': {
				var markBound2 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound2, { x: x, y: y });
			}
			case 'shapeIDSquare': {
				var markBound3 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound3, { x: x, y: y });
			}
			case 'shapeIDFilledSquare': {
				var markBound4 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound4, { x: x, y: y });
			}
			case 'shapeIDAsterisk': {
				var markBound5 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound5, { x: x, y: y });
			}
			case 'shapeIDPlus': {
				var markBound6 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound6, { x: x, y: y });
			}
			case 'shapeIDFilledPlus': {
				var markBound7 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound7, { x: x, y: y });
			}
			case 'shapeIDTimes': {
				var markBound8 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound8, { x: x, y: y });
			}
			case 'shapeIDFilledTimes': {
				var markBound9 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound9, { x: x, y: y });
			}
			case 'shapeIDDiamond': {
				var markBound10 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound10, { x: x, y: y });
			}
			case 'shapeIDFilledDiamond': {
				var markBound11 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound11, { x: x, y: y });
			}
			case 'shapeIDTriangle': {
				var markBound12 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound12, { x: x, y: y });
			}
			case 'shapeIDFilledTriangle': {
				var markBound13 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound13, { x: x, y: y });
			}
			case 'shapeIDDownTriangle': {
				var markBound14 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound14, { x: x, y: y });
			}
			case 'shapeIDFilledDownTriangle': {
				var markBound15 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound15, { x: x, y: y });
			}
			case 'shapeIDLeftTriangle': {
				var markBound16 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound16, { x: x, y: y });
			}
			case 'shapeIDFilledLeftTriangle': {
				var markBound17 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound17, { x: x, y: y });
			}
			case 'shapeIDRightTriangle': {
				var markBound18 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound18, { x: x, y: y });
			}
			case 'shapeIDFilledRightTriangle': {
				var markBound19 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound19, { x: x, y: y });
			}
			case 'shapeIDFilledStar': {
				var markBound20 = paneDrawInfo.getMarkBounds(markIndex);
				return $tab_GeometryUtil.getSquaredDistanceToCircumference(markBound20, { x: x, y: y });
			}
			default: {
				break;
			}
		}
		return $tab_GeometryUtil.getSquaredDistanceToCenter(paneDrawInfo.getMarkBounds(markIndex), { x: x, y: y });
	};
	$tab_MarksRenderer.shapeMarkRectangleAreaHitTest = function MarksRenderer$ShapeMarkRectangleAreaHitTest(paneDrawInfo, rect, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				return $tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2 }, rect);
			}
			case 'shapeIDFilledCircle': {
				return $tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 / 2 }, rect);
			}
			case 'shapeIDUnscaledFilledCircle': {
				return $tab_GeometryUtil.circleIntersectsRect({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 }, rect);
			}
			case 'shapeIDSquare': {
				return true;
			}
			case 'shapeIDFilledSquare': {
				return true;
			}
			case 'shapeIDAsterisk': {
				return true;
			}
			case 'shapeIDPlus': {
				return true;
			}
			case 'shapeIDFilledPlus': {
				return true;
			}
			case 'shapeIDTimes': {
				return true;
			}
			case 'shapeIDFilledTimes': {
				return true;
			}
			case 'shapeIDDiamond': {
				return true;
			}
			case 'shapeIDFilledDiamond': {
				return true;
			}
			case 'shapeIDTriangle': {
				return true;
			}
			case 'shapeIDFilledTriangle': {
				return true;
			}
			case 'shapeIDDownTriangle': {
				return true;
			}
			case 'shapeIDFilledDownTriangle': {
				return true;
			}
			case 'shapeIDLeftTriangle': {
				return true;
			}
			case 'shapeIDFilledLeftTriangle': {
				return true;
			}
			case 'shapeIDRightTriangle': {
				return true;
			}
			case 'shapeIDFilledRightTriangle': {
				return true;
			}
			case 'shapeIDFilledStar': {
				return true;
			}
			default: {
				break;
			}
		}
		return true;
	};
	$tab_MarksRenderer.shapeMarkCircleAreaHitTest = function MarksRenderer$ShapeMarkCircleAreaHitTest(paneDrawInfo, circle, markIndex, radialDistanceHitTest) {
		if (radialDistanceHitTest) {
			{
				{
					return $tab_GeometryUtil.isPointInCircle({ x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, circle);
				}
			}
		}
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				return $tab_GeometryUtil.circleIntersectsCircle({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2 }, circle);
			}
			case 'shapeIDFilledCircle': {
				return $tab_GeometryUtil.circleIntersectsCircle({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 / 2 }, circle);
			}
			case 'shapeIDUnscaledFilledCircle': {
				return $tab_GeometryUtil.circleIntersectsCircle({ center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 }, circle);
			}
			case 'shapeIDSquare': {
				var bbox = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s2 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s = 2 * s2;
					tab.RectXYUtil.unionInPlace$1(bbox, x - s2, y - s2, s, s);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox);
			}
			case 'shapeIDFilledSquare': {
				var bbox1 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x1 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y1 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s21 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s1 = 2 * s21;
					tab.RectXYUtil.unionInPlace$1(bbox1, x1 - s21, y1 - s21, s1, s1);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox1);
			}
			case 'shapeIDAsterisk': {
				var bbox2 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x2 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y2 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s22 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2);
					var s3 = 2 * s22;
					tab.RectXYUtil.unionInPlace$1(bbox2, x2 - s22, y2 - s22, s3, s3);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox2);
			}
			case 'shapeIDPlus': {
				var bbox3 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x3 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y3 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s23 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s4 = 2 * s23;
					tab.RectXYUtil.unionInPlace$1(bbox3, x3 - s23, y3 - s23, s4, s4);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox3);
			}
			case 'shapeIDFilledPlus': {
				var bbox4 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x4 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y4 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s24 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s5 = 2 * s24;
					tab.RectXYUtil.unionInPlace$1(bbox4, x4 - s24, y4 - s24, s5, s5);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox4);
			}
			case 'shapeIDTimes': {
				var bbox5 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x5 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y5 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s25 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2);
					var s6 = 2 * s25;
					tab.RectXYUtil.unionInPlace$1(bbox5, x5 - s25, y5 - s25, s6, s6);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox5);
			}
			case 'shapeIDFilledTimes': {
				var bbox6 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x6 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y6 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s26 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s7 = 2 * s26;
					tab.RectXYUtil.unionInPlace$1(bbox6, x6 - s26, y6 - s26, s7, s7);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox6);
			}
			case 'shapeIDDiamond': {
				var bbox7 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x7 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y7 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s27 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2);
					var s8 = 2 * s27;
					tab.RectXYUtil.unionInPlace$1(bbox7, x7 - s27, y7 - s27, s8, s8);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox7);
			}
			case 'shapeIDFilledDiamond': {
				var bbox8 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x8 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y8 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s28 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2);
					var s9 = 2 * s28;
					tab.RectXYUtil.unionInPlace$1(bbox8, x8 - s28, y8 - s28, s9, s9);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox8);
			}
			case 'shapeIDTriangle': {
				var bbox9 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x9 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y9 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s29 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s10 = 2 * s29;
					tab.RectXYUtil.unionInPlace$1(bbox9, x9 - s29, y9 - s29, s10, s10);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox9);
			}
			case 'shapeIDFilledTriangle': {
				var bbox10 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x10 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y10 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s210 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s11 = 2 * s210;
					tab.RectXYUtil.unionInPlace$1(bbox10, x10 - s210, y10 - s210, s11, s11);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox10);
			}
			case 'shapeIDDownTriangle': {
				var bbox11 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x11 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y11 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s211 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s12 = 2 * s211;
					tab.RectXYUtil.unionInPlace$1(bbox11, x11 - s211, y11 - s211, s12, s12);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox11);
			}
			case 'shapeIDFilledDownTriangle': {
				var bbox12 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x12 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y12 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s212 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s13 = 2 * s212;
					tab.RectXYUtil.unionInPlace$1(bbox12, x12 - s212, y12 - s212, s13, s13);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox12);
			}
			case 'shapeIDLeftTriangle': {
				var bbox13 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x13 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y13 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s213 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s14 = 2 * s213;
					tab.RectXYUtil.unionInPlace$1(bbox13, x13 - s213, y13 - s213, s14, s14);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox13);
			}
			case 'shapeIDFilledLeftTriangle': {
				var bbox14 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x14 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y14 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s214 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s15 = 2 * s214;
					tab.RectXYUtil.unionInPlace$1(bbox14, x14 - s214, y14 - s214, s15, s15);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox14);
			}
			case 'shapeIDRightTriangle': {
				var bbox15 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x15 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y15 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s215 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s16 = 2 * s215;
					tab.RectXYUtil.unionInPlace$1(bbox15, x15 - s215, y15 - s215, s16, s16);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox15);
			}
			case 'shapeIDFilledRightTriangle': {
				var bbox16 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x16 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y16 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s216 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s17 = 2 * s216;
					tab.RectXYUtil.unionInPlace$1(bbox16, x16 - s216, y16 - s216, s17, s17);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox16);
			}
			case 'shapeIDFilledStar': {
				var bbox17 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x17 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y17 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s217 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667 / 2);
					var s18 = 2 * s217;
					tab.RectXYUtil.unionInPlace$1(bbox17, x17 - s217, y17 - s217, s18, s18);
				}
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox17);
			}
			default: {
				var x18 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
				var y18 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
				var size = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex));
				var halfSize = Math.ceil(size / 2);
				var bbox18 = { x: x18 - halfSize, y: y18 - halfSize, w: size, h: size };
				return $tab_GeometryUtil.circleIntersectsRect(circle, bbox18);
			}
		}
	};
	$tab_MarksRenderer.shapeMarkPolygonAreaHitTest = function MarksRenderer$ShapeMarkPolygonAreaHitTest(paneDrawInfo, selectionPointsInclWorldOffset, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		switch (shape) {
			case 'shapeIDCircle': {
				return $tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2 });
			}
			case 'shapeIDFilledCircle': {
				return $tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 / 2 });
			}
			case 'shapeIDUnscaledFilledCircle': {
				return $tab_GeometryUtil.polygonIntersectsCircle(selectionPointsInclWorldOffset, { center: { x: paneDrawInfo.c.get('x').gv(markIndex), y: paneDrawInfo.c.get('y').gv(markIndex) }, radius: paneDrawInfo.c.get('size').gv(markIndex) / 2 });
			}
			case 'shapeIDSquare': {
				var bbox = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s2 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s = 2 * s2;
					tab.RectXYUtil.unionInPlace$1(bbox, x - s2, y - s2, s, s);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox);
			}
			case 'shapeIDFilledSquare': {
				var bbox1 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x1 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y1 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s21 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s1 = 2 * s21;
					tab.RectXYUtil.unionInPlace$1(bbox1, x1 - s21, y1 - s21, s1, s1);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox1);
			}
			case 'shapeIDAsterisk': {
				var bbox2 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x2 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y2 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s22 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2);
					var s3 = 2 * s22;
					tab.RectXYUtil.unionInPlace$1(bbox2, x2 - s22, y2 - s22, s3, s3);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox2);
			}
			case 'shapeIDPlus': {
				var bbox3 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x3 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y3 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s23 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s4 = 2 * s23;
					tab.RectXYUtil.unionInPlace$1(bbox3, x3 - s23, y3 - s23, s4, s4);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox3);
			}
			case 'shapeIDFilledPlus': {
				var bbox4 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x4 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y4 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s24 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s5 = 2 * s24;
					tab.RectXYUtil.unionInPlace$1(bbox4, x4 - s24, y4 - s24, s5, s5);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox4);
			}
			case 'shapeIDTimes': {
				var bbox5 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x5 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y5 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s25 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2);
					var s6 = 2 * s25;
					tab.RectXYUtil.unionInPlace$1(bbox5, x5 - s25, y5 - s25, s6, s6);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox5);
			}
			case 'shapeIDFilledTimes': {
				var bbox6 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x6 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y6 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s26 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2);
					var s7 = 2 * s26;
					tab.RectXYUtil.unionInPlace$1(bbox6, x6 - s26, y6 - s26, s7, s7);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox6);
			}
			case 'shapeIDDiamond': {
				var bbox7 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x7 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y7 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s27 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2);
					var s8 = 2 * s27;
					tab.RectXYUtil.unionInPlace$1(bbox7, x7 - s27, y7 - s27, s8, s8);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox7);
			}
			case 'shapeIDFilledDiamond': {
				var bbox8 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x8 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y8 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s28 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2);
					var s9 = 2 * s28;
					tab.RectXYUtil.unionInPlace$1(bbox8, x8 - s28, y8 - s28, s9, s9);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox8);
			}
			case 'shapeIDTriangle': {
				var bbox9 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x9 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y9 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s29 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s10 = 2 * s29;
					tab.RectXYUtil.unionInPlace$1(bbox9, x9 - s29, y9 - s29, s10, s10);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox9);
			}
			case 'shapeIDFilledTriangle': {
				var bbox10 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x10 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y10 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s210 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s11 = 2 * s210;
					tab.RectXYUtil.unionInPlace$1(bbox10, x10 - s210, y10 - s210, s11, s11);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox10);
			}
			case 'shapeIDDownTriangle': {
				var bbox11 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x11 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y11 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s211 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s12 = 2 * s211;
					tab.RectXYUtil.unionInPlace$1(bbox11, x11 - s211, y11 - s211, s12, s12);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox11);
			}
			case 'shapeIDFilledDownTriangle': {
				var bbox12 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x12 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y12 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s212 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s13 = 2 * s212;
					tab.RectXYUtil.unionInPlace$1(bbox12, x12 - s212, y12 - s212, s13, s13);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox12);
			}
			case 'shapeIDLeftTriangle': {
				var bbox13 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x13 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y13 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s213 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s14 = 2 * s213;
					tab.RectXYUtil.unionInPlace$1(bbox13, x13 - s213, y13 - s213, s14, s14);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox13);
			}
			case 'shapeIDFilledLeftTriangle': {
				var bbox14 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x14 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y14 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s214 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s15 = 2 * s214;
					tab.RectXYUtil.unionInPlace$1(bbox14, x14 - s214, y14 - s214, s15, s15);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox14);
			}
			case 'shapeIDRightTriangle': {
				var bbox15 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x15 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y15 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s215 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2);
					var s16 = 2 * s215;
					tab.RectXYUtil.unionInPlace$1(bbox15, x15 - s215, y15 - s215, s16, s16);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox15);
			}
			case 'shapeIDFilledRightTriangle': {
				var bbox16 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x16 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y16 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s216 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2);
					var s17 = 2 * s216;
					tab.RectXYUtil.unionInPlace$1(bbox16, x16 - s216, y16 - s216, s17, s17);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox16);
			}
			case 'shapeIDFilledStar': {
				var bbox17 = { x: 0, y: 0, w: 0, h: 0 };
				{
					var x17 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
					var y17 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
					var s217 = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667 / 2);
					var s18 = 2 * s217;
					tab.RectXYUtil.unionInPlace$1(bbox17, x17 - s217, y17 - s217, s18, s18);
				}
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox17);
			}
			default: {
				var x18 = Math.round(paneDrawInfo.c.get('x').gv(markIndex));
				var y18 = Math.round(paneDrawInfo.c.get('y').gv(markIndex));
				var size = Math.ceil(paneDrawInfo.c.get('size').gv(markIndex));
				var halfSize = Math.ceil(size / 2);
				var bbox18 = { x: x18 - halfSize, y: y18 - halfSize, w: size, h: size };
				return $tab_GeometryUtil.polygonIntersectsRect(selectionPointsInclWorldOffset, bbox18);
			}
		}
	};
	$tab_MarksRenderer.renderMultipolygonMarkHoverOverlayImage = function MarksRenderer$RenderMultipolygonMarkHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				{
					var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount = offsets.length;
					for (var index = 0; index < offsetCount; index++) {
						var offset = offsets[index];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
						{
							var strokeSizeOffset = $tab_MarksRenderer.get_$multipolyLineSizeOffset();
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.save();
								tabContext.translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
								tabContext.scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
							}
							tab.CanvasRenderer.createMultipolygonPath(tabContext, geometryPM);
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.restore();
							}
							tabContext.set_lineWidth(1.75 - strokeSizeOffset);
							tabContext.set_strokeStyle(paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone']);
							tabContext.stroke();
						}
						if (offset !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			case 'multiLineString': {
				{
					var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount1 = offsets1.length;
					for (var index1 = 0; index1 < offsetCount1; index1++) {
						var offset1 = offsets1[index1];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
						var colorOverrideMode = 'colorOverrideNone';
						if (!paneDrawInfo.hasPixelGeometry) {
							tabContext.save();
							tabContext.translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
							tabContext.scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
						}
						tab.CanvasRenderer.createMultiLinePath(tabContext, geometryPM);
						if (!paneDrawInfo.hasPixelGeometry) {
							tabContext.restore();
						}
						{
							tab.CanvasRenderer.fillMultiLineStringPath(tabContext, paneDrawInfo.c.get('size').gv(markIndex) + 3.5, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							tab.CanvasRenderer.fillMultiLineStringEndCaps(tabContext, geometryPM.multiLine, paneDrawInfo.c.get('size').gv(markIndex) + 3.5, 1.75, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							tab.CanvasRenderer.fillClearMultiLineStringPath(tabContext, paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
						if (offset1 !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			case 'multiPoint': {
				{
					var offsets2 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount2 = offsets2.length;
					for (var index2 = 0; index2 < offsetCount2; index2++) {
						var offset2 = offsets2[index2];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset2);
						{
							var strokeSizeOffset1 = $tab_MarksRenderer.get_$multipolyLineSizeOffset();
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.save();
								tabContext.translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
								tabContext.scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
							}
							tab.CanvasRenderer.createMultipointPath(tabContext, 7, geometryPM);
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.restore();
							}
							tabContext.set_lineWidth(1.75 - strokeSizeOffset1);
							tabContext.set_strokeStyle(paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone']);
							tabContext.stroke();
						}
						if (offset2 !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			case 'empty': {
				{
					var offsets3 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount3 = offsets3.length;
					for (var index3 = 0; index3 < offsetCount3; index3++) {
						var offset3 = offsets3[index3];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset3);
						{
							var strokeSizeOffset2 = $tab_MarksRenderer.get_$multipolyLineSizeOffset();
							tab.CanvasRenderer.createPlaceholderPath(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), 7);
							tabContext.set_lineWidth(1.75 - strokeSizeOffset2);
							tabContext.set_strokeStyle(paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone']);
							tabContext.stroke();
						}
						if (offset3 !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			default: {
				break;
			}
		}
	};
	$tab_MarksRenderer.renderMultipolygonMarkPressedOverlayImage = function MarksRenderer$RenderMultipolygonMarkPressedOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var geometryType = 'empty';
		var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
		if (ss.isValue(geometryPM)) {
			geometryType = geometryPM.geometryType;
		}
		switch (geometryType) {
			case 'multiPolygon': {
				{
					var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount = offsets.length;
					for (var index = 0; index < offsetCount; index++) {
						var offset = offsets[index];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
						{
							var strokeSizeOffset = $tab_MarksRenderer.get_$multipolyLineSizeOffset();
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.save();
								tabContext.translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
								tabContext.scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
							}
							tab.CanvasRenderer.createMultipolygonPath(tabContext, geometryPM);
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.restore();
							}
							tabContext.set_lineWidth(2.5 - strokeSizeOffset);
							tabContext.set_strokeStyle(paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone']);
							tabContext.stroke();
						}
						if (offset !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			case 'multiLineString': {
				{
					var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount1 = offsets1.length;
					for (var index1 = 0; index1 < offsetCount1; index1++) {
						var offset1 = offsets1[index1];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
						var colorOverrideMode = 'colorOverrideNone';
						if (!paneDrawInfo.hasPixelGeometry) {
							tabContext.save();
							tabContext.translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
							tabContext.scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
						}
						tab.CanvasRenderer.createMultiLinePath(tabContext, geometryPM);
						if (!paneDrawInfo.hasPixelGeometry) {
							tabContext.restore();
						}
						{
							tab.CanvasRenderer.fillMultiLineStringPath(tabContext, paneDrawInfo.c.get('size').gv(markIndex) + 5, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							tab.CanvasRenderer.fillMultiLineStringEndCaps(tabContext, geometryPM.multiLine, paneDrawInfo.c.get('size').gv(markIndex) + 5, 2.5, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							tab.CanvasRenderer.fillClearMultiLineStringPath(tabContext, paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
						if (offset1 !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			case 'multiPoint': {
				{
					var offsets2 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount2 = offsets2.length;
					for (var index2 = 0; index2 < offsetCount2; index2++) {
						var offset2 = offsets2[index2];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset2);
						{
							var strokeSizeOffset1 = $tab_MarksRenderer.get_$multipolyLineSizeOffset();
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.save();
								tabContext.translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
								tabContext.scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
							}
							tab.CanvasRenderer.createMultipointPath(tabContext, 7, geometryPM);
							if (!paneDrawInfo.hasPixelGeometry) {
								tabContext.restore();
							}
							tabContext.set_lineWidth(2.5 - strokeSizeOffset1);
							tabContext.set_strokeStyle(paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone']);
							tabContext.stroke();
						}
						if (offset2 !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			case 'empty': {
				{
					var offsets3 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount3 = offsets3.length;
					for (var index3 = 0; index3 < offsetCount3; index3++) {
						var offset3 = offsets3[index3];
						$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset3);
						{
							var strokeSizeOffset2 = $tab_MarksRenderer.get_$multipolyLineSizeOffset();
							tab.CanvasRenderer.createPlaceholderPath(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), 7);
							tabContext.set_lineWidth(2.5 - strokeSizeOffset2);
							tabContext.set_strokeStyle(paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone']);
							tabContext.stroke();
						}
						if (offset3 !== 0) {
							tabContext.restore();
						}
					}
				}
				break;
			}
			default: {
				break;
			}
		}
	};
	$tab_MarksRenderer.renderAreaMarkHoverOverlayImage = function MarksRenderer$RenderAreaMarkHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var nextOrPrevBrushed = false;
		if (markIndex - 1 > 0 && !paneDrawInfo.isMarkEndPrimitive(markIndex - 1)) {
			nextOrPrevBrushed = nextOrPrevBrushed || paneDrawInfo.isMarkHighlighted(markIndex - 1);
		}
		if (markIndex + 1 < paneDrawInfo.markCount && !paneDrawInfo.isMarkEndPrimitive(markIndex)) {
			nextOrPrevBrushed = nextOrPrevBrushed || paneDrawInfo.isMarkHighlighted(markIndex + 1);
		}
		var color;
		var x = paneDrawInfo.c.get('x').gv(markIndex);
		var y = paneDrawInfo.c.get('y').gv(markIndex);
		if (paneDrawInfo.isMarkSelected(markIndex)) {
			color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
			{
				var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
				var primitiveSize = 7 + (drawBorder ? 2 : 0);
				tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 4);
			}
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideOpaque'];
			{
				var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount = offsets.length;
				for (var index = 0; index < offsetCount; index++) {
					var offset = offsets[index];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 7, color);
					if (offset !== 0) {
						tabContext.restore();
					}
				}
			}
			x = paneDrawInfo.c.get('x1').gv(markIndex);
			y = paneDrawInfo.c.get('y1').gv(markIndex);
			color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
			{
				var drawBorder1 = paneDrawInfo.c.get('draw_border').gv(markIndex);
				var primitiveSize1 = 7 + (drawBorder1 ? 2 : 0);
				tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize1, color, 4);
			}
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideOpaque'];
			{
				var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount1 = offsets1.length;
				for (var index1 = 0; index1 < offsetCount1; index1++) {
					var offset1 = offsets1[index1];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 7, color);
					if (offset1 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		else if (paneDrawInfo.isMarkHighlighted(markIndex) && !nextOrPrevBrushed) {
			color = paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)['colorOverrideNone'];
			{
				var offsets2 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount2 = offsets2.length;
				for (var index2 = 0; index2 < offsetCount2; index2++) {
					var offset2 = offsets2[index2];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset2);
					{
						var drawBorder2 = paneDrawInfo.c.get('draw_border').gv(markIndex);
						var primitiveSize2 = 7 + (drawBorder2 ? 2 : 0);
						tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize2, color, 4);
					}
					if (offset2 !== 0) {
						tabContext.restore();
					}
				}
			}
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideNone'];
			{
				var offsets3 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount3 = offsets3.length;
				for (var index3 = 0; index3 < offsetCount3; index3++) {
					var offset3 = offsets3[index3];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset3);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 7, color);
					if (offset3 !== 0) {
						tabContext.restore();
					}
				}
			}
			x = paneDrawInfo.c.get('x1').gv(markIndex);
			y = paneDrawInfo.c.get('y1').gv(markIndex);
			color = paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)['colorOverrideNone'];
			{
				var offsets4 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount4 = offsets4.length;
				for (var index4 = 0; index4 < offsetCount4; index4++) {
					var offset4 = offsets4[index4];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset4);
					{
						var drawBorder3 = paneDrawInfo.c.get('draw_border').gv(markIndex);
						var primitiveSize3 = 7 + (drawBorder3 ? 2 : 0);
						tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize3, color, 4);
					}
					if (offset4 !== 0) {
						tabContext.restore();
					}
				}
			}
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideNone'];
			{
				var offsets5 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount5 = offsets5.length;
				for (var index5 = 0; index5 < offsetCount5; index5++) {
					var offset5 = offsets5[index5];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset5);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 7, color);
					if (offset5 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		else {
			color = (paneDrawInfo.drawBorder ? paneDrawInfo.get_borderColor() : tab.SceneUtils.blackColor)['colorOverrideNone'];
			{
				var offsets6 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount6 = offsets6.length;
				for (var index6 = 0; index6 < offsetCount6; index6++) {
					var offset6 = offsets6[index6];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset6);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 5, color);
					if (offset6 !== 0) {
						tabContext.restore();
					}
				}
			}
			x = paneDrawInfo.c.get('x1').gv(markIndex);
			y = paneDrawInfo.c.get('y1').gv(markIndex);
			color = (paneDrawInfo.drawBorder ? paneDrawInfo.get_borderColor() : tab.SceneUtils.blackColor)['colorOverrideNone'];
			{
				var offsets7 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount7 = offsets7.length;
				for (var index7 = 0; index7 < offsetCount7; index7++) {
					var offset7 = offsets7[index7];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset7);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 5, color);
					if (offset7 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
	};
	$tab_MarksRenderer.renderAreaMarkPressedOverlayImage = function MarksRenderer$RenderAreaMarkPressedOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var color = (paneDrawInfo.drawBorder ? paneDrawInfo.get_borderColor() : tab.SceneUtils.blackColor)['colorOverrideNone'];
		var x = paneDrawInfo.c.get('x').gv(markIndex);
		var y = paneDrawInfo.c.get('y').gv(markIndex);
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 7, color);
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
		x = paneDrawInfo.c.get('x1').gv(markIndex);
		y = paneDrawInfo.c.get('y1').gv(markIndex);
		{
			var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount1 = offsets1.length;
			for (var index1 = 0; index1 < offsetCount1; index1++) {
				var offset1 = offsets1[index1];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
				tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, 7, color);
				if (offset1 !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderPieHoverOverlayImage = function MarksRenderer$RenderPieHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
		var offsetCount = offsets.length;
		for (var index = 0; index < offsetCount; index++) {
			var offset = offsets[index];
			$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
			var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
			var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
			var borderSizeOffset = (!!drawBorder ? 1 : 0);
			var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
			var theta = paneDrawInfo.c.get('theta').gv(markIndex);
			var theta1 = paneDrawInfo.c.get('theta1').gv(markIndex);
			var anticlockwise = theta > theta1;
			if (Math.abs(theta - theta1) >= 1) {
				tab.CanvasRenderer.renderCircle(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), (radius + borderSizeOffset) * 2, color, 1);
			}
			else {
				tab.CanvasRenderer.renderWedge(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius, theta, theta1, color, 1 + borderSizeOffset, anticlockwise);
			}
			if (offset !== 0) {
				tabContext.restore();
			}
		}
	};
	$tab_MarksRenderer.renderPiePressedOverlayImage = function MarksRenderer$RenderPiePressedOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
		var offsetCount = offsets.length;
		for (var index = 0; index < offsetCount; index++) {
			var offset = offsets[index];
			$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
			var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
			var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
			var borderSizeOffset = (!!drawBorder ? 1 : 0);
			var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
			var theta = paneDrawInfo.c.get('theta').gv(markIndex);
			var theta1 = paneDrawInfo.c.get('theta1').gv(markIndex);
			var anticlockwise = theta > theta1;
			if (Math.abs(theta - theta1) >= 1) {
				tab.CanvasRenderer.renderCircle(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), (radius + borderSizeOffset) * 2, color, 2);
			}
			else {
				tab.CanvasRenderer.renderWedge(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius, theta, theta1, color, 2 + borderSizeOffset, anticlockwise);
			}
			if (offset !== 0) {
				tabContext.restore();
			}
		}
	};
	$tab_MarksRenderer.renderTextHoverOverlayImage = function MarksRenderer$RenderTextHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
			{
				var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount = offsets.length;
				for (var index = 0; index < offsetCount; index++) {
					var offset = offsets[index];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
					var leftOffset = -paneDrawInfo.c.get('width').gv(markIndex) / 2;
					var bottomOffset = paneDrawInfo.c.get('height').gv(markIndex) / 2 - 1;
					var x0 = paneDrawInfo.c.get('x').gv(markIndex) + leftOffset;
					var y0 = paneDrawInfo.c.get('y').gv(markIndex) + bottomOffset;
					var x1 = paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('width').gv(markIndex) + leftOffset;
					var y1 = paneDrawInfo.c.get('y').gv(markIndex) + bottomOffset;
					var height = 1;
					var width = x1 - x0;
					var path = [x0, y0 + height - 1, x0 + width, y0 + height - 1];
					tabContext.set_lineCap('square');
					tabContext.set_lineWidth(height);
					tabContext.set_strokeStyle(paneDrawInfo.getMarkColors(markIndex)['colorOverrideOpaque']);
					tab.CanvasRenderer.strokePath(tabContext, path, false, true);
					if (offset !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
			{
				var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount1 = offsets1.length;
				for (var index1 = 0; index1 < offsetCount1; index1++) {
					var offset1 = offsets1[index1];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
					{
						var inset = 2;
						var left = paneDrawInfo.c.get('x').gv(markIndex) - paneDrawInfo.c.get('clip_width').gv(markIndex) / 2 + inset;
						var right = paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('clip_width').gv(markIndex) / 2 - inset;
						var top = paneDrawInfo.c.get('y').gv(markIndex) - paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 + inset;
						var bottom = paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 - inset;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left, right, top, bottom, paneDrawInfo.getMarkColors(markIndex), !!false, Math.floor(1));
					}
					if (offset1 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
	};
	$tab_MarksRenderer.renderTextPressedOverlayImage = function MarksRenderer$RenderTextPressedOverlayImage(tabContext, paneDrawInfo, markIndex) {
		if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
			{
				var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount = offsets.length;
				for (var index = 0; index < offsetCount; index++) {
					var offset = offsets[index];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
					var leftOffset = -paneDrawInfo.c.get('width').gv(markIndex) / 2;
					var bottomOffset = paneDrawInfo.c.get('height').gv(markIndex) / 2 - 1;
					var x0 = paneDrawInfo.c.get('x').gv(markIndex) + leftOffset;
					var y0 = paneDrawInfo.c.get('y').gv(markIndex) + bottomOffset;
					var x1 = paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('width').gv(markIndex) + leftOffset;
					var y1 = paneDrawInfo.c.get('y').gv(markIndex) + bottomOffset;
					var height = 2;
					var width = x1 - x0;
					var path = [x0, y0 + height - 1, x0 + width, y0 + height - 1];
					tabContext.set_lineCap('square');
					tabContext.set_lineWidth(height);
					tabContext.set_strokeStyle(paneDrawInfo.getMarkColors(markIndex)['colorOverrideOpaque']);
					tab.CanvasRenderer.strokePath(tabContext, path, false, true);
					if (offset !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
			{
				var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount1 = offsets1.length;
				for (var index1 = 0; index1 < offsetCount1; index1++) {
					var offset1 = offsets1[index1];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
					{
						var inset = 2;
						var left = paneDrawInfo.c.get('x').gv(markIndex) - paneDrawInfo.c.get('clip_width').gv(markIndex) / 2 + inset;
						var right = paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('clip_width').gv(markIndex) / 2 - inset;
						var top = paneDrawInfo.c.get('y').gv(markIndex) - paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 + inset;
						var bottom = paneDrawInfo.c.get('y').gv(markIndex) + paneDrawInfo.c.get('clip_height').gv(markIndex) / 2 - inset;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left, right, top, bottom, paneDrawInfo.getMarkColors(markIndex), !!false, Math.floor(2));
					}
					if (offset1 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
	};
	$tab_MarksRenderer.renderBarHoverOverlayImage = function MarksRenderer$RenderBarHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var halfSize = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
		var borderWidth = 1;
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			{
				var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount = offsets.length;
				for (var index = 0; index < offsetCount; index++) {
					var offset = offsets[index];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
					{
						var inset = 0;
						var left = paneDrawInfo.c.get('x').gv(markIndex) + inset;
						var right = paneDrawInfo.c.get('x1').gv(markIndex) - inset;
						var top = paneDrawInfo.c.get('y').gv(markIndex) + inset;
						var bottom = paneDrawInfo.c.get('y1').gv(markIndex) - inset;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left, right, top, bottom, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!false, Math.floor(borderWidth));
					}
					if (offset !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			{
				var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount1 = offsets1.length;
				for (var index1 = 0; index1 < offsetCount1; index1++) {
					var offset1 = offsets1[index1];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
					{
						var inset1 = 0;
						var left1 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize + inset1;
						var right1 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize - inset1;
						var top1 = paneDrawInfo.c.get('y').gv(markIndex) + inset1;
						var bottom1 = paneDrawInfo.c.get('y1').gv(markIndex) - inset1;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left1, right1, top1, bottom1, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!false, Math.floor(borderWidth));
					}
					if (offset1 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			{
				var offsets2 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount2 = offsets2.length;
				for (var index2 = 0; index2 < offsetCount2; index2++) {
					var offset2 = offsets2[index2];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset2);
					{
						var inset2 = 0;
						var left2 = paneDrawInfo.c.get('x').gv(markIndex) + inset2;
						var right2 = paneDrawInfo.c.get('x1').gv(markIndex) - inset2;
						var top2 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize + inset2;
						var bottom2 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize - inset2;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left2, right2, top2, bottom2, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!false, Math.floor(borderWidth));
					}
					if (offset2 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			{
				var offsets3 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount3 = offsets3.length;
				for (var index3 = 0; index3 < offsetCount3; index3++) {
					var offset3 = offsets3[index3];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset3);
					{
						var inset3 = 0;
						var left3 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize + inset3;
						var right3 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize - inset3;
						var top3 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize + inset3;
						var bottom3 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize - inset3;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left3, right3, top3, bottom3, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!true, Math.floor(borderWidth));
					}
					if (offset3 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
	};
	$tab_MarksRenderer.renderBarPressedOverlayImage = function MarksRenderer$RenderBarPressedOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var halfSize = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
		var borderWidth = 2;
		if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			{
				var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount = offsets.length;
				for (var index = 0; index < offsetCount; index++) {
					var offset = offsets[index];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
					{
						var inset = 0;
						var left = paneDrawInfo.c.get('x').gv(markIndex) + inset;
						var right = paneDrawInfo.c.get('x1').gv(markIndex) - inset;
						var top = paneDrawInfo.c.get('y').gv(markIndex) + inset;
						var bottom = paneDrawInfo.c.get('y1').gv(markIndex) - inset;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left, right, top, bottom, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!false, Math.floor(borderWidth));
					}
					if (offset !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
			{
				var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount1 = offsets1.length;
				for (var index1 = 0; index1 < offsetCount1; index1++) {
					var offset1 = offsets1[index1];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
					{
						var inset1 = 0;
						var left1 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize + inset1;
						var right1 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize - inset1;
						var top1 = paneDrawInfo.c.get('y').gv(markIndex) + inset1;
						var bottom1 = paneDrawInfo.c.get('y1').gv(markIndex) - inset1;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left1, right1, top1, bottom1, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!false, Math.floor(borderWidth));
					}
					if (offset1 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			{
				var offsets2 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount2 = offsets2.length;
				for (var index2 = 0; index2 < offsetCount2; index2++) {
					var offset2 = offsets2[index2];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset2);
					{
						var inset2 = 0;
						var left2 = paneDrawInfo.c.get('x').gv(markIndex) + inset2;
						var right2 = paneDrawInfo.c.get('x1').gv(markIndex) - inset2;
						var top2 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize + inset2;
						var bottom2 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize - inset2;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left2, right2, top2, bottom2, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!false, Math.floor(borderWidth));
					}
					if (offset2 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
			{
				var offsets3 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount3 = offsets3.length;
				for (var index3 = 0; index3 < offsetCount3; index3++) {
					var offset3 = offsets3[index3];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset3);
					{
						var inset3 = 0;
						var left3 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize + inset3;
						var right3 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize - inset3;
						var top3 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize + inset3;
						var bottom3 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize - inset3;
						$tab_MarksRenderer.$drawBarInSprite(tabContext, paneDrawInfo, markIndex, left3, right3, top3, bottom3, paneDrawInfo.c.get('selected_halo_color').gv(markIndex), !!true, Math.floor(borderWidth));
					}
					if (offset3 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
	};
	$tab_MarksRenderer.renderLineMarkHoverOverlayImage = function MarksRenderer$RenderLineMarkHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var nextOrPrevBrushed = false;
		if (markIndex - 1 > 0 && !paneDrawInfo.isMarkEndPrimitive(markIndex - 1)) {
			nextOrPrevBrushed = nextOrPrevBrushed || paneDrawInfo.isMarkHighlighted(markIndex - 1);
		}
		if (markIndex + 1 < paneDrawInfo.markCount && !paneDrawInfo.isMarkEndPrimitive(markIndex)) {
			nextOrPrevBrushed = nextOrPrevBrushed || paneDrawInfo.isMarkHighlighted(markIndex + 1);
		}
		var color;
		var x = paneDrawInfo.c.get('x').gv(markIndex);
		var y = paneDrawInfo.c.get('y').gv(markIndex);
		if (paneDrawInfo.isMarkSelected(markIndex)) {
			color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
			{
				var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
				var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) + 4 + 4 + (drawBorder ? 2 : 0);
				tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 4);
			}
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideOpaque'];
			{
				var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount = offsets.length;
				for (var index = 0; index < offsetCount; index++) {
					var offset = offsets[index];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, paneDrawInfo.c.get('size').gv(markIndex) + 4 + 4, color);
					if (offset !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		else if (paneDrawInfo.isMarkHighlighted(markIndex) && !nextOrPrevBrushed) {
			color = paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)['colorOverrideNone'];
			{
				var offsets1 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount1 = offsets1.length;
				for (var index1 = 0; index1 < offsetCount1; index1++) {
					var offset1 = offsets1[index1];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset1);
					{
						var drawBorder1 = paneDrawInfo.c.get('draw_border').gv(markIndex);
						var primitiveSize1 = paneDrawInfo.c.get('size').gv(markIndex) + 4 + 4 + (drawBorder1 ? 2 : 0);
						tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize1, color, 4);
					}
					if (offset1 !== 0) {
						tabContext.restore();
					}
				}
			}
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideNone'];
			{
				var offsets2 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount2 = offsets2.length;
				for (var index2 = 0; index2 < offsetCount2; index2++) {
					var offset2 = offsets2[index2];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset2);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, paneDrawInfo.c.get('size').gv(markIndex) + 4 + 4, color);
					if (offset2 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
		else {
			color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideNone'];
			{
				var offsets3 = paneDrawInfo.getMarkInstanceOffsets(markIndex);
				var offsetCount3 = offsets3.length;
				for (var index3 = 0; index3 < offsetCount3; index3++) {
					var offset3 = offsets3[index3];
					$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset3);
					tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, paneDrawInfo.c.get('size').gv(markIndex) + 4, color);
					if (offset3 !== 0) {
						tabContext.restore();
					}
				}
			}
		}
	};
	$tab_MarksRenderer.renderLineMarkPressedOverlayImage = function MarksRenderer$RenderLineMarkPressedOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var color = paneDrawInfo.getMarkColors(markIndex)['colorOverrideNone'];
		var x = paneDrawInfo.c.get('x').gv(markIndex);
		var y = paneDrawInfo.c.get('y').gv(markIndex);
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				tab.CanvasRenderer.renderFilledCircle(tabContext, 0 + x, 0 + y, paneDrawInfo.c.get('size').gv(markIndex) + 8, color);
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.shapeHasLayerContent = function MarksRenderer$ShapeHasLayerContent(shape, layer) {
		var retval = false;
		switch (shape) {
			case 'shapeIDCircle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledCircle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'border':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDUnscaledFilledCircle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'border':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDSquare': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledSquare': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'border':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDAsterisk': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDPlus': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledPlus': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDTimes': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledTimes': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDDiamond': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledDiamond': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDDownTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledDownTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDLeftTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledLeftTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDRightTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledRightTriangle': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledStar': {
				switch (layer) {
					case 'normalUnder':
					case 'normalOn':
					case 'selectedUnder':
					case 'hoverOverlay':
					case 'pressedOverlay': {
						retval = true;
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			default: {
				retval = true;
				break;
			}
		}
		return retval;
	};
	$tab_MarksRenderer.getShapeMarkSpriteSize = function MarksRenderer$GetShapeMarkSpriteSize(shape, layer, size) {
		var retval = 0;
		switch (shape) {
			case 'shapeIDCircle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 8);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledCircle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'border': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDUnscaledFilledCircle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'border': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDSquare': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledSquare': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'border': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDAsterisk': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 8);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDPlus': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledPlus': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 3);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 5);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDTimes': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledTimes': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDDiamond': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 8);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledDiamond': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 5);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 7);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 8);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDDownTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledDownTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDLeftTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledLeftTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDRightTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 6);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledRightTriangle': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 4);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 4);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			case 'shapeIDFilledStar': {
				switch (layer) {
					case 'normalUnder': {
						retval = Math.ceil(size + 6);
						break;
					}
					case 'normalOn': {
						retval = Math.ceil(size + 2);
						break;
					}
					case 'selectedUnder': {
						retval = Math.ceil(size + 6);
						break;
					}
					case 'hoverOverlay': {
						retval = Math.ceil(size + 10);
						break;
					}
					case 'pressedOverlay': {
						retval = Math.ceil(size + 14);
						break;
					}
					default: {
						break;
					}
				}
				break;
			}
			default: {
				break;
			}
		}
		return retval;
	};
	$tab_MarksRenderer.renderShapeHoverOverlayImage = function MarksRenderer$RenderShapeHoverOverlayImage(tabContext, paneDrawInfo, markIndex) {
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		var xPos = paneDrawInfo.c.get('x').gv(markIndex);
		var yPos = paneDrawInfo.c.get('y').gv(markIndex);
		if (paneDrawInfo.shouldStampThisShapeMark(markIndex)) {
			var size = paneDrawInfo.c.get('size').gv(markIndex);
			var canvasWidth = $tab_MarksRenderer.getShapeMarkSpriteSize(shape, 'normalOn', size) + 2;
			var canvasCenter = canvasWidth / 2;
			xPos = (xPos - canvasCenter + 0.5 << 0) + canvasCenter;
			yPos = (yPos - canvasCenter + 0.5 << 0) + canvasCenter;
		}
		switch (shape) {
			case 'shapeIDCircle': {
				$tab_MarksRenderer.renderShapeIDCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledCircle': {
				$tab_MarksRenderer.renderShapeIDFilledCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDUnscaledFilledCircle': {
				$tab_MarksRenderer.renderShapeIDUnscaledFilledCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDSquare': {
				$tab_MarksRenderer.renderShapeIDSquareHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledSquare': {
				$tab_MarksRenderer.renderShapeIDFilledSquareHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDAsterisk': {
				$tab_MarksRenderer.renderShapeIDAsteriskHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDPlus': {
				$tab_MarksRenderer.renderShapeIDPlusHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledPlus': {
				$tab_MarksRenderer.renderShapeIDFilledPlusHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDTimes': {
				$tab_MarksRenderer.renderShapeIDTimesHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledTimes': {
				$tab_MarksRenderer.renderShapeIDFilledTimesHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDDiamond': {
				$tab_MarksRenderer.renderShapeIDDiamondHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledDiamond': {
				$tab_MarksRenderer.renderShapeIDFilledDiamondHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDTriangle': {
				$tab_MarksRenderer.renderShapeIDTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDDownTriangle': {
				$tab_MarksRenderer.renderShapeIDDownTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledDownTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledDownTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDLeftTriangle': {
				$tab_MarksRenderer.renderShapeIDLeftTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledLeftTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledLeftTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDRightTriangle': {
				$tab_MarksRenderer.renderShapeIDRightTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledRightTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledRightTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledStar': {
				$tab_MarksRenderer.renderShapeIDFilledStarHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			default: {
				if (ss.isValue(tab.ApplicationModel.get_instance().get_shapeManager().getImageElement(shape))) {
					var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount = offsets.length;
					for (var index = 0; index < offsetCount; index++) {
						var offset = offsets[index];
						if (offset !== 0) {
							tabContext.save();
							tabContext.translate(offset, 0);
						}
						$tab_MarksRenderer.$renderCustomShape(tabContext, paneDrawInfo, markIndex, 'hoverOverlay', 'colorOverrideNone');
						if (offset !== 0) {
							tabContext.restore();
						}
					}
				}
				else {
					$tab_MarksRenderer.renderShapeIDCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				}
				break;
			}
		}
	};
	$tab_MarksRenderer.renderShapePressedOverlayImage = function MarksRenderer$RenderShapePressedOverlayImage(tabContext, paneDrawInfo, tupleId) {
		var markIndex = paneDrawInfo.getMarkIndexFromTupleId(tupleId);
		var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
		var xPos = paneDrawInfo.c.get('x').gv(markIndex);
		var yPos = paneDrawInfo.c.get('y').gv(markIndex);
		if (paneDrawInfo.shouldStampThisShapeMark(markIndex)) {
			var size = paneDrawInfo.c.get('size').gv(markIndex);
			var canvasWidth = $tab_MarksRenderer.getShapeMarkSpriteSize(shape, 'normalOn', size) + 2;
			var canvasCenter = canvasWidth / 2;
			xPos = (xPos - canvasCenter + 0.5 << 0) + canvasCenter;
			yPos = (yPos - canvasCenter + 0.5 << 0) + canvasCenter;
		}
		switch (shape) {
			case 'shapeIDCircle': {
				$tab_MarksRenderer.renderShapeIDCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledCircle': {
				$tab_MarksRenderer.renderShapeIDFilledCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDUnscaledFilledCircle': {
				$tab_MarksRenderer.renderShapeIDUnscaledFilledCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDSquare': {
				$tab_MarksRenderer.renderShapeIDSquarePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledSquare': {
				$tab_MarksRenderer.renderShapeIDFilledSquarePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDAsterisk': {
				$tab_MarksRenderer.renderShapeIDAsteriskPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDPlus': {
				$tab_MarksRenderer.renderShapeIDPlusPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledPlus': {
				$tab_MarksRenderer.renderShapeIDFilledPlusPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDTimes': {
				$tab_MarksRenderer.renderShapeIDTimesPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledTimes': {
				$tab_MarksRenderer.renderShapeIDFilledTimesPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDDiamond': {
				$tab_MarksRenderer.renderShapeIDDiamondPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledDiamond': {
				$tab_MarksRenderer.renderShapeIDFilledDiamondPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDTriangle': {
				$tab_MarksRenderer.renderShapeIDTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDDownTriangle': {
				$tab_MarksRenderer.renderShapeIDDownTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledDownTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledDownTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDLeftTriangle': {
				$tab_MarksRenderer.renderShapeIDLeftTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledLeftTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledLeftTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDRightTriangle': {
				$tab_MarksRenderer.renderShapeIDRightTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledRightTriangle': {
				$tab_MarksRenderer.renderShapeIDFilledRightTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			case 'shapeIDFilledStar': {
				$tab_MarksRenderer.renderShapeIDFilledStarPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				break;
			}
			default: {
				if (ss.isValue(tab.ApplicationModel.get_instance().get_shapeManager().getImageElement(shape))) {
					var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
					var offsetCount = offsets.length;
					for (var index = 0; index < offsetCount; index++) {
						var offset = offsets[index];
						if (offset !== 0) {
							tabContext.save();
							tabContext.translate(offset, 0);
						}
						$tab_MarksRenderer.$renderCustomShape(tabContext, paneDrawInfo, markIndex, 'pressedOverlay', 'colorOverrideNone');
						if (offset !== 0) {
							tabContext.restore();
						}
					}
				}
				else {
					$tab_MarksRenderer.renderShapeIDCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex);
				}
				break;
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDCircleHoverOverlayImage = function MarksRenderer$RenderShapeIDCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
					var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 + 2 + (drawBorder ? 2 : 0);
					tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 1);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDCirclePressedOverlayImage = function MarksRenderer$RenderShapeIDCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
					var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 + 3 + (drawBorder ? 2 : 0);
					tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 2);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledCircleHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
					var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 + (drawBorder ? 2 : 0);
					tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 1);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledCirclePressedOverlayImage = function MarksRenderer$RenderShapeIDFilledCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
					var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667 + 1 + (drawBorder ? 2 : 0);
					tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 2);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDUnscaledFilledCircleHoverOverlayImage = function MarksRenderer$RenderShapeIDUnscaledFilledCircleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
					var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) + (drawBorder ? 2 : 0);
					tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 1);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDUnscaledFilledCirclePressedOverlayImage = function MarksRenderer$RenderShapeIDUnscaledFilledCirclePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
					var primitiveSize = paneDrawInfo.c.get('size').gv(markIndex) + 1 + (drawBorder ? 2 : 0);
					tab.CanvasRenderer.renderCircle(tabContext, 0 + x, 0 + y, primitiveSize, color, 2);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDSquareHoverOverlayImage = function MarksRenderer$RenderShapeIDSquareHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				tab.CanvasRenderer.renderRectangle(tabContext, x + 0, y + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 3, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 3, color, 1);
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDSquarePressedOverlayImage = function MarksRenderer$RenderShapeIDSquarePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				tab.CanvasRenderer.renderRectangle(tabContext, x + 0, y + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 4, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 4, color, 2);
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledSquareHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledSquareHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				tab.CanvasRenderer.renderRectangle(tabContext, x + 0, y + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 + 1, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 + 1, color, 1);
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledSquarePressedOverlayImage = function MarksRenderer$RenderShapeIDFilledSquarePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				tab.CanvasRenderer.renderRectangle(tabContext, x + 0, y + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 + 2, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 + 2, color, 2);
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDAsteriskHoverOverlayImage = function MarksRenderer$RenderShapeIDAsteriskHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(36);
					var edgeWidth = (paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 + 2) / 2;
					var scaledEdgeWidth = 0.899999976158142 * edgeWidth;
					var quarterSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 + 6) / 4;
					var thickOutlineWidth = 2.5;
					var thinOutlineWidth = 1.5;
					points[0] = -thickOutlineWidth + x;
					points[1] = 0 + y;
					points[2] = -scaledEdgeWidth + x;
					points[3] = quarterSize - thickOutlineWidth + y;
					points[4] = thinOutlineWidth - scaledEdgeWidth + x;
					points[5] = quarterSize + y;
					points[6] = -thinOutlineWidth + x;
					points[7] = thickOutlineWidth + y;
					points[8] = -thinOutlineWidth + x;
					points[9] = edgeWidth + y;
					points[10] = thinOutlineWidth + x;
					points[11] = edgeWidth + y;
					points[12] = thinOutlineWidth + x;
					points[13] = thickOutlineWidth + y;
					points[14] = scaledEdgeWidth - thinOutlineWidth + x;
					points[15] = quarterSize + y;
					points[16] = scaledEdgeWidth + x;
					points[17] = quarterSize - thickOutlineWidth + y;
					points[18] = thickOutlineWidth + x;
					points[19] = 0 + y;
					points[20] = scaledEdgeWidth + x;
					points[21] = thickOutlineWidth - quarterSize + y;
					points[22] = scaledEdgeWidth - thinOutlineWidth + x;
					points[23] = -quarterSize + y;
					points[24] = thinOutlineWidth + x;
					points[25] = -thickOutlineWidth + y;
					points[26] = thinOutlineWidth + x;
					points[27] = -edgeWidth + y;
					points[28] = -thinOutlineWidth + x;
					points[29] = -edgeWidth + y;
					points[30] = -thinOutlineWidth + x;
					points[31] = -thickOutlineWidth + y;
					points[32] = thinOutlineWidth - scaledEdgeWidth + x;
					points[33] = -quarterSize + y;
					points[34] = -scaledEdgeWidth + x;
					points[35] = thickOutlineWidth - quarterSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDAsteriskPressedOverlayImage = function MarksRenderer$RenderShapeIDAsteriskPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(36);
					var edgeWidth = (paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 + 4) / 2;
					var scaledEdgeWidth = 0.899999976158142 * edgeWidth;
					var quarterSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 + 8) / 4;
					var thickOutlineWidth = 3;
					var thinOutlineWidth = 2;
					points[0] = -thickOutlineWidth + x;
					points[1] = 0 + y;
					points[2] = -scaledEdgeWidth + x;
					points[3] = quarterSize - thickOutlineWidth + y;
					points[4] = thinOutlineWidth - scaledEdgeWidth + x;
					points[5] = quarterSize + y;
					points[6] = -thinOutlineWidth + x;
					points[7] = thickOutlineWidth + y;
					points[8] = -thinOutlineWidth + x;
					points[9] = edgeWidth + y;
					points[10] = thinOutlineWidth + x;
					points[11] = edgeWidth + y;
					points[12] = thinOutlineWidth + x;
					points[13] = thickOutlineWidth + y;
					points[14] = scaledEdgeWidth - thinOutlineWidth + x;
					points[15] = quarterSize + y;
					points[16] = scaledEdgeWidth + x;
					points[17] = quarterSize - thickOutlineWidth + y;
					points[18] = thickOutlineWidth + x;
					points[19] = 0 + y;
					points[20] = scaledEdgeWidth + x;
					points[21] = thickOutlineWidth - quarterSize + y;
					points[22] = scaledEdgeWidth - thinOutlineWidth + x;
					points[23] = -quarterSize + y;
					points[24] = thinOutlineWidth + x;
					points[25] = -thickOutlineWidth + y;
					points[26] = thinOutlineWidth + x;
					points[27] = -edgeWidth + y;
					points[28] = -thinOutlineWidth + x;
					points[29] = -edgeWidth + y;
					points[30] = -thinOutlineWidth + x;
					points[31] = -thickOutlineWidth + y;
					points[32] = thinOutlineWidth - scaledEdgeWidth + x;
					points[33] = -quarterSize + y;
					points[34] = -scaledEdgeWidth + x;
					points[35] = thickOutlineWidth - quarterSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDPlusHoverOverlayImage = function MarksRenderer$RenderShapeIDPlusHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 + 2) / 2;
					var outlineWidth = 1.5;
					points[0] = -outlineWidth + x;
					points[1] = -halfSize + y;
					points[2] = -outlineWidth + x;
					points[3] = -outlineWidth + y;
					points[4] = -halfSize + x;
					points[5] = -outlineWidth + y;
					points[6] = -halfSize + x;
					points[7] = outlineWidth + y;
					points[8] = -outlineWidth + x;
					points[9] = outlineWidth + y;
					points[10] = -outlineWidth + x;
					points[11] = halfSize + y;
					points[12] = outlineWidth + x;
					points[13] = halfSize + y;
					points[14] = outlineWidth + x;
					points[15] = outlineWidth + y;
					points[16] = halfSize + x;
					points[17] = outlineWidth + y;
					points[18] = halfSize + x;
					points[19] = -outlineWidth + y;
					points[20] = outlineWidth + x;
					points[21] = -outlineWidth + y;
					points[22] = outlineWidth + x;
					points[23] = -halfSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDPlusPressedOverlayImage = function MarksRenderer$RenderShapeIDPlusPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 + 3) / 2;
					var outlineWidth = 2;
					points[0] = -outlineWidth + x;
					points[1] = -halfSize + y;
					points[2] = -outlineWidth + x;
					points[3] = -outlineWidth + y;
					points[4] = -halfSize + x;
					points[5] = -outlineWidth + y;
					points[6] = -halfSize + x;
					points[7] = outlineWidth + y;
					points[8] = -outlineWidth + x;
					points[9] = outlineWidth + y;
					points[10] = -outlineWidth + x;
					points[11] = halfSize + y;
					points[12] = outlineWidth + x;
					points[13] = halfSize + y;
					points[14] = outlineWidth + x;
					points[15] = outlineWidth + y;
					points[16] = halfSize + x;
					points[17] = outlineWidth + y;
					points[18] = halfSize + x;
					points[19] = -outlineWidth + y;
					points[20] = outlineWidth + x;
					points[21] = -outlineWidth + y;
					points[22] = outlineWidth + x;
					points[23] = -halfSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledPlusHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledPlusHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var sixSize = halfSize / 3;
					points[0] = -sixSize + x;
					points[1] = -halfSize + y;
					points[2] = -sixSize + x;
					points[3] = -sixSize + y;
					points[4] = -halfSize + x;
					points[5] = -sixSize + y;
					points[6] = -halfSize + x;
					points[7] = sixSize + y;
					points[8] = -sixSize + x;
					points[9] = sixSize + y;
					points[10] = -sixSize + x;
					points[11] = halfSize + y;
					points[12] = sixSize + x;
					points[13] = halfSize + y;
					points[14] = sixSize + x;
					points[15] = sixSize + y;
					points[16] = halfSize + x;
					points[17] = sixSize + y;
					points[18] = halfSize + x;
					points[19] = -sixSize + y;
					points[20] = sixSize + x;
					points[21] = -sixSize + y;
					points[22] = sixSize + x;
					points[23] = -halfSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledPlusPressedOverlayImage = function MarksRenderer$RenderShapeIDFilledPlusPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 + 1) / 2;
					var sixSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 + 3) / 6;
					points[0] = -sixSize + x;
					points[1] = -halfSize + y;
					points[2] = -sixSize + x;
					points[3] = -sixSize + y;
					points[4] = -halfSize + x;
					points[5] = -sixSize + y;
					points[6] = -halfSize + x;
					points[7] = sixSize + y;
					points[8] = -sixSize + x;
					points[9] = sixSize + y;
					points[10] = -sixSize + x;
					points[11] = halfSize + y;
					points[12] = sixSize + x;
					points[13] = halfSize + y;
					points[14] = sixSize + x;
					points[15] = sixSize + y;
					points[16] = halfSize + x;
					points[17] = sixSize + y;
					points[18] = halfSize + x;
					points[19] = -sixSize + y;
					points[20] = sixSize + x;
					points[21] = -sixSize + y;
					points[22] = sixSize + x;
					points[23] = -halfSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDTimesHoverOverlayImage = function MarksRenderer$RenderShapeIDTimesHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var edgeWidth = (paneDrawInfo.c.get('size').gv(markIndex) * 0.875 + 4) / 2;
					var outlineWidth = 2;
					points[0] = -edgeWidth + outlineWidth + x;
					points[1] = -edgeWidth + y;
					points[2] = -edgeWidth + x;
					points[3] = -edgeWidth + outlineWidth + y;
					points[4] = -outlineWidth + x;
					points[5] = 0 + y;
					points[6] = -edgeWidth + x;
					points[7] = edgeWidth - outlineWidth + y;
					points[8] = -edgeWidth + outlineWidth + x;
					points[9] = edgeWidth + y;
					points[10] = 0 + x;
					points[11] = outlineWidth + y;
					points[12] = edgeWidth - outlineWidth + x;
					points[13] = edgeWidth + y;
					points[14] = edgeWidth + x;
					points[15] = edgeWidth - outlineWidth + y;
					points[16] = outlineWidth + x;
					points[17] = 0 + y;
					points[18] = edgeWidth + x;
					points[19] = -edgeWidth + outlineWidth + y;
					points[20] = edgeWidth - outlineWidth + x;
					points[21] = -edgeWidth + y;
					points[22] = 0 + x;
					points[23] = -outlineWidth + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDTimesPressedOverlayImage = function MarksRenderer$RenderShapeIDTimesPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var edgeWidth = (paneDrawInfo.c.get('size').gv(markIndex) * 0.875 + 4) / 2;
					var outlineWidth = 3;
					points[0] = -edgeWidth + outlineWidth + x;
					points[1] = -edgeWidth + y;
					points[2] = -edgeWidth + x;
					points[3] = -edgeWidth + outlineWidth + y;
					points[4] = -outlineWidth + x;
					points[5] = 0 + y;
					points[6] = -edgeWidth + x;
					points[7] = edgeWidth - outlineWidth + y;
					points[8] = -edgeWidth + outlineWidth + x;
					points[9] = edgeWidth + y;
					points[10] = 0 + x;
					points[11] = outlineWidth + y;
					points[12] = edgeWidth - outlineWidth + x;
					points[13] = edgeWidth + y;
					points[14] = edgeWidth + x;
					points[15] = edgeWidth - outlineWidth + y;
					points[16] = outlineWidth + x;
					points[17] = 0 + y;
					points[18] = edgeWidth + x;
					points[19] = -edgeWidth + outlineWidth + y;
					points[20] = edgeWidth - outlineWidth + x;
					points[21] = -edgeWidth + y;
					points[22] = 0 + x;
					points[23] = -outlineWidth + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledTimesHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledTimesHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var quarterSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 4;
					points[0] = -quarterSize + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = -quarterSize + y;
					points[4] = -quarterSize + x;
					points[5] = 0 + y;
					points[6] = -halfSize + x;
					points[7] = quarterSize + y;
					points[8] = -quarterSize + x;
					points[9] = halfSize + y;
					points[10] = 0 + x;
					points[11] = quarterSize + y;
					points[12] = quarterSize + x;
					points[13] = halfSize + y;
					points[14] = halfSize + x;
					points[15] = quarterSize + y;
					points[16] = quarterSize + x;
					points[17] = 0 + y;
					points[18] = halfSize + x;
					points[19] = -quarterSize + y;
					points[20] = quarterSize + x;
					points[21] = -halfSize + y;
					points[22] = 0 + x;
					points[23] = -quarterSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledTimesPressedOverlayImage = function MarksRenderer$RenderShapeIDFilledTimesPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(24);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var quarterSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 4;
					points[0] = -quarterSize + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = -quarterSize + y;
					points[4] = -quarterSize + x;
					points[5] = 0 + y;
					points[6] = -halfSize + x;
					points[7] = quarterSize + y;
					points[8] = -quarterSize + x;
					points[9] = halfSize + y;
					points[10] = 0 + x;
					points[11] = quarterSize + y;
					points[12] = quarterSize + x;
					points[13] = halfSize + y;
					points[14] = halfSize + x;
					points[15] = quarterSize + y;
					points[16] = quarterSize + x;
					points[17] = 0 + y;
					points[18] = halfSize + x;
					points[19] = -quarterSize + y;
					points[20] = quarterSize + x;
					points[21] = -halfSize + y;
					points[22] = 0 + x;
					points[23] = -quarterSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDDiamondHoverOverlayImage = function MarksRenderer$RenderShapeIDDiamondHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(8);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 + 3) / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = 0 + y;
					points[4] = 0 + x;
					points[5] = halfSize + y;
					points[6] = halfSize + x;
					points[7] = 0 + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDDiamondPressedOverlayImage = function MarksRenderer$RenderShapeIDDiamondPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(8);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 + 4) / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = 0 + y;
					points[4] = 0 + x;
					points[5] = halfSize + y;
					points[6] = halfSize + x;
					points[7] = 0 + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledDiamondHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledDiamondHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(8);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = 0 + y;
					points[4] = 0 + x;
					points[5] = halfSize + y;
					points[6] = halfSize + x;
					points[7] = 0 + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledDiamondPressedOverlayImage = function MarksRenderer$RenderShapeIDFilledDiamondPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(8);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 + 2) / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = 0 + y;
					points[4] = 0 + x;
					points[5] = halfSize + y;
					points[6] = halfSize + x;
					points[7] = 0 + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 3) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 6) / 2;
					points[0] = 0 + x;
					points[1] = -pointDistance + y;
					points[2] = -sideDistance + x;
					points[3] = sideDistance + y;
					points[4] = sideDistance + x;
					points[5] = sideDistance + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 4) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 8) / 2;
					points[0] = 0 + x;
					points[1] = -pointDistance + y;
					points[2] = -sideDistance + x;
					points[3] = sideDistance + y;
					points[4] = sideDistance + x;
					points[5] = sideDistance + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = halfSize + y;
					points[4] = halfSize + x;
					points[5] = halfSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDFilledTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 + 1) / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = halfSize + y;
					points[4] = halfSize + x;
					points[5] = halfSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDDownTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDDownTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 2.5) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 6) / 2;
					points[0] = 0 + x;
					points[1] = pointDistance + y;
					points[2] = -sideDistance + x;
					points[3] = -sideDistance + y;
					points[4] = sideDistance + x;
					points[5] = -sideDistance + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDDownTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDDownTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 4) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 8) / 2;
					points[0] = 0 + x;
					points[1] = pointDistance + y;
					points[2] = -sideDistance + x;
					points[3] = -sideDistance + y;
					points[4] = sideDistance + x;
					points[5] = -sideDistance + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledDownTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledDownTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					points[0] = 0 + x;
					points[1] = halfSize + y;
					points[2] = -halfSize + x;
					points[3] = -halfSize + y;
					points[4] = halfSize + x;
					points[5] = -halfSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledDownTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDFilledDownTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 + 1) / 2;
					points[0] = 0 + x;
					points[1] = halfSize + y;
					points[2] = -halfSize + x;
					points[3] = -halfSize + y;
					points[4] = halfSize + x;
					points[5] = -halfSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDLeftTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDLeftTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 3) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 6) / 2;
					points[0] = -pointDistance + x;
					points[1] = 0 + y;
					points[2] = sideDistance + x;
					points[3] = -sideDistance + y;
					points[4] = sideDistance + x;
					points[5] = sideDistance + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDLeftTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDLeftTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 4) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 8) / 2;
					points[0] = -pointDistance + x;
					points[1] = 0 + y;
					points[2] = sideDistance + x;
					points[3] = -sideDistance + y;
					points[4] = sideDistance + x;
					points[5] = sideDistance + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledLeftTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledLeftTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					points[0] = -halfSize + x;
					points[1] = 0 + y;
					points[2] = halfSize + x;
					points[3] = -halfSize + y;
					points[4] = halfSize + x;
					points[5] = halfSize + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledLeftTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDFilledLeftTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 + 1) / 2;
					points[0] = -halfSize + x;
					points[1] = 0 + y;
					points[2] = halfSize + x;
					points[3] = -halfSize + y;
					points[4] = halfSize + x;
					points[5] = halfSize + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDRightTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDRightTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 3) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 6) / 2;
					points[0] = -sideDistance + x;
					points[1] = -sideDistance + y;
					points[2] = -sideDistance + x;
					points[3] = sideDistance + y;
					points[4] = pointDistance + x;
					points[5] = 0 + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDRightTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDRightTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var sideDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 4) / 2;
					var pointDistance = (paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 + 8) / 2;
					points[0] = -sideDistance + x;
					points[1] = -sideDistance + y;
					points[2] = -sideDistance + x;
					points[3] = sideDistance + y;
					points[4] = pointDistance + x;
					points[5] = 0 + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledRightTriangleHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledRightTriangleHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					points[0] = -halfSize + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = halfSize + y;
					points[4] = halfSize + x;
					points[5] = 0 + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledRightTrianglePressedOverlayImage = function MarksRenderer$RenderShapeIDFilledRightTrianglePressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(6);
					var halfSize = (paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 + 1) / 2;
					points[0] = -halfSize + x;
					points[1] = -halfSize + y;
					points[2] = -halfSize + x;
					points[3] = halfSize + y;
					points[4] = halfSize + x;
					points[5] = 0 + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledStarHoverOverlayImage = function MarksRenderer$RenderShapeIDFilledStarHoverOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(20);
					var computedSize = paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667 + 2;
					var computedVal = computedSize * 0.3877;
					var halfSize = computedSize / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + computedSize * 0.0246 + y;
					points[2] = -halfSize + computedSize * 0.3817 + x;
					points[3] = -halfSize + computedVal + y;
					points[4] = -halfSize + x;
					points[5] = -halfSize + computedVal + y;
					points[6] = -halfSize + computedSize * 0.3088 + x;
					points[7] = -halfSize + computedSize * 0.612 + y;
					points[8] = -halfSize + computedSize * 0.1909 + x;
					points[9] = -halfSize + computedSize * 0.9751 + y;
					points[10] = 0 + x;
					points[11] = -halfSize + computedSize * 0.7507 + y;
					points[12] = -halfSize + computedSize * 0.8085 + x;
					points[13] = -halfSize + computedSize * 0.9751 + y;
					points[14] = -halfSize + computedSize * 0.6905 + x;
					points[15] = -halfSize + computedSize * 0.612 + y;
					points[16] = halfSize + x;
					points[17] = -halfSize + computedVal + y;
					points[18] = -halfSize + computedSize * 0.6176 + x;
					points[19] = -halfSize + computedVal + y;
					tabContext.set_lineWidth(1);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.renderShapeIDFilledStarPressedOverlayImage = function MarksRenderer$RenderShapeIDFilledStarPressedOverlayImage(tabContext, paneDrawInfo, xPos, yPos, markIndex) {
		var color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideNone'];
		var x = xPos;
		var y = yPos;
		{
			var offsets = paneDrawInfo.getMarkInstanceOffsets(markIndex);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				$tab_MarksRenderer.$saveAndTranslateIfOffset(tabContext, offset);
				{
					var points = new Array(20);
					var computedSize = paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667 + 4;
					var computedVal = computedSize * 0.3877;
					var halfSize = computedSize / 2;
					points[0] = 0 + x;
					points[1] = -halfSize + computedSize * 0.0246 + y;
					points[2] = -halfSize + computedSize * 0.3817 + x;
					points[3] = -halfSize + computedVal + y;
					points[4] = -halfSize + x;
					points[5] = -halfSize + computedVal + y;
					points[6] = -halfSize + computedSize * 0.3088 + x;
					points[7] = -halfSize + computedSize * 0.612 + y;
					points[8] = -halfSize + computedSize * 0.1909 + x;
					points[9] = -halfSize + computedSize * 0.9751 + y;
					points[10] = 0 + x;
					points[11] = -halfSize + computedSize * 0.7507 + y;
					points[12] = -halfSize + computedSize * 0.8085 + x;
					points[13] = -halfSize + computedSize * 0.9751 + y;
					points[14] = -halfSize + computedSize * 0.6905 + x;
					points[15] = -halfSize + computedSize * 0.612 + y;
					points[16] = halfSize + x;
					points[17] = -halfSize + computedVal + y;
					points[18] = -halfSize + computedSize * 0.6176 + x;
					points[19] = -halfSize + computedVal + y;
					tabContext.set_lineWidth(2);
					tabContext.set_strokeStyle(color);
					tabContext.set_lineJoin('miter');
					tab.CanvasRenderer.strokePath(tabContext, points, true, true);
				}
				if (offset !== 0) {
					tabContext.restore();
				}
			}
		}
	};
	$tab_MarksRenderer.get_$multipolyLineSizeOffset = function MarksRenderer$get_MultipolyLineSizeOffset() {
		return (BrowserSupport.BrowserSupport.IsChrome() ? $tab_MarksRenderer.$chromeBorderThicknessOffset : 0);
	};
	$tab_MarksRenderer.$saveAndTranslateIfOffset = function MarksRenderer$SaveAndTranslateIfOffset(context, xOffset) {
		if (!tab.DoubleUtil.isApproximatelyEqual(xOffset, 0)) {
			context.save();
			context.translate(xOffset, 0);
		}
	};
	$tab_MarksRenderer.$boundingBoxOfBoundFilledBar = function MarksRenderer$BoundingBoxOfBoundFilledBar(paneDrawInfo, bbox, topVal, leftVal, bottomVal, rightVal) {
		var top = Math.min(topVal, bottomVal);
		var bottom = Math.max(topVal, bottomVal);
		var left = Math.min(leftVal, rightVal);
		var right = Math.max(leftVal, rightVal);
		var yAndHeight = $tab_MarksRenderer.roundStartAndExtent(top, bottom - top, paneDrawInfo.minBarHeight);
		var xAndWidth = $tab_MarksRenderer.roundStartAndExtent(left, right - left, paneDrawInfo.minBarWidth);
		tab.RectXYUtil.unionInPlace$1(bbox, xAndWidth.item1, yAndHeight.item1, Math.floor(xAndWidth.item2), Math.floor(yAndHeight.item2));
	};
	$tab_MarksRenderer.$drawBarInSprite = function MarksRenderer$DrawBarInSprite(context, paneDrawInfo, markIndex, left, right, top, bottom, color, square, strokeWidth) {
		var drawBorder = paneDrawInfo.c.get('draw_border').gv(markIndex);
		var borderSize = (drawBorder ? 1 : 0);
		var barOffset = ((paneDrawInfo.markType === 'text') ? 0 : 1);
		var x = Math.min(left, right);
		var y = Math.min(top, bottom);
		var width = Math.abs(right - left);
		var height = Math.abs(bottom - top);
		var yAndHeight = $tab_MarksRenderer.roundStartAndExtent(y, height, paneDrawInfo.minBarHeight);
		var xAndWidth = $tab_MarksRenderer.roundStartAndExtent(x, width, paneDrawInfo.minBarWidth);
		x = xAndWidth.item1 - barOffset;
		y = yAndHeight.item1 - barOffset;
		width = xAndWidth.item2 + strokeWidth + borderSize + barOffset - 1;
		height = yAndHeight.item2 + strokeWidth + borderSize + barOffset - 1;
		if (square) {
			width = height = Math.min(width, height);
		}
		if (!paneDrawInfo.isWrappedDomain) {
			var paneRect = paneDrawInfo.getUserPaneRectByMark(markIndex);
			if (!tab.RectXYUtil.intersectsWith$1(paneRect, Math.floor(x), Math.floor(y), Math.floor(width), Math.floor(height))) {
				return;
			}
			if (paneRect.x >= x) {
				var xPos = paneRect.x + strokeWidth - 1;
				width -= xPos - x;
				x = xPos;
			}
			if (paneRect.x + paneRect.w <= x + width) {
				width = paneRect.x + paneRect.w - x - 1;
			}
			if (paneRect.y >= y) {
				var yPos = paneRect.y + strokeWidth - 1;
				height -= yPos - y;
				y = yPos;
			}
			if (paneRect.y + paneRect.h <= y + height) {
				height = paneRect.y + paneRect.h - y - 1;
			}
		}
		context.set_lineJoin('miter');
		$tab_MarksRenderer.$renderBarOutline(context, x, y, width, height, color['colorOverrideNone'], strokeWidth, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
	};
	$tab_MarksRenderer.bBoxGeometry = function MarksRenderer$BBoxGeometry(oldRect, transform, padding, geometryPM) {
		var bounds = { minX: Number.POSITIVE_INFINITY, minY: Number.POSITIVE_INFINITY, maxX: Number.NEGATIVE_INFINITY, maxY: Number.NEGATIVE_INFINITY };
		switch (geometryPM.geometryType) {
			case 'multiPolygon': {
				tab.CanvasRenderer.boundsMultipolygon(geometryPM.multiPolygon, bounds);
				break;
			}
			case 'multiLineString': {
				tab.CanvasRenderer.boundsMultilineString(geometryPM.multiLine, bounds);
				break;
			}
			case 'multiPoint': {
				tab.CanvasRenderer.boundsCoordinateArray(geometryPM.multiPoint.pointsF, bounds);
				break;
			}
			default: {
				return;
			}
		}
		var pixelBounds = transform.transformBounds(bounds);
		tab.DoubleRectXYUtil.outsetRectInPlace(pixelBounds, padding, padding);
		tab.RectXYUtil.unionInPlace(oldRect, tab.DoubleRectXYUtil.toEncompassingRectXY(pixelBounds));
	};
	$tab_MarksRenderer.$getShapeColorForLayer = function MarksRenderer$GetShapeColorForLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
		switch (layer) {
			case 'highlightedUnder':
			case 'normalUnder': {
				return paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
			}
			case 'selectedOn':
			case 'highlightedOn':
			case 'normalOn': {
				return paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode];
			}
			case 'border': {
				return paneDrawInfo.getBorderColors(markIndex)[colorOverrideMode];
			}
			case 'selectedUnder':
			case 'hoverOverlay':
			case 'pressedOverlay': {
				return paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode];
			}
		}
		return $tab_MarksRenderer.$white;
	};
	$tab_MarksRenderer.$getClipRect = function MarksRenderer$GetClipRect(cellClipCase, x, y, width, height) {
		var BigVal = 100000;
		switch (cellClipCase) {
			case 0: {
				return { x: ss.Int32.trunc(x), y: ss.Int32.trunc(y), w: ss.Int32.trunc(width), h: ss.Int32.trunc(height) };
			}
			case 1: {
				y = -100000;
				height = 200000;
				break;
			}
			case 2: {
				x = -100000;
				width = 200000;
				break;
			}
		}
		var yAndHeight = $tab_MarksRenderer.roundStartAndExtent(y, height, 0);
		var xAndWidth = $tab_MarksRenderer.roundStartAndExtent(x, width, 0);
		return { x: ss.Int32.trunc(xAndWidth.item1), y: ss.Int32.trunc(yAndHeight.item1), w: ss.Int32.trunc(xAndWidth.item2), h: ss.Int32.trunc(yAndHeight.item2) };
	};
	$tab_MarksRenderer.$getLineEdgePoints = function MarksRenderer$GetLineEdgePoints(x0, y0, width0, x1, y1, width1) {
		var angle = Math.atan2(y1 - y0, x1 - x0);
		var cosAngle = Math.cos(angle);
		var sinAngle = Math.sin(angle);
		width0 /= 2;
		width1 /= 2;
		var width0SinAngle = width0 * sinAngle;
		var width1SinAngle = width1 * sinAngle;
		var width0CosAngle = width0 * cosAngle;
		var width1CosAngle = width1 * cosAngle;
		var points = new Array(8);
		points[0] = x0 + width0SinAngle;
		points[1] = y0 - width0CosAngle;
		points[2] = x1 + width1SinAngle;
		points[3] = y1 - width1CosAngle;
		points[4] = x1 - width1SinAngle;
		points[5] = y1 + width1CosAngle;
		points[6] = x0 - width0SinAngle;
		points[7] = y0 + width0CosAngle;
		return points;
	};
	$tab_MarksRenderer.$lineEdgeContains = function MarksRenderer$LineEdgeContains(hitX, hitY, x0, y0, width0, x1, y1, width1) {
		var points = $tab_MarksRenderer.$getLineEdgePoints(x0, y0, width0, x1, y1, width1);
		return $tab_GeometryUtil.isPointInPoly(points, { x: hitX, y: hitY }, null);
	};
	$tab_MarksRenderer.$boundLineEdgeInPlace = function MarksRenderer$BoundLineEdgeInPlace(bound, x0, y0, width0, x1, y1, width1) {
		var points = $tab_MarksRenderer.$getLineEdgePoints(x0, y0, width0, x1, y1, width1);
		var minx = points[0];
		var maxx = minx;
		var miny = points[1];
		var maxy = miny;
		var len = points.length;
		for (var i = 0; i < len; i = i + 2) {
			minx = Math.min(minx, points[i]);
			maxx = Math.max(maxx, points[i]);
			miny = Math.min(miny, points[i + 1]);
			maxy = Math.max(maxy, points[i + 1]);
		}
		tab.RectXYUtil.unionInPlace(bound, { x: minx << 0, y: miny << 0, w: (maxx - minx << 0) + 1, h: (maxy - miny << 0) + 1 });
	};
	$tab_MarksRenderer.$boundWedge = function MarksRenderer$BoundWedge(x, y, radius, theta1, theta2) {
		if (theta1 > theta2) {
			var temp = theta1;
			theta1 = theta2;
			theta2 = temp;
		}
		if (theta2 - theta1 >= 1) {
			var d = Math.ceil(2 * radius);
			return { x: Math.floor(x - radius), y: Math.floor(y - radius), w: d, h: d };
		}
		var startAngle = tab.CanvasRenderer.toCanvasAngle(theta1);
		var endAngle = tab.CanvasRenderer.toCanvasAngle(theta2);
		var $t1 = [];
		$t1.push({ x: x, y: y });
		$t1.push({ x: x + radius * Math.cos(startAngle), y: y + radius * Math.sin(startAngle) });
		$t1.push({ x: x + radius * Math.cos(endAngle), y: y + radius * Math.sin(endAngle) });
		var points = $t1;
		startAngle = $tab_GeometryUtil.normalizeAngle(startAngle);
		endAngle = $tab_GeometryUtil.normalizeAngle(endAngle);
		if ($tab_GeometryUtil.isInBetweenAngles(0, startAngle, endAngle)) {
			points.push({ x: x + radius, y: y });
		}
		if ($tab_GeometryUtil.isInBetweenAngles(tab.CanvasRenderer.halfPI, startAngle, endAngle)) {
			points.push({ x: x, y: y + radius });
		}
		if ($tab_GeometryUtil.isInBetweenAngles(tab.CanvasRenderer.onePI, startAngle, endAngle)) {
			points.push({ x: x - radius, y: y });
		}
		if ($tab_GeometryUtil.isInBetweenAngles(tab.CanvasRenderer.oneAndHalfPI, startAngle, endAngle)) {
			points.push({ x: x, y: y - radius });
		}
		var minX = Number.POSITIVE_INFINITY;
		var minY = Number.POSITIVE_INFINITY;
		var maxX = Number.NEGATIVE_INFINITY;
		var maxY = Number.NEGATIVE_INFINITY;
		for (var $t2 = 0; $t2 < points.length; $t2++) {
			var point = points[$t2];
			minX = Math.min(minX, point.x);
			minY = Math.min(minY, point.y);
			maxX = Math.max(maxX, point.x);
			maxY = Math.max(maxY, point.y);
		}
		return tab.RectXYUtil.rectXYFromMinAndMax(minX, minY, maxX, maxY);
	};
	$tab_MarksRenderer.roundStartAndExtent = function MarksRenderer$RoundStartAndExtent(start, extent, minSize) {
		var end = Math.round(start + extent);
		start = Math.round(start);
		extent = Math.max(Math.abs(end - start), minSize);
		return { item1: start, item2: extent };
	};
	$tab_MarksRenderer.$isPointInExpandedRectHelperF = function MarksRenderer$IsPointInExpandedRectHelperF(top, left, height, width, expandHeight, expandWidth, minHeight, minWidth, x, y) {
		if (height < 0) {
			top += height;
			height = Math.abs(height);
		}
		if (width < 0) {
			left += width;
			width = Math.abs(width);
		}
		var yAndHeight = $tab_MarksRenderer.roundStartAndExtent(top - expandHeight, height + expandHeight + expandHeight, minHeight + expandHeight + expandHeight);
		var xAndWidth = $tab_MarksRenderer.roundStartAndExtent(left - expandWidth, width + expandWidth + expandWidth, minWidth + expandWidth + expandWidth);
		var rect = { x: ss.Int32.trunc(xAndWidth.item1), y: ss.Int32.trunc(yAndHeight.item1), w: ss.Int32.trunc(xAndWidth.item2), h: ss.Int32.trunc(yAndHeight.item2) };
		if (tab.RectXYUtil.inRectPointF(rect, { x: x, y: y })) {
			return true;
		}
		return false;
	};
	$tab_MarksRenderer.$renderCustomShape = function MarksRenderer$RenderCustomShape(tabContext, paneDrawInfo, markIndex, layer, colorOverrideMode) {
		var shapeId = paneDrawInfo.c.get('shape_id').gv(markIndex);
		if (ss.isValue(shapeId)) {
			var shapeManager = tab.ApplicationModel.get_instance().get_shapeManager();
			var image = shapeManager.getImageElement(shapeId);
			if (!ss.isValue(image)) {
				tab.CanvasRenderer.renderCircle(tabContext, paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), $tab_MarksRenderer.$getShapeColorForLayer(paneDrawInfo, markIndex, layer, colorOverrideMode), 2);
				return;
			}
			if (!image.complete) {
				return;
			}
			var constantColor = paneDrawInfo.hasConstantColor;
			var originalSize = paneDrawInfo.c.get('size').gv(markIndex);
			var left = paneDrawInfo.c.get('left').gv(markIndex);
			var top = paneDrawInfo.c.get('top').gv(markIndex);
			var width;
			var height;
			if (image.naturalWidth > image.naturalHeight) {
				var scaleFactor = image.naturalWidth / image.naturalHeight;
				width = originalSize;
				height = originalSize / scaleFactor;
				top += Math.round((originalSize - height) / 2);
			}
			else {
				var scaleFactor1 = image.naturalHeight / image.naturalWidth;
				width = originalSize / scaleFactor1;
				height = originalSize;
				left += Math.round((originalSize - width) / 2);
			}
			width = Math.round(width);
			height = Math.round(height);
			var colorModel = $tab_MarksRenderer.$getCustomShapeColorModel(paneDrawInfo, markIndex, layer, colorOverrideMode);
			layer = ((layer === 'normalOn' && colorOverrideMode === 'colorOverrideOpaque') ? 'selectedOn' : layer);
			var canvasCacheKey = tab.ShapeManager.getCacheKey$1(shapeId, layer, colorOverrideMode, colorModel.toString(), width, height);
			var cachedCanvas = shapeManager.getCachedCanvas(canvasCacheKey);
			if (ss.isNullOrUndefined(cachedCanvas)) {
				var cacheableCanvasGenerator = null;
				switch (layer) {
					case 'normalUnder':
					case 'highlightedUnder':
					case 'selectedUnder': {
						cacheableCanvasGenerator = function() {
							return $tab_ShapeUtil.generateSelectedUnderCustomShape(image, colorModel, tab.ShapeManager.selectionBorderSize, width, height);
						};
						break;
					}
					case 'normalOn': {
						if (constantColor) {
							if (colorOverrideMode === 'colorOverrideFog') {
								cacheableCanvasGenerator = function() {
									return $tab_ShapeUtil.applyFoggingToImage(image, paneDrawInfo.foggedBackgroundColor, paneDrawInfo.fogBlendFactor, width, height);
								};
							}
						}
						else {
							cacheableCanvasGenerator = function() {
								return $tab_ShapeUtil.colorTransformImage(image, colorModel, width, height);
							};
						}
						break;
					}
					case 'highlightedOn': {
						if (!constantColor) {
							cacheableCanvasGenerator = function() {
								return $tab_ShapeUtil.colorTransformImage(image, colorModel, width, height);
							};
						}
						break;
					}
					case 'selectedOn': {
						if (!constantColor) {
							cacheableCanvasGenerator = function() {
								colorModel = tab.ColorModel.fromColorModelPlusAlpha(colorModel, 255);
								return $tab_ShapeUtil.colorTransformImage(image, colorModel, width, height);
							};
						}
						break;
					}
					case 'hoverOverlay': {
						cacheableCanvasGenerator = function() {
							return $tab_ShapeUtil.generateOverlayForShape(image, colorModel, tab.ShapeManager.selectionBorderSize, width, height);
						};
						break;
					}
					case 'pressedOverlay': {
						cacheableCanvasGenerator = function() {
							return $tab_ShapeUtil.generateOverlayForShape(image, colorModel, tab.ShapeManager.selectionBorderSize * 2, width, height);
						};
						break;
					}
				}
				if (!ss.isValue(cacheableCanvasGenerator)) {
					cacheableCanvasGenerator = function() {
						return $tab_ShapeUtil.generateCanvasAndPrescaleAsNeeded(image, width, height);
					};
				}
				cachedCanvas = shapeManager.generateCachedCanvas(canvasCacheKey, cacheableCanvasGenerator);
			}
			if (ss.isValue(cachedCanvas)) {
				switch (layer) {
					case 'normalUnder':
					case 'highlightedUnder':
					case 'selectedUnder':
					case 'hoverOverlay': {
						tabContext.drawImage3(cachedCanvas, left - tab.ShapeManager.selectionBorderSize, top - tab.ShapeManager.selectionBorderSize, cachedCanvas.width, cachedCanvas.height);
						break;
					}
					case 'pressedOverlay': {
						tabContext.drawImage3(cachedCanvas, left - tab.ShapeManager.selectionBorderSize * 2, top - tab.ShapeManager.selectionBorderSize * 2, cachedCanvas.width, cachedCanvas.height);
						break;
					}
					case 'normalOn': {
						tabContext.set_alpha(colorModel.get_a());
						tabContext.drawImage3(cachedCanvas, left, top, width, height);
						break;
					}
					default: {
						tabContext.drawImage3(cachedCanvas, left, top, width, height);
						break;
					}
				}
			}
			else {
				tab.Log.get(tabContext).warn('Shape was not found, and could not be drawn!', []);
			}
		}
	};
	$tab_MarksRenderer.$getCustomShapeColorModel = function MarksRenderer$GetCustomShapeColorModel(paneDrawInfo, markIndex, layer, colorOverrideMode) {
		var color = $tab_MarksRenderer.$getShapeColorForLayer(paneDrawInfo, markIndex, layer, colorOverrideMode);
		return tab.ColorModel.fromColorCode(color);
	};
	$tab_MarksRenderer.$renderBarOutline = function MarksRenderer$RenderBarOutline(context, x, y, width, height, color, strokeWidth, minWidth, minHeight, isSquare) {
		context.set_lineWidth(strokeWidth);
		context.set_strokeStyle(color);
		var pixelAdjustment = ((Math.round(strokeWidth) % 2 === 0) ? 0 : 0.5);
		var yAndHeight = $tab_MarksRenderer.roundStartAndExtent(y, height, minHeight);
		var xAndWidth = $tab_MarksRenderer.roundStartAndExtent(x, width, minWidth);
		if (isSquare) {
			var minItem2 = Math.min(xAndWidth.item2, yAndHeight.item2);
			xAndWidth = { item1: xAndWidth.item1, item2: minItem2 };
			yAndHeight = { item1: yAndHeight.item1, item2: minItem2 };
		}
		context.strokeRect(xAndWidth.item1 + pixelAdjustment, yAndHeight.item1 + pixelAdjustment, xAndWidth.item2, yAndHeight.item2);
	};
	$tab_MarksRenderer.$renderFilledBar = function MarksRenderer$RenderFilledBar(context, x, y, width, height, color, minWidth, minHeight, isSquare) {
		context.set_shapeFillStyle(color);
		{
			var yAndHeight = $tab_MarksRenderer.roundStartAndExtent(y, height, minHeight);
			y = yAndHeight.item1;
			height = yAndHeight.item2;
			var xAndWidth = $tab_MarksRenderer.roundStartAndExtent(x, width, minWidth);
			x = xAndWidth.item1;
			width = xAndWidth.item2;
		}
		if (isSquare) {
			width = height = Math.min(width, height);
		}
		context.fillRect(x, y, width, height);
	};
	global.tab.MarksRenderer = $tab_MarksRenderer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.NodeType
	var $tab_NodeType = function() {
	};
	$tab_NodeType.__typeName = 'tab.NodeType';
	global.tab.NodeType = $tab_NodeType;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.PaneDrawInfo
	var $tab_PaneDrawInfo = function() {
		this.hasPixelGeometry = false;
		this.worldWidth = 0;
		this.sceneInfo = null;
		this.c = new Map();
		this.$labelColumnIterators = null;
		this.$textRunColumnIterators = null;
		this.$textStyleColumnIterators = null;
		this.domainExtents = null;
		this.$paneFlags = 0;
		this.paneMarks = null;
		this.pdMarksKey = null;
		this.tupleToIndexMap = new Map();
		this.$dirtyMarks = null;
		this.$markState = null;
		this.markInstanceOffsets = null;
		this.markLabelInstanceOffsets = null;
		this.$marksWithMarker = null;
		this.$filteredMarks = new Set();
		this.$stampAllShapeMarks = false;
		this.shapeMarkStampingDecision = null;
		this.$discreteColorTable = null;
		this.$lineDrawState = null;
		this.truncateLabelToCell = false;
		this.markCount = 0;
		this.markType = null;
		this.showLabels = false;
		this.labelMode = null;
		this.fogBlendFactor = 0;
		this.foggedBackgroundColor = null;
		this.forceOpaqueColors = false;
		this.drawBorder = false;
		this.isWrappedDomain = false;
		this.paneColumn = 0;
		this.paneRow = 0;
		this.$1$PaneIndexField = 0;
		this.paneRect = null;
		this.clipCase = 0;
		this.globalAlpha = 0;
		this.paneDrawInfoKey = null;
		this.userPaneCount = 0;
		this.hasUserPanes = false;
		this.customShapes = null;
		this.geometries = null;
		this.scaleMarksInX = false;
		this.scaleMarksInY = false;
		this.useCellClipForSelection = false;
		this.paneHasCellsX = false;
		this.paneHasCellsY = false;
		this.mapExtents = null;
		this.hasConstantColor = false;
		this.skipClipping = false;
		this.markWorldOffsets = null;
		this.markLabelWorldOffsets = null;
		this.$userPaneInfo = null;
		this.minBarHeight = 0;
		this.lineInterpolation = null;
		this.minBarWidth = 0;
		if (ss.isNullOrUndefined($tab_PaneDrawInfo.textAngleInRad)) {
			$tab_PaneDrawInfo.textAngleInRad = new Map();
			$tab_PaneDrawInfo.textAngleInRad.set(1, 0);
			$tab_PaneDrawInfo.textAngleInRad.set(2, -Math.PI * 0.5);
			$tab_PaneDrawInfo.textAngleInRad.set(3, Math.PI * 0.5);
		}
		if (ss.isNullOrUndefined($tab_PaneDrawInfo.$floatColumnsMappedToInt)) {
			$tab_PaneDrawInfo.$floatColumnsMappedToInt = new Map();
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('theta', { x: 0, y: 1 });
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('theta1', { x: 0, y: 1 });
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('size', { x: 0, y: 4096 });
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('text_run_x', { x: 0, y: 4096 });
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('text_run_direction_x', { x: 0, y: 4096 });
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('text_run_y', { x: 0, y: 4096 });
			$tab_PaneDrawInfo.$floatColumnsMappedToInt.set('text_run_direction_y', { x: 0, y: 4096 });
			for (var $t1 = 0; $t1 < $tab_PaneDrawInfo.$columnsToConvertToXDomainCoords.length; $t1++) {
				var xColName = $tab_PaneDrawInfo.$columnsToConvertToXDomainCoords[$t1];
				$tab_PaneDrawInfo.$floatColumnsMappedToInt.set(xColName, { x: 0, y: 0 });
			}
			for (var $t2 = 0; $t2 < $tab_PaneDrawInfo.$columnsToConvertToYDomainCoords.length; $t2++) {
				var yColName = $tab_PaneDrawInfo.$columnsToConvertToYDomainCoords[$t2];
				$tab_PaneDrawInfo.$floatColumnsMappedToInt.set(yColName, { x: 0, y: 0 });
			}
		}
		if (ss.isNullOrUndefined($tab_PaneDrawInfo.$noWorldOffsetArray)) {
			$tab_PaneDrawInfo.$noWorldOffsetArray = [];
			$tab_PaneDrawInfo.$noWorldOffsetArray.push(0);
		}
		this.setDefaultLabelLookupValues();
	};
	$tab_PaneDrawInfo.__typeName = 'tab.PaneDrawInfo';
	$tab_PaneDrawInfo.$ctor1 = function(pdMarksKey, scene, pane, paneMarks, colorDict, paneDrawInfoKey, dataStore, paneIndex) {
		$tab_PaneDrawInfo.call(this);
		if (ss.isNullOrUndefined(pane)) {
			throw new ss.ArgumentNullException('pane');
		}
		if (ss.isNullOrUndefined(paneMarks)) {
			throw new ss.ArgumentNullException('paneMarks');
		}
		this.skipClipping = false;
		this.paneDrawInfoKey = paneDrawInfoKey;
		this.sceneInfo = scene;
		this.paneMarks = paneMarks;
		this.forceOpaqueColors = false;
		this.pdMarksKey = pdMarksKey;
		this.paneColumn = pane.Column;
		this.paneRow = pane.Row;
		this.paneRect = { x: pane.Rect[0], y: pane.Rect[1], w: pane.Rect[2], h: pane.Rect[3] };
		this.set_paneIndex(paneIndex);
		this.domainExtents = null;
		var perPaneExtentsDefined = ss.isValue(dataStore.Viewpoint) && ss.isValue(dataStore.Viewpoint.PerPaneExtents);
		if (perPaneExtentsDefined) {
			this.domainExtents = $tab_PaneDrawInfo.getPaneDomainExtents(dataStore.Viewpoint.PerPaneExtents, paneIndex);
		}
		this.markCount = $tab_PaneDrawInfo.getNumPaneItems(this.paneMarks);
		var markLayoutOutput = dataStore.PDMarks[pdMarksKey];
		var markLayoutData = markLayoutOutput.MarkLayoutData;
		var markLayoutParameters = markLayoutData.Parameters;
		this.markType = tab.EnumConversions.primitiveFromInt(markLayoutParameters.PrimitiveType);
		this.showLabels = ss.isValue(markLayoutOutput.ShowLabels) && markLayoutOutput.ShowLabels;
		this.labelMode = (ss.isValue(markLayoutOutput.LabelMode) ? markLayoutOutput.LabelMode : 'mlm-default');
		this.set_paneFlags(markLayoutParameters.pane_flags);
		this.hasPixelGeometry = this.scaleMarksInX && this.scaleMarksInY;
		this.c = $tab_PaneDrawInfo.$parseColumns(dataStore.PDMarks[pdMarksKey], paneMarks.get_startIndex(), this.markCount);
		this.hasConstantColor = !markLayoutOutput.has_per_mark_color_encoding;
		var backgroundColor = tab.ColorModel.white;
		if (this.c.has('background_color')) {
			var $t1 = this.c.get('background_color');
			backgroundColor = tab.ColorModel.fromArgbInt($t1.v[($t1.c ? 0 : 0)]);
		}
		this.fogBlendFactor = tab.SceneDataUtil.getFogBlendFactor(backgroundColor);
		this.foggedBackgroundColor = tab.SceneDataUtil.applyFogToBackgroundColor(backgroundColor, this.fogBlendFactor);
		this.transformColumnData(this.c);
		this.setUserPaneInfo(scene.sceneUserPaneInfo);
		this.processColors(colorDict);
		this.initStaticProperties();
		this.setDefaultLabelLookupValues();
		if (this.markType === 'line' || this.markType === 'area') {
			this.prepareLeftRight();
		}
		var isTextTable = ss.isValue(markLayoutData.TextCompositionInputKeys) && markLayoutData.TextCompositionInputKeys.is_text_table === true;
		this.parseTextInfo(markLayoutOutput.TextRunTable, markLayoutOutput.TextStyleTable, false, isTextTable);
		if (ss.isValue(this.paneRect) && ss.isValue(this.paneRect.w) && ss.isValue(this.domainExtents) && ss.isValue(this.domainExtents.w) && this.domainExtents.w !== 0) {
			this.worldWidth = this.paneRect.w / this.domainExtents.w;
		}
		this.clipCase = tab.SceneDataUtil.calcCellClip(this.get_paneFlags());
		this.mapExtents = null;
		if (perPaneExtentsDefined) {
			this.mapExtents = $tab_PaneDrawInfo.buildMapExtentsRect(dataStore.Viewpoint.PerPaneExtents, paneIndex, this.domainExtents, this.paneRect);
		}
		this.setupBoundingBoxes();
		if (this.markType === 'shape') {
			this.setupCustomShapePositions();
			this.setupShapeMarkStampingMap();
		}
		this.buildTupleLookup();
	};
	$tab_PaneDrawInfo.getNumPaneItems = function PaneDrawInfo$GetNumPaneItems(paneMarks) {
		return paneMarks.get_endIndex() - paneMarks.get_startIndex();
	};
	$tab_PaneDrawInfo.getPaneDomainExtents = function PaneDrawInfo$GetPaneDomainExtents(paneExtents, paneIndex) {
		ss.Debug.assert(paneExtents.DomainLeft[paneIndex] !== paneExtents.DomainRight[paneIndex] && paneExtents.DomainBottom[paneIndex] !== paneExtents.DomainTop[paneIndex], 'Error: DomainExtents are degenerate.');
		return tab.DoubleRectXYUtil.constructDoubleRectXY(paneExtents.DomainLeft[paneIndex], paneExtents.DomainTop[paneIndex], paneExtents.DomainRight[paneIndex], paneExtents.DomainBottom[paneIndex]);
	};
	$tab_PaneDrawInfo.buildMapExtentsRect = function PaneDrawInfo$BuildMapExtentsRect(paneExtents, paneIndex, domainExtents, paneRectXY) {
		if (ss.isNullOrUndefined(paneExtents.MapDomainBottom) || ss.isNullOrUndefined(paneExtents.MapDomainTop) || ss.isNullOrUndefined(paneExtents.MapDomainLeft) || ss.isNullOrUndefined(paneExtents.MapDomainRight) || paneExtents.MapDomainLeft[paneIndex] === paneExtents.MapDomainRight[paneIndex] || paneExtents.MapDomainBottom[paneIndex] === paneExtents.MapDomainTop[paneIndex]) {
			return null;
		}
		return { x: ss.Int32.trunc($tab_PaneDrawInfo.domainToPixelX(paneExtents.MapDomainLeft[paneIndex], domainExtents, paneRectXY)), y: ss.Int32.trunc($tab_PaneDrawInfo.domainToPixelY(paneExtents.MapDomainTop[paneIndex], domainExtents, paneRectXY)), w: ss.Int32.trunc($tab_PaneDrawInfo.domainToPixelWidth(paneExtents.MapDomainRight[paneIndex] - paneExtents.MapDomainLeft[paneIndex], domainExtents, paneRectXY)), h: ss.Int32.trunc($tab_PaneDrawInfo.domainToPixelHeight(paneExtents.MapDomainBottom[paneIndex] - paneExtents.MapDomainTop[paneIndex], domainExtents, paneRectXY)) };
	};
	$tab_PaneDrawInfo.$parseColumns = function PaneDrawInfo$ParseColumns(markLayout, startIndex, count) {
		var retVal = new Map();
		var dictionary = markLayout;
		var $t1 = new ss.ObjectEnumerator(dictionary);
		try {
			while ($t1.moveNext()) {
				var pair = $t1.current();
				if (!ss.referenceEquals(pair.value, markLayout.Encodings) && !ss.referenceEquals(pair.value, markLayout.MarkLayoutData)) {
					var collection = [pair.value];
					retVal.set(pair.key, tab.VisualColumnIterator.create(collection));
				}
			}
		}
		finally {
			$t1.dispose();
		}
		var parametersDict = markLayout.MarkLayoutData.Parameters;
		var $t2 = new ss.ObjectEnumerator(parametersDict);
		try {
			while ($t2.moveNext()) {
				var pair1 = $t2.current();
				var collection1 = [pair1.value];
				retVal.set(pair1.key, tab.VisualColumnIterator.create(collection1));
			}
		}
		finally {
			$t2.dispose();
		}
		var encodingsDict = markLayout.Encodings;
		var $t3 = new ss.ObjectEnumerator(encodingsDict);
		try {
			while ($t3.moveNext()) {
				var pair2 = $t3.current();
				var curColumn = pair2.value;
				retVal.set(pair2.key, ss.cast(tab.VisualColumnIterator.create(Array.prototype.slice.call(curColumn, startIndex, startIndex + count)), tab.VisualColumnIterator));
			}
		}
		finally {
			$t3.dispose();
		}
		return retVal;
	};
	$tab_PaneDrawInfo.domainToPixelX = function PaneDrawInfo$DomainToPixelX(x, domainExtents, paneRectXY) {
		return $tab_GeometryUtil.$domainToPixel(x, domainExtents.x, paneRectXY.x, paneRectXY.w / domainExtents.w);
	};
	$tab_PaneDrawInfo.domainToPixelY = function PaneDrawInfo$DomainToPixelY(y, domainExtents, paneRectXY) {
		return $tab_GeometryUtil.$domainToPixel(y, domainExtents.y, paneRectXY.y, paneRectXY.h / domainExtents.h);
	};
	$tab_PaneDrawInfo.domainToPixelWidth = function PaneDrawInfo$DomainToPixelWidth(width, domainExtents, paneRectXY) {
		return width / domainExtents.w * paneRectXY.w;
	};
	$tab_PaneDrawInfo.domainToPixelHeight = function PaneDrawInfo$DomainToPixelHeight(height, domainExtents, paneRectXY) {
		return height / domainExtents.h * paneRectXY.h;
	};
	$tab_PaneDrawInfo.$createPreparedFont = function PaneDrawInfo$CreatePreparedFont(textStyles, styleNum) {
		ss.Debug.assert(ss.keyExists(textStyles, 'font_size'), 'The font must have a size');
		ss.Debug.assert(ss.keyExists(textStyles, 'font'), 'The font must have a name');
		var fontDescription = new ss.StringBuilder();
		if (ss.keyExists(textStyles, 'font_style') && parseInt(textStyles['font_style'].dataValues[styleNum].toString()) === 1) {
			fontDescription.append('italic ');
		}
		if (ss.keyExists(textStyles, 'font_weight') && parseInt(textStyles['font_weight'].dataValues[styleNum].toString()) === 1) {
			fontDescription.append('bold ');
		}
		var pointSize = parseInt(textStyles['font_size'].dataValues[styleNum].toString());
		pointSize = Math.max(6, pointSize);
		var fontName = ss.cast(textStyles['font'].dataValues[styleNum], String);
		fontName = tab.FontUtil.createFallbackCanvasFontName(fontName);
		fontDescription.append(pointSize + 'pt ' + fontName);
		return fontDescription.toString();
	};
	$tab_PaneDrawInfo.$createPreparedFont$1 = function PaneDrawInfo$CreatePreparedFont(textStyles, styleNum) {
		ss.Debug.assert(!ss.isNullOrUndefined(textStyles.font_size), 'The font must have a size');
		ss.Debug.assert(!ss.isNullOrUndefined(textStyles.font), 'The font must have a name');
		var fontDescription = new ss.StringBuilder();
		if (!ss.isNullOrUndefined(textStyles.font_style) && parseInt(textStyles.font_style[styleNum].toString()) === 1) {
			fontDescription.append('italic ');
		}
		if (!ss.isNullOrUndefined(textStyles.font_weight) && parseInt(textStyles.font_weight[styleNum].toString()) === 1) {
			fontDescription.append('bold ');
		}
		var pointSize = parseInt(textStyles.font_size[styleNum].toString());
		pointSize = Math.max(6, pointSize);
		var fontName = textStyles.font[styleNum];
		fontName = tab.FontUtil.createFallbackCanvasFontName(fontName);
		fontDescription.append(pointSize + 'pt ' + fontName);
		return fontDescription.toString();
	};
	$tab_PaneDrawInfo.getTextAngleInRad = function PaneDrawInfo$GetTextAngleInRad(textOrientation) {
		return $tab_PaneDrawInfo.textAngleInRad.get(textOrientation);
	};
	$tab_PaneDrawInfo.getMarkBoundingBox = function PaneDrawInfo$GetMarkBoundingBox(markType, index, paneDrawInfo, userPaneRect) {
		ss.Debug.assert(ss.isValue(paneDrawInfo), 'Expecting non-null PaneDrawInfo');
		ss.Debug.assert(index >= 0, 'Invalid mark index');
		var bbox;
		switch (markType) {
			case 'shape': {
				bbox = $tab_MarksRenderer.shapeMarkBuildMarkBound(paneDrawInfo, index);
				break;
			}
			case 'bar':
			case 'square': {
				bbox = $tab_MarksRenderer.barMarkBuildMarkBound(paneDrawInfo, index);
				break;
			}
			case 'pie': {
				bbox = $tab_MarksRenderer.getPieBoundingBox(paneDrawInfo, index);
				break;
			}
			case 'text': {
				bbox = $tab_MarksRenderer.textMarkBuildMarkBound(paneDrawInfo, index);
				break;
			}
			case 'label': {
				bbox = $tab_MarksRenderer.getMarkLabelBoundingBox(paneDrawInfo, index);
				break;
			}
			case 'line': {
				bbox = $tab_MarksRenderer.lineMarkBuildMarkBound(paneDrawInfo, index);
				break;
			}
			case 'area': {
				bbox = $tab_MarksRenderer.areaMarkBuildMarkBound(paneDrawInfo, index);
				break;
			}
			case 'multipolygon': {
				bbox = $tab_MarksRenderer.multipolygonMarkBuildMarkBound(paneDrawInfo, index);
				break;
			}
			default: {
				bbox = $tab_PaneDrawInfo.$defaultBoundingBoxBasedOnMarkSize(paneDrawInfo, index);
				break;
			}
		}
		if (paneDrawInfo.hasUserPanes) {
			tab.RectXYUtil.intersectInPlace(bbox, userPaneRect);
		}
		return bbox;
	};
	$tab_PaneDrawInfo.$defaultBoundingBoxBasedOnMarkSize = function PaneDrawInfo$DefaultBoundingBoxBasedOnMarkSize(paneDrawInfo, markIndex) {
		var x = paneDrawInfo.c.get('x').gv(markIndex);
		var y = paneDrawInfo.c.get('y').gv(markIndex);
		var size = paneDrawInfo.c.get('size').gv(markIndex);
		var roundedSize = Math.ceil(size);
		return { x: Math.floor(x - size / 2 + 0.5), y: Math.floor(y - size / 2 + 0.5), w: roundedSize, h: roundedSize };
	};
	global.tab.PaneDrawInfo = $tab_PaneDrawInfo;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.PaneTable2DRenderer
	var $tab_PaneTable2DRenderer = function(canvas, context) {
		this.$displayListRenderer = null;
		this.$referenceLinesRenderer = null;
		this.$sceneInfo = null;
		tab.CanvasRenderer.call(this, canvas, context);
		var colors = (ss.isValue(this.$sceneInfo) ? this.$sceneInfo.colorModel : $tab_InteractionColorModel.defaultColors);
		this.$displayListRenderer = new $tab_DisplayList2DRenderer(canvas, context, colors);
		this.$referenceLinesRenderer = new $tab_ReferenceLinesRenderer(canvas, context);
	};
	$tab_PaneTable2DRenderer.__typeName = 'tab.PaneTable2DRenderer';
	$tab_PaneTable2DRenderer.renderHoverOverlay = function PaneTable2DRenderer$RenderHoverOverlay(tupleId, paneDrawInfo, overlayCanvas) {
		if (ss.isNullOrUndefined(overlayCanvas) || ss.isNullOrUndefined(paneDrawInfo)) {
			return;
		}
		{
			var $t1 = tabBootstrap.MetricsController.createContext('RenderHoverOverlay', 32, null);
			try {
				var markIndex = paneDrawInfo.getMarkIndexFromTupleId(tupleId);
				switch (paneDrawInfo.markType) {
					case 'area': {
						$tab_MarksRenderer.renderAreaMarkHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'bar':
					case 'square': {
						$tab_MarksRenderer.renderBarHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'line': {
						$tab_MarksRenderer.renderLineMarkHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'multipolygon': {
						$tab_MarksRenderer.renderMultipolygonMarkHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'pie': {
						$tab_MarksRenderer.renderPieHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'shape': {
						$tab_MarksRenderer.renderShapeHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'text': {
						$tab_MarksRenderer.renderTextHoverOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
				}
			}
			finally {
				if (ss.isValue($t1)) {
					$t1.dispose();
				}
			}
		}
	};
	$tab_PaneTable2DRenderer.renderPressedOverlay = function PaneTable2DRenderer$RenderPressedOverlay(tupleId, paneDrawInfo, overlayCanvas) {
		if (ss.isNullOrUndefined(overlayCanvas) || ss.isNullOrUndefined(paneDrawInfo)) {
			return;
		}
		{
			var $t1 = tabBootstrap.MetricsController.createContext('RenderPressedOverlay', 32, null);
			try {
				var markIndex = paneDrawInfo.getMarkIndexFromTupleId(tupleId);
				switch (paneDrawInfo.markType) {
					case 'area': {
						$tab_MarksRenderer.renderAreaMarkPressedOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'bar':
					case 'square': {
						$tab_MarksRenderer.renderBarPressedOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'line': {
						$tab_MarksRenderer.renderLineMarkPressedOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'multipolygon': {
						$tab_MarksRenderer.renderMultipolygonMarkPressedOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'pie': {
						$tab_MarksRenderer.renderPiePressedOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
					case 'shape': {
						$tab_MarksRenderer.renderShapePressedOverlayImage(overlayCanvas, paneDrawInfo, tupleId);
						break;
					}
					case 'text': {
						$tab_MarksRenderer.renderTextPressedOverlayImage(overlayCanvas, paneDrawInfo, markIndex);
						break;
					}
				}
			}
			finally {
				if (ss.isValue($t1)) {
					$t1.dispose();
				}
			}
		}
	};
	$tab_PaneTable2DRenderer.anInstantRefLineIsPresent = function PaneTable2DRenderer$AnInstantRefLineIsPresent(runtimeData) {
		if (ss.isValue(runtimeData.get_finalDataStore().InstantRefLines)) {
			var $t1 = new ss.ObjectEnumerator(runtimeData.get_finalDataStore().InstantRefLines);
			try {
				while ($t1.moveNext()) {
					var pane = $t1.current();
					if (pane.value.LayoutElements.Value.length > 0) {
						return true;
					}
				}
			}
			finally {
				$t1.dispose();
			}
		}
		var $t2 = runtimeData.get_annexedData().Panes;
		for (var $t3 = 0; $t3 < $t2.length; $t3++) {
			var pane1 = $t2[$t3];
			var drawPanes = pane1.DrawPanes;
			for (var $t4 = 0; $t4 < drawPanes.length; $t4++) {
				var drawPane = drawPanes[$t4];
				var panePartArray = drawPane;
				var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
				if (visualPart === 'ref-lines') {
					return true;
				}
			}
		}
		return false;
	};
	$tab_PaneTable2DRenderer.$setCoordinatesFromPoints = function PaneTable2DRenderer$SetCoordinatesFromPoints(pointsToAlter, start, end) {
		pointsToAlter[0] = start.x;
		pointsToAlter[1] = start.y;
		pointsToAlter[2] = end.x;
		pointsToAlter[3] = end.y;
	};
	$tab_PaneTable2DRenderer.calculateColorForState = function PaneTable2DRenderer$CalculateColorForState(colorModel, targetState, isTypeVisuallyAffected, applyFog) {
		if (targetState === 'selected' && isTypeVisuallyAffected) {
			if (tab.ColorModel.isFullyTransparent(colorModel)) {
				return $tab_PaneTable2DRenderer.$displayListSelectedColorBlack;
			}
			return colorModel.toString();
		}
		if (targetState === 'hover' && isTypeVisuallyAffected) {
			return colorModel.toHoverColor().toString();
		}
		if (targetState === 'fogged') {
			return tab.SceneDataUtil.fogColorTransform(colorModel, applyFog.item2, applyFog.item1).toString();
		}
		return colorModel.toString();
	};
	$tab_PaneTable2DRenderer.getFogBlendFactorAndBackgroundColor = function PaneTable2DRenderer$GetFogBlendFactorAndBackgroundColor(paneDrawInfo) {
		if (ss.isValue(paneDrawInfo) && ss.isValue(paneDrawInfo.fogBlendFactor) && ss.isValue(paneDrawInfo.foggedBackgroundColor)) {
			return { item1: paneDrawInfo.fogBlendFactor, item2: paneDrawInfo.foggedBackgroundColor };
		}
		else {
			var defaultBackground = tab.ColorModel.white;
			var defaultBlendFactor = tab.SceneDataUtil.getFogBlendFactor(defaultBackground);
			var defaultFoggedBackground = tab.SceneDataUtil.applyFogToBackgroundColor(defaultBackground, defaultBlendFactor);
			return { item1: defaultBlendFactor, item2: defaultFoggedBackground };
		}
	};
	global.tab.PaneTable2DRenderer = $tab_PaneTable2DRenderer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableCanvasView
	var $tab_PaneTableCanvasView = function(viewModel, domNode, backgroundMode) {
		ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_PaneTableViewModel]).call(this, viewModel, domNode, backgroundMode);
		this.renderer = new $tab_PaneTable2DRenderer(this.canvasElt, this.context);
		var $t1 = _.keys(viewModel.get_vizRegionMap());
		for (var $t2 = 0; $t2 < $t1.length; $t2++) {
			var part = $t1[$t2];
			if (!ss.contains($tab_PaneTableViewModel.blackListVisualParts, part)) {
				viewModel.get_vizRegionMap()[part].add_propertyChanged(ss.mkdel(this, this.onViewModelPropertyChanged));
			}
		}
	};
	$tab_PaneTableCanvasView.__typeName = 'tab.PaneTableCanvasView';
	global.tab.PaneTableCanvasView = $tab_PaneTableCanvasView;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.PaneTableGeometry.PaneTableGeometryArgCache
	var $tab_PaneTableGeometryArgCache = function() {
		this.$lastArgs = null;
	};
	$tab_PaneTableGeometryArgCache.__typeName = 'tab.PaneTableGeometryArgCache';
	global.tab.PaneTableGeometryArgCache = $tab_PaneTableGeometryArgCache;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.PaneTableGeometry.PaneTableGeometryBundle
	var $tab_PaneTableGeometryBundle = function(regionGeometry, visibleGeometry, geometryWithRegions) {
		this.$1$RegionGeometryField = null;
		this.$1$VisibleGeometryField = null;
		this.$1$GeometryWithRegionsField = null;
		this.set_regionGeometry(regionGeometry);
		this.set_visibleGeometry(visibleGeometry);
		this.set_geometryWithRegions(geometryWithRegions);
	};
	$tab_PaneTableGeometryBundle.__typeName = 'tab.PaneTableGeometryBundle';
	global.tab.PaneTableGeometryBundle = $tab_PaneTableGeometryBundle;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.PaneTableGeometry.PaneTableGeometryComputer
	var $tab_PaneTableGeometryComputer = function() {
	};
	$tab_PaneTableGeometryComputer.__typeName = 'tab.PaneTableGeometryComputer';
	$tab_PaneTableGeometryComputer.computeGeometry = function PaneTableGeometryComputer$ComputeGeometry(args) {
		var geo = $tab_PaneTableGeometryComputer.$initializeGeometryWithRegions(args.geometry);
		var regionGeometry = new $tab_RegionGeometry(geo, args.containerBox.w, args.containerBox.h);
		var visGeo = regionGeometry.getVisibleGeometry(geo, args.containerBox.w);
		if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
			$tab_PaneTableGeometryComputer.$applySizeCorrectionForBorder(geo, visGeo);
		}
		return new $tab_PaneTableGeometryBundle(regionGeometry, visGeo, geo);
	};
	$tab_PaneTableGeometryComputer.$initializeGeometryWithRegions = function PaneTableGeometryComputer$InitializeGeometryWithRegions(g) {
		var geo = {};
		$.extend(true, geo, g);
		var len = geo.ri.length;
		for (var i = 0; i < len; i++) {
			geo[geo.ri[i].r] = geo.ri[i];
		}
		return geo;
	};
	$tab_PaneTableGeometryComputer.$applySizeCorrectionForBorder = function PaneTableGeometryComputer$ApplySizeCorrectionForBorder(geo, visGeo) {
		if (ss.isValue(geo.bottomaxis)) {
			$tab_PaneTableGeometryComputer.$addExtraPixelToGeometryHeight(geo);
			$tab_PaneTableGeometryComputer.$addExtraPixelToVisibleGeometryHeight(visGeo);
		}
		if (ss.isValue(geo.rightaxis)) {
			$tab_PaneTableGeometryComputer.$addExtraPixelToGeometryWidth(geo);
			$tab_PaneTableGeometryComputer.$addExtraPixelToVisibleGeometryWidth(visGeo);
		}
	};
	$tab_PaneTableGeometryComputer.$addExtraPixelToGeometryWidth = function PaneTableGeometryComputer$AddExtraPixelToGeometryWidth(geo) {
		var extraWidthRegions = [geo.xheader, geo.bottomaxis, geo.topaxis, geo.viz];
		for (var $t1 = 0; $t1 < extraWidthRegions.length; $t1++) {
			var rect = extraWidthRegions[$t1];
			if (ss.isValue(rect)) {
				rect.w += 1;
			}
		}
	};
	$tab_PaneTableGeometryComputer.$addExtraPixelToGeometryHeight = function PaneTableGeometryComputer$AddExtraPixelToGeometryHeight(geo) {
		var extraHeightRegions = [geo.yheader, geo.rightaxis, geo.leftaxis, geo.viz];
		for (var $t1 = 0; $t1 < extraHeightRegions.length; $t1++) {
			var rect = extraHeightRegions[$t1];
			if (ss.isValue(rect)) {
				rect.h += 1;
			}
		}
	};
	$tab_PaneTableGeometryComputer.$addExtraPixelToVisibleGeometryWidth = function PaneTableGeometryComputer$AddExtraPixelToVisibleGeometryWidth(visibleGeometry) {
		var extraWidthRegions = [visibleGeometry.xheaderArea, visibleGeometry.bottomaxisArea, visibleGeometry.topaxisArea, visibleGeometry.vizArea];
		for (var $t1 = 0; $t1 < extraWidthRegions.length; $t1++) {
			var rect = extraWidthRegions[$t1];
			if (ss.isValue(rect)) {
				rect.w += 1;
			}
		}
	};
	$tab_PaneTableGeometryComputer.$addExtraPixelToVisibleGeometryHeight = function PaneTableGeometryComputer$AddExtraPixelToVisibleGeometryHeight(visibleGeometry) {
		var extraHeightRegions = [visibleGeometry.yheaderArea, visibleGeometry.rightaxisArea, visibleGeometry.leftaxisArea, visibleGeometry.vizArea];
		for (var $t1 = 0; $t1 < extraHeightRegions.length; $t1++) {
			var rect = extraHeightRegions[$t1];
			if (ss.isValue(rect)) {
				rect.h += 1;
			}
		}
	};
	$tab_PaneTableGeometryComputer.computeVizScrollCapabilities = function PaneTableGeometryComputer$ComputeVizScrollCapabilities(model) {
		var args = { containerBox: model.get_containerGeometry(), geometry: model.get_geometryModel().pm };
		var bundle = $tab_PaneTableGeometryComputer.computeGeometry(args);
		var vizContentGeometry = bundle.get_geometryWithRegions().viz;
		var vizContainerGeometry = bundle.get_visibleGeometry().vizArea;
		if (ss.isNullOrUndefined(vizContentGeometry) || ss.isNullOrUndefined(vizContainerGeometry)) {
			return 0;
		}
		var scrollCapabilities = 0;
		if (vizContentGeometry.w > vizContainerGeometry.w) {
			scrollCapabilities |= 1;
		}
		if (vizContentGeometry.h > vizContainerGeometry.h) {
			scrollCapabilities |= 2;
		}
		return scrollCapabilities;
	};
	global.tab.PaneTableGeometryComputer = $tab_PaneTableGeometryComputer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableOverlayView
	var $tab_PaneTableOverlayView = function(viewModel, domNode, vizRegion) {
		this.$vizRegion = null;
		this.$invalidRects = [];
		this.$hoverTarget = new $tab_$TargetObject('hover');
		this.$pressTarget = new $tab_$TargetObject('press');
		this.$hasInvalidAreas = false;
		this.$selectorShapeState = null;
		this.$hasTargetBeenPressed = false;
		this.$dirtyDragRects = [];
		this.$pendingDragTuples = null;
		this.$dragTuples = null;
		this.$lastTargetState = 'normal';
		this.$timedOut = false;
		this.$referenceLinesRenderer = null;
		ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_PaneTableViewModel]).call(this, viewModel, domNode, 'transparent');
		this.renderer = new $tab_PaneTable2DRenderer(this.canvasElt, this.context);
		this.$referenceLinesRenderer = new $tab_ReferenceLinesRenderer(this.canvasElt, this.context);
		this.$vizRegion = vizRegion;
		var canvasObject = $(this.canvasElt);
		canvasObject.css('position', 'absolute');
		canvasObject.css('left', '0px');
		canvasObject.css('top', '0px');
	};
	$tab_PaneTableOverlayView.__typeName = 'tab.PaneTableOverlayView';
	$tab_PaneTableOverlayView.$checkArrayIsSorted = function PaneTableOverlayView$CheckArrayIsSorted(tuples) {
		for (var i = 0; i + 1 < tuples.length; ++i) {
			ss.Debug.assert(tuples[i] < tuples[i + 1], 'See comments, list of tuples must be sorted');
		}
	};
	$tab_PaneTableOverlayView.$computeTupleDifference = function PaneTableOverlayView$ComputeTupleDifference(tuples1, tuples2) {
		var tupleSet = new Set();
		if (ss.isValue(tuples1) && tuples1.length > 0) {
			tab.SetUtilities.addAll(ss.Int32).call(null, tupleSet, tuples1);
		}
		if (ss.isValue(tuples2) && tuples2.length > 0) {
			var otherSet = new Set();
			tab.SetUtilities.addAll(ss.Int32).call(null, otherSet, tuples2);
			tupleSet = tab.SetUtilities.symmetricDifferenceWith(ss.Int32).call(null, tupleSet, otherSet);
		}
		return tab.SetUtilities.getValues(ss.Int32).call(null, tupleSet);
	};
	global.tab.PaneTableOverlayView = $tab_PaneTableOverlayView;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableTemplate
	var $tab_PaneTableTemplate = function(root) {
		this.enclosingDiv = null;
		this.yLabel = null;
		this.leftAxis = null;
		this.rightAxis = null;
		this.xLabel = null;
		this.bottomAxis = null;
		this.topAxis = null;
		this.view = null;
		this.title = null;
		this.caption = null;
		this.topLeftSpacer = null;
		this.topRightSpacer = null;
		this.bottomLeftSpacer = null;
		this.bottomRightSpacer = null;
		this.borders = null;
		spiff.Template.call(this, root);
		var g = ss.mkdel(this, this.getElementBySelector);
		this.enclosingDiv = g('.tab-clip');
		this.yLabel = g('.tab-tvYLabel');
		this.leftAxis = g('.tab-tvLeftAxis');
		this.rightAxis = g('.tab-tvRightAxis');
		this.xLabel = g('.tab-tvXLabel');
		this.bottomAxis = g('.tab-tvBottomAxis');
		this.topAxis = g('.tab-tvTopAxis');
		this.view = g('.tab-tvView');
		this.title = g('.tab-tvTitle');
		this.caption = g('.tab-tvCaption');
		this.topLeftSpacer = g('.tab-tvTLSpacer');
		this.topRightSpacer = g('.tab-tvTRSpacer');
		this.bottomLeftSpacer = g('.tab-tvBLSpacer');
		this.bottomRightSpacer = g('.tab-tvBRSpacer');
		this.borders = g('.tvViewportBorders');
		this.borders.append($($tab_PaneTableTemplate.$bordersHtml));
	};
	$tab_PaneTableTemplate.__typeName = 'tab.PaneTableTemplate';
	global.tab.PaneTableTemplate = $tab_PaneTableTemplate;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableView
	var $tab_PaneTableView = function(paneTableVM, template) {
		this.regions = {};
		this.floatingZoomToolbarView = null;
		this.isPointerToolLocked = false;
		this.mapsSearchView = null;
		this.wasPressOverlayJustUpdated = false;
		this.lastVizHoverPoint = null;
		this.$overlayImages = [];
		this.$timestamp = 0;
		this.$scrollPos = { x: 0, y: 0 };
		this.$requestId = 0;
		this.$visualPartHoverCommandTimeOut = null;
		this.isAnimationOccurring = false;
		this.vizTooltip = null;
		this.$titleView = null;
		this.$captionView = null;
		this.$hasBeenDisposed = false;
		this.$overlayTableView = null;
		this.$lastDragTime = 0;
		this.$pendingOverlayDrag = null;
		this.$mapAttribution = null;
		this.$mapScaleView = null;
		this.$cachedColors = null;
		this.$isMapsSearchViewInDom = false;
		this.$titleAreaId = null;
		this.$captionAreaId = null;
		this.$instructionsDiv = null;
		this.$cornersRenderer = new $tab_$PaneTableCornersRenderer();
		this.regionParts = null;
		this.$geometryArgCache = null;
		this.$3$GeometryBundleField = null;
		this.dom = null;
		this.tlspacerAreaX = null;
		this.tlspacerAreaY = null;
		this.titleHeight = 0;
		this.$3$VizHitTestDebouncerField = null;
		ss.makeGenericType(spiff.BaseView$1, [tab.IPaneTableViewModel]).call(this, paneTableVM, template);
		this.dom = template;
		this.regionParts = new $tab_PaneTableViewRegionParts(template);
		this.get_controller().setTiledViewer(this);
		this.$timestamp = (new Date()).getTime();
		this.dom.view.attr('id', 'view' + this.$getDashboardViewId());
		this.dom.domRoot.attr('tb-test-id', tab.EscapingUtil.escapeHtml(this.get_paneTableVM().get_visualId().worksheet));
		this.floatingZoomToolbarView = new $tab_FloatingZoomToolbarView(this);
		var clickHandler = spiff.TableauClickHandler.targetAndClick(this.dom.view.get(0), ss.mkdel(this, function(e) {
			if (tab.FeatureFlags.isEnabled('MultiSelect') && tab.DashboardView.canMultiSelectZones(e)) {
				tab.SelectionClientCommands.setActiveZone(this.get_paneTableVM().get_zonePresModel().zoneId, 'add', null);
			}
		}));
		clickHandler.set_stopPropagationOnEvent(false);
		this.disposables.add$1(clickHandler);
		var domClickHandler = spiff.TableauClickHandler.targetAndClick(this.dom.domRoot.get(0), ss.mkdel(this, function(e1) {
			if (tab.FeatureFlags.isEnabled('MultiSelect') && tab.DashboardView.canMultiSelectZones(e1)) {
				tab.SelectionClientCommands.setActiveZone(this.get_paneTableVM().get_zonePresModel().zoneId, 'add', null);
			}
		}));
		domClickHandler.set_stopPropagationOnEvent(false);
		this.disposables.add$1(domClickHandler);
		var visualModel = paneTableVM.get_visualModel();
		this.$updateTitle(visualModel);
		this.$updateCaption(visualModel);
		this.$updateAccessibilityViewDataInstructions();
		this.$updateAccessibilityBindingsForView();
		this.$setupKeyboardAccessibility();
		this.$updateDebugInfo(visualModel);
		this.get_paneTableVM().add_newPaneTable(ss.mkdel(this, this.handleNewVisual));
		this.get_paneTableVM().add_propertyChanged(ss.mkdel(this, this.handlePropertyChanged));
		this.get_paneTableVM().add_textUpdated(ss.mkdel(this, this.$handleTextUpdated));
		if (ss.isValue(this.get_paneTableVM().get_mapServerModel())) {
			this.get_paneTableVM().get_mapServerModel().add_tileSourceChanged(ss.mkdel(this, this.$handleMapSourceChanged));
		}
		this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
			this.get_paneTableVM().remove_newPaneTable(ss.mkdel(this, this.handleNewVisual));
			this.get_paneTableVM().remove_propertyChanged(ss.mkdel(this, this.handlePropertyChanged));
			this.get_paneTableVM().remove_textUpdated(ss.mkdel(this, this.$handleTextUpdated));
			if (ss.isValue(this.get_paneTableVM().get_mapServerModel())) {
				this.get_paneTableVM().get_mapServerModel().remove_tileSourceChanged(ss.mkdel(this, this.$handleMapSourceChanged));
			}
		})));
		this.set_geometryBundle(new $tab_PaneTableGeometryBundle(null, null, null));
		this.$geometryArgCache = new $tab_PaneTableGeometryArgCache();
	};
	$tab_PaneTableView.__typeName = 'tab.PaneTableView';
	$tab_PaneTableView.addVizDragApprover = function PaneTableView$AddVizDragApprover(dragApprover) {
		$tab_PaneTableView.removeVizDragApprover(dragApprover);
		$tab_PaneTableView.$vizDragApprovers.push(dragApprover);
	};
	$tab_PaneTableView.removeVizDragApprover = function PaneTableView$RemoveVizDragApprover(dragApprover) {
		ss.remove($tab_PaneTableView.$vizDragApprovers, dragApprover);
	};
	$tab_PaneTableView.addVizDragHandler = function PaneTableView$AddVizDragHandler(dragHandler) {
		$tab_PaneTableView.removeVizDragHandler(dragHandler);
		$tab_PaneTableView.$vizDragHandlers.push(dragHandler);
	};
	$tab_PaneTableView.addAsyncVizDragHandler = function PaneTableView$AddAsyncVizDragHandler(dragHandler) {
		$tab_PaneTableView.removeAsyncVizDragHandler(dragHandler);
		$tab_PaneTableView.$asyncVizDragHandlers.push(dragHandler);
	};
	$tab_PaneTableView.removeVizDragHandler = function PaneTableView$RemoveVizDragHandler(dragHandler) {
		ss.remove($tab_PaneTableView.$vizDragHandlers, dragHandler);
	};
	$tab_PaneTableView.removeAsyncVizDragHandler = function PaneTableView$RemoveAsyncVizDragHandler(dragHandler) {
		ss.remove($tab_PaneTableView.$asyncVizDragHandlers, dragHandler);
	};
	$tab_PaneTableView.$getRegionBackgroundColor = function PaneTableView$GetRegionBackgroundColor(colors, regionPart) {
		if (regionPart === 'viz') {
			return colors[1];
		}
		return (ss.contains($tab_PaneTableViewRegionParts.headerRegions, regionPart) ? colors[2] : colors[0]);
	};
	$tab_PaneTableView.$resolvePaneAcross = function PaneTableView$ResolvePaneAcross(pointX, widthOfPanes, pane) {
		var numPanesAcross = widthOfPanes.length;
		for (var i = 0; i < numPanesAcross; i++) {
			var paneWidth = widthOfPanes[i];
			if (pane.x + paneWidth <= pointX) {
				pane.x += paneWidth;
			}
			else {
				pane.w = paneWidth;
				return;
			}
		}
	};
	$tab_PaneTableView.$resolvePaneDown = function PaneTableView$ResolvePaneDown(pointY, heightOfPanes, pane) {
		var numPanesDown = heightOfPanes.length;
		for (var i = 0; i < numPanesDown; i++) {
			var paneHeight = heightOfPanes[i];
			if (pane.y + paneHeight <= pointY) {
				pane.y += paneHeight;
			}
			else {
				pane.h = paneHeight;
				return;
			}
		}
	};
	$tab_PaneTableView.findTitles = function PaneTableView$FindTitles() {
		return $('.tab-tvTitle');
	};
	$tab_PaneTableView.$adjustMarkHitTestCoord = function PaneTableView$AdjustMarkHitTestCoord(coords, markBBox) {
		var ShiftSize = 2;
		var toRet = { x: coords.x, y: coords.y };
		if (markBBox.w > 4) {
			toRet = tab.RectXYUtil.horizontalShiftCoordsTowardsCenter(toRet, markBBox, ShiftSize);
		}
		else {
			toRet = { x: markBBox.x + ss.Int32.div(markBBox.w, 2), y: toRet.y };
		}
		if (markBBox.h > 4) {
			toRet = tab.RectXYUtil.verticalShiftCoordsTowardsCenter(toRet, markBBox, ShiftSize);
		}
		else {
			toRet = { x: toRet.x, y: markBBox.y + ss.Int32.div(markBBox.h, 2) };
		}
		return toRet;
	};
	$tab_PaneTableView.guessTooltipTargetTypeFromRegion = function PaneTableView$GuessTooltipTargetTypeFromRegion(regionPart) {
		switch (regionPart) {
			case 'bottomaxis':
			case 'topaxis':
			case 'leftaxis':
			case 'rightaxis':
			case 'xheader':
			case 'yheader': {
				return 'header';
			}
			case 'color': {
				return 'legenditem';
			}
			default: {
				return 'unspecified';
			}
		}
	};
	$tab_PaneTableView.isViewDataAccessEnabled = function PaneTableView$IsViewDataAccessEnabled() {
		return tab.ApplicationModel.get_instance().get_toolbar().isLegacyMenuItemEnabled('exportdata');
	};
	global.tab.PaneTableView = $tab_PaneTableView;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableViewModel
	var $tab_PaneTableViewModel = function(model) {
		this.$vizRegionViewModels = {};
		this.$visModel = null;
		this.$sceneInfo = null;
		this.$localRenderVizHitTester = null;
		this.$mapsSearchViewModel = null;
		this.$mapScaleViewModel = null;
		this.$customShapesPending = null;
		this.$vizRegionToolModeViewModel = null;
		this.$invalidationRects = null;
		this.$vizContextMenuViewModel = null;
		this.$annotationSelectionChromeViewModel = null;
		this.$sceneDirty = false;
		this.$selectionsToken = null;
		this.$impliedSelectionsToken = null;
		this.$brushingsToken = null;
		this.borderHighlighted = false;
		this.$2$VizRegionMapChangeField = null;
		this.$2$NewPaneTableField = null;
		this.$2$TextUpdatedField = null;
		this.$2$DifferentMarkBrushingField = null;
		this.$2$DifferentMarkSelectionField = null;
		this.$2$ViewControllerField = null;
		this.deferredResizerFactory = null;
		this.deferredHeaderResizerManagerViewModel = null;
		this.deferredCellResizerManagerViewModel = null;
		this.$2$FloatingToolbarContainerVMField = null;
		this.$2$SmoothTooltipsOnboardingVMField = null;
		spiff.BaseViewModel.call(this);
		this.$visModel = model;
		this.$invalidationRects = [];
		this.$sceneInfo = new $tab_SceneInfo();
		var hitTestChain = new ss.Lazy(ss.mkdel(this, function() {
			return $tab_HitTestChain.createHitTestChain(this, this.$sceneInfo);
		}));
		this.$localRenderVizHitTester = new $tab_LocalRenderVizHitTester(hitTestChain, this.$sceneInfo);
		if (ss.isValue(this.$visModel)) {
			if (ss.isValue(this.$visModel.get_selectionsModel())) {
				this.$selectionsToken = this.$visModel.get_selectionsModel().createSelectionsToken();
			}
			if (ss.isValue(this.$visModel.get_selectionsModel().tupleSelection)) {
				this.$visModel.get_selectionsModel().add_newSelections(ss.mkdel(this, this.$handleSelectionChange));
			}
			this.$visModel.get_impliedSelectionModel().add_newSelection(ss.mkdel(this, this.$handleSelectionChange));
			if (ss.isValue(this.$visModel.get_brushingsModel().tupleSelection)) {
				this.$visModel.get_brushingsModel().add_newSelections(ss.mkdel(this, this.$handleBrushingChange));
			}
			if (ss.isValue(this.$visModel.get_sceneModel())) {
				this.$visModel.get_sceneModel().add_newSceneModel(ss.mkdel(this, this.$handleSceneChange));
				this.$handleSceneChange();
				this.$sceneDirty = false;
			}
			this.$visModel.add_newHiddenTuples(ss.mkdel(this, this.$handleHiddenTuplesChange));
			this.$visModel.add_newFilteredTuples(ss.mkdel(this, this.$handleFilteredTuplesChange));
			this.$visModel.add_brushingFromActionChanged(ss.mkdel(this, this.$handleBrushingFromActionChanged));
			this.$visModel.add_colorDictionaryChanged(ss.mkdel(this, this.$handleColorDictionaryChange));
			this.$visModel.add_vizNavigationSettingChanged(ss.mkdel(this, this.$handleVizNavigationSettingChange));
			this.$visModel.add_newVisual(ss.mkdel(this, this.$handleVisualChanged));
			this.$visModel.add_newVisual(ss.mkdel(this, this.$handleNewPaneTable));
			this.$visModel.add_emptyHighlightFogAllChanged(ss.mkdel(this, this.$handleEmptyHighlightFogAllChanged));
			this.$visModel.add_annotationHitBoxesChanged(ss.mkdel(this, this.$handleServerRenderedAnnotationChange));
			this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
				this.$visModel.remove_annotationHitBoxesChanged(ss.mkdel(this, this.$handleServerRenderedAnnotationChange));
			})));
		}
		var waitForFontsToLoad = ss.mkdel(this, function() {
			this.notifyPropertyChanged(tab.FontNotificationUtil.fontPropertyName);
			this.$notifyTextUpdated();
		});
		this.$vizRegionToolModeViewModel = new $tab_ToolModeViewModel('viz', (ss.isValue(this.$visModel) ? this.$visModel.get_defaultMapTool() : 'no-tools'));
		this.set_floatingToolbarContainerVM(new $tab_FloatingToolbarContainerViewModel(this.$vizRegionToolModeViewModel));
		this.set_smoothTooltipsOnboardingVM(new $tab_SmoothTooltipsOnboardingViewModel());
		this.$loadResizeHeadersModule();
		this.$initializeHeaderResizerManagerViewModel();
		this.$initializeCellResizerManagerViewModel();
		this.$initializeVizContextMenuViewModel();
		this.$initializeAnnotationSelectionChromeViewModel();
		tab.ServerFontLoader.get_instance().add_fontPreparationComplete(waitForFontsToLoad);
		this.disposables.add$1(new tab.CallOnDispose(function() {
			tab.ServerFontLoader.get_instance().remove_fontPreparationComplete(waitForFontsToLoad);
		}));
		this.$updateSceneInfo();
	};
	$tab_PaneTableViewModel.__typeName = 'tab.PaneTableViewModel';
	$tab_PaneTableViewModel.updateSceneInfoFromVisualModel = function PaneTableViewModel$UpdateSceneInfoFromVisualModel(scene, visModel) {
		if (ss.isNullOrUndefined(scene) || ss.isNullOrUndefined(visModel)) {
			return;
		}
		var colorDictionary = visModel.pm.colorDictionary;
		var scenePresModel = visModel.pm.scene;
		var selectionsModel = (ss.isValue(visModel.get_selectionsModel().tupleSelection) ? visModel.get_selectionsModel() : null);
		var impliedSelectionModel = (ss.isValue(visModel.get_impliedSelectionModel()) ? visModel.get_impliedSelectionModel() : null);
		var brushingsModel = (ss.isValue(visModel.get_brushingsModel().tupleSelection) ? visModel.get_brushingsModel() : null);
		var refLinesModel = ((ss.isValue(visModel.get_sceneModel()) && ss.isValue(visModel.get_sceneModel().get_referenceLines())) ? visModel.get_sceneModel().get_referenceLines() : null);
		var hiddenTuples = visModel.get_hiddenTuples();
		var filteredTuples = visModel.get_filteredTuples();
		var sceneRect = $tab_PaneTableViewModel.$getSceneRect(visModel);
		scene.setSceneData(scenePresModel, selectionsModel, impliedSelectionModel, brushingsModel, colorDictionary, hiddenTuples, filteredTuples, visModel.get_runtimeData(), refLinesModel, sceneRect);
		if (ss.isValue(visModel.get_runtimeData())) {
			scene.setLabelInfo(visModel.get_runtimeData(), scenePresModel.currentPage);
		}
		scene.setIsTargetOfBrushingAction(visModel.get_isBrushedFromAction());
		scene.setEmptyHighlightFogAll(visModel.get_emptyHighlightFogAll());
	};
	$tab_PaneTableViewModel.$hasTupleDifference = function PaneTableViewModel$HasTupleDifference(selectionsDiff, selectionsModel, impliedSelectionModel) {
		switch (selectionsDiff.get_reason()) {
			case 1: {
				if (selectionsModel.hasTupleSelection()) {
					return true;
				}
				return ss.isValue(impliedSelectionModel) && impliedSelectionModel.get_selectionType() === 'tuples' && impliedSelectionModel.get_ids().length > 0;
			}
			case 2: {
				return selectionsDiff.get_invalidateViz() || selectionsDiff.get_objectIds().length > 0;
			}
			default: {
				return false;
			}
		}
	};
	$tab_PaneTableViewModel.$getSceneRect = function PaneTableViewModel$GetSceneRect(visModel) {
		var geometry = visModel.get_geometryModel().pm;
		var sceneRect = null;
		if (ss.isValue(geometry) && ss.isValue(geometry.ri)) {
			var regionInfo = geometry.ri;
			for (var i = 0; i < regionInfo.length; i++) {
				if (regionInfo[i].r === 'viz') {
					sceneRect = { x: 0, y: 0, w: regionInfo[i].w, h: regionInfo[i].h };
					break;
				}
			}
		}
		return sceneRect;
	};
	global.tab.PaneTableViewModel = $tab_PaneTableViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PaneTableViewRegionParts
	var $tab_PaneTableViewRegionParts = function(template) {
		this.$dom = null;
		this.$regionSelectors = null;
		this.$dom = template;
		this.$regionSelectors = this.$createSelectorLookup();
	};
	$tab_PaneTableViewRegionParts.__typeName = 'tab.PaneTableViewRegionParts';
	$tab_PaneTableViewRegionParts.getVisibleGeometryForRegionIfExists = function PaneTableViewRegionParts$GetVisibleGeometryForRegionIfExists(region, vizGeo) {
		switch (region) {
			case 'uleft': {
				return vizGeo.uleftArea;
			}
			case 'uright': {
				return vizGeo.urightArea;
			}
			case 'lleft': {
				return vizGeo.lleftArea;
			}
			case 'lright': {
				return vizGeo.lrightArea;
			}
			case 'xheader': {
				return vizGeo.xheaderArea;
			}
			case 'yheader': {
				return vizGeo.yheaderArea;
			}
			case 'leftaxis': {
				return vizGeo.leftaxisArea;
			}
			case 'rightaxis': {
				return vizGeo.rightaxisArea;
			}
			case 'bottomaxis': {
				return vizGeo.bottomaxisArea;
			}
			case 'topaxis': {
				return vizGeo.topaxisArea;
			}
			case 'viz': {
				return vizGeo.vizArea;
			}
			default: {
				return null;
			}
		}
	};
	$tab_PaneTableViewRegionParts.getRegionRectForRegionIfExists = function PaneTableViewRegionParts$GetRegionRectForRegionIfExists(region, geo) {
		switch (region) {
			case 'uleft': {
				return geo.uleft;
			}
			case 'uright': {
				return geo.uright;
			}
			case 'lleft': {
				return geo.lleft;
			}
			case 'lright': {
				return geo.lright;
			}
			case 'xheader': {
				return geo.xheader;
			}
			case 'yheader': {
				return geo.yheader;
			}
			case 'leftaxis': {
				return geo.leftaxis;
			}
			case 'rightaxis': {
				return geo.rightaxis;
			}
			case 'bottomaxis': {
				return geo.bottomaxis;
			}
			case 'topaxis': {
				return geo.topaxis;
			}
			case 'viz': {
				return geo.viz;
			}
			default: {
				return null;
			}
		}
	};
	global.tab.PaneTableViewRegionParts = $tab_PaneTableViewRegionParts;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.PaneTableViewWebMetrics
	var $tab_PaneTableViewWebMetrics = function() {
	};
	$tab_PaneTableViewWebMetrics.__typeName = 'tab.PaneTableViewWebMetrics';
	$tab_PaneTableViewWebMetrics.createWheelZoomFullyCompleteContext = function PaneTableViewWebMetrics$CreateWheelZoomFullyCompleteContext() {
		return tabBootstrap.MetricsController.createContext('WheelZoomFullyComplete', 32, null);
	};
	global.tab.PaneTableViewWebMetrics = $tab_PaneTableViewWebMetrics;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PolyShapeSelector
	var $tab_PolyShapeSelector = function(svgSize, optimize) {
		this.$dragPoints = null;
		this.$hitTestPoints = null;
		this.$dictOfPointsWithWorldOffset = null;
		this.$optimizeShape = false;
		this.$trail = '';
		this.$closePathEventId = null;
		this.$prevX = null;
		this.$prevY = null;
		$tab_ShapeSelectorBase.call(this, svgSize, $tab_PolyShapeSelector.$htmlTemplate, $tab_PolyShapeSelector.$divClassName);
		this.$dragPoints = [];
		this.$hitTestPoints = [];
		this.$dictOfPointsWithWorldOffset = {};
		this.$optimizeShape = optimize;
		this.$prevX = null;
		this.$prevY = null;
	};
	$tab_PolyShapeSelector.__typeName = 'tab.PolyShapeSelector';
	$tab_PolyShapeSelector.$isTrioOrdered = function PolyShapeSelector$IsTrioOrdered(a, b, c) {
		return a >= b && b >= c || a <= b && b <= c;
	};
	global.tab.PolyShapeSelector = $tab_PolyShapeSelector;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.PolyShapeState
	var $tab_PolyShapeState = function() {
		this.$currentState = null;
		this.$lastState = 0;
		$tab_ShapeStateBase.call(this);
		this.$currentState = [];
		this.$lastState = 0;
	};
	$tab_PolyShapeState.__typeName = 'tab.PolyShapeState';
	global.tab.PolyShapeState = $tab_PolyShapeState;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.RectShapeSelector
	var $tab_RectShapeSelector = function() {
		this.$dragRect = null;
		this.$hitTestRect = null;
		$tab_ShapeSelectorBase.call(this, { x: 0, y: 0, w: 0, h: 0 }, $tab_RectShapeSelector.$htmlTemplate, $tab_RectShapeSelector.$divClassName);
		this.$dragRect = { x: 0, y: 0, w: 0, h: 0 };
		this.$hitTestRect = { x: 0, y: 0, w: 0, h: 0 };
	};
	$tab_RectShapeSelector.__typeName = 'tab.RectShapeSelector';
	global.tab.RectShapeSelector = $tab_RectShapeSelector;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.RectShapeState
	var $tab_RectShapeState = function() {
		this.$currentState = null;
		this.$lastState = null;
		$tab_ShapeStateBase.call(this);
		this.$currentState = { x: 0, y: 0, w: 0, h: 0 };
		this.$lastState = { x: 0, y: 0, w: 0, h: 0 };
	};
	$tab_RectShapeState.__typeName = 'tab.RectShapeState';
	global.tab.RectShapeState = $tab_RectShapeState;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.ReferenceLinesRenderer
	var $tab_ReferenceLinesRenderer = function(canvasElt, context) {
		this.$currentVisualState = 'normal';
		this.$currentFogging = null;
		$tab_MarksRenderer.call(this, canvasElt, context);
	};
	$tab_ReferenceLinesRenderer.__typeName = 'tab.ReferenceLinesRenderer';
	global.tab.ReferenceLinesRenderer = $tab_ReferenceLinesRenderer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.RefLineHitTestLink
	var $tab_RefLineHitTestLink = function(ptvm, sceneInfo) {
		this.$sceneInfo = null;
		this.$hitTestStructureList = null;
		$tab_HitTestLink.call(this, ptvm);
		this.$sceneInfo = sceneInfo;
	};
	$tab_RefLineHitTestLink.__typeName = 'tab.RefLineHitTestLink';
	$tab_RefLineHitTestLink.hitTestRefLines = function RefLineHitTestLink$HitTestRefLines(refLines, selectionRect, isSingleSelect) {
		var bestSingleHitResult = $tab_HitTestResult.createEmptyHitTestResult();
		var multiSelectResults = [];
		for (var $t1 = 0; $t1 < refLines.length; $t1++) {
			var refLine = refLines[$t1];
			var referenceLineHit = $tab_RefLineHitTestLink.hitTestRefLine(refLine.drawItems, selectionRect, isSingleSelect);
			if (referenceLineHit.get_hitType() !== 0) {
				if (isSingleSelect) {
					bestSingleHitResult = $tab_HitTestResult.tieBreak(referenceLineHit, bestSingleHitResult);
				}
				else {
					multiSelectResults.push(referenceLineHit);
				}
			}
		}
		return $tab_RefLineHitTestLink.$resolveHitTestReults(isSingleSelect, bestSingleHitResult, multiSelectResults);
	};
	$tab_RefLineHitTestLink.$getRefParts = function RefLineHitTestLink$GetRefParts(drawItems, refPart) {
		var toRet = [];
		for (var $t1 = 0; $t1 < drawItems.length; $t1++) {
			var drawItem = drawItems[$t1];
			if (drawItem.type === 'clip-rect' && refPart === 'refpart-clip-rect') {
				toRet.push(drawItem);
			}
			else if (drawItem.type === 'draw-group') {
				var drawGroup = drawItem;
				var drawText = _.find(drawGroup.drawItems, function(iterator) {
					return iterator.type === 'draw-text';
				});
				if (refPart === 'refpart-text' && ss.isValue(drawText)) {
					toRet.push(drawItem);
				}
				else if (refPart === 'refpart-geom' && ss.isNullOrUndefined(drawText)) {
					toRet.push(drawItem);
				}
			}
		}
		return toRet;
	};
	$tab_RefLineHitTestLink.$hitTestRefLineGeom = function RefLineHitTestLink$HitTestRefLineGeom(drawItems, geomType, selectionRect, isSingleSelect, groupId) {
		var expandedSelectionRect = tab.RectXYUtil.dialate(selectionRect, $tab_VisualPartsHitTest.visualPartNearHitTestExpansionPixels);
		var lineWidth = 1;
		var toRet = new $tab_HitTestResult.$ctor1(groupId, geomType, 0);
		for (var $t1 = 0; $t1 < drawItems.length; $t1++) {
			var drawItem = drawItems[$t1];
			switch (drawItem.type) {
				case 'draw-pen': {
					var drawPen = drawItem;
					if (ss.isValue(drawPen.strokeWidth)) {
						lineWidth = drawPen.strokeWidth;
					}
					break;
				}
				case 'draw-polyline':
				case 'draw-fill-rect': {
					var drawPoints = drawItem;
					var doNotRenderOverlay = ss.isValue(drawPoints.useForOverlayHitTest) && !drawPoints.useForOverlayHitTest;
					var pt1 = { x: drawPoints.points[0], y: drawPoints.points[1] };
					var pt2 = { x: drawPoints.points[2], y: drawPoints.points[3] };
					var refLineRect = tab.RectXYUtil.rectXYFromCorners$1(pt1, pt2);
					if (drawItem.type === 'draw-polyline') {
						if (lineWidth < 3) {
							refLineRect = tab.RectXYUtil.dialate(refLineRect, 1);
						}
					}
					var nearHit = isSingleSelect && tab.RectXYUtil.intersectsWith(expandedSelectionRect, refLineRect);
					var exactHit = (!isSingleSelect || nearHit) && tab.RectXYUtil.intersectsWith(selectionRect, refLineRect);
					if (exactHit) {
						toRet = new $tab_HitTestResult.$ctor1(groupId, geomType, 3);
						if (doNotRenderOverlay) {
							toRet.doNotRenderOverlay();
						}
						return toRet;
					}
					if (nearHit) {
						toRet = new $tab_HitTestResult.$ctor1(groupId, geomType, 2);
						if (doNotRenderOverlay) {
							toRet.doNotRenderOverlay();
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		}
		return toRet;
	};
	$tab_RefLineHitTestLink.hitTestRefLine = function RefLineHitTestLink$HitTestRefLine(drawItems, selectionRect, isSingleSelect) {
		var currentBest = $tab_HitTestResult.createEmptyHitTestResult();
		var textItems = $tab_RefLineHitTestLink.$getRefParts(drawItems, 'refpart-text');
		currentBest = $tab_RefLineHitTestLink.$hitTestDrawItemPresModels(textItems, 5, selectionRect, isSingleSelect, currentBest);
		if (currentBest.get_hitType() === 3) {
			return currentBest;
		}
		var lineItems = $tab_RefLineHitTestLink.$getRefParts(drawItems, 'refpart-geom');
		currentBest = $tab_RefLineHitTestLink.$hitTestDrawItemPresModels(lineItems, 4, selectionRect, isSingleSelect, currentBest);
		return currentBest;
	};
	$tab_RefLineHitTestLink.$hitTestDrawItemPresModels = function RefLineHitTestLink$HitTestDrawItemPresModels(items, itemType, selectionRect, isSingleSelect, currentBest) {
		for (var i = items.length - 1; i >= 0; i--) {
			var group = items[i];
			var hitTestResult = $tab_RefLineHitTestLink.$hitTestRefLineGeom(group.drawItems, itemType, selectionRect, isSingleSelect, group.objectId);
			if (hitTestResult.get_hitType() === 3) {
				return hitTestResult;
			}
			if (hitTestResult.get_hitType() === 2 && currentBest.get_hitType() === 0) {
				currentBest = hitTestResult;
			}
		}
		return currentBest;
	};
	$tab_RefLineHitTestLink.$updateBestSingleHitTestResult = function RefLineHitTestLink$UpdateBestSingleHitTestResult(bestSingleHitResult, hitTestResult) {
		if (hitTestResult.get_hitType() === 3) {
			return hitTestResult;
		}
		if (hitTestResult.get_hitType() === 2 && bestSingleHitResult.get_hitType() === 0) {
			return hitTestResult;
		}
		return bestSingleHitResult;
	};
	$tab_RefLineHitTestLink.$singleHitTestRefLine = function RefLineHitTestLink$SingleHitTestRefLine(refLineNode, p) {
		var toRet = $tab_HitTestResult.createEmptyHitTestResult();
		if (refLineNode.get_nodeType() === 8) {
			toRet = $tab_RefLineHitTestLink.$doNearHitTest(refLineNode, p);
		}
		if (toRet.get_hitType() === 2 || refLineNode.get_nodeType() === 9) {
			var exactHit = $tab_RefLineHitTestLink.$doExactHitTest(refLineNode, p);
			if (exactHit.get_hitType() === 3) {
				toRet = exactHit;
			}
		}
		return toRet;
	};
	$tab_RefLineHitTestLink.$doNearHitTest = function RefLineHitTestLink$DoNearHitTest(refLineNode, p) {
		var toRet = $tab_HitTestResult.createEmptyHitTestResult();
		var expandedSelectionRect = tab.RectXYUtil.dialate({ x: p.x, y: p.y, w: 0, h: 0 }, $tab_RefLineHitTestLink.$nearHitTestExpansion);
		var nearHit = tab.RectXYUtil.intersectsWithMoreThanSharedEdge(refLineNode.get_boundingBox(), expandedSelectionRect);
		if (nearHit) {
			toRet = new $tab_HitTestResult.$ctor1(refLineNode.get_objectId(), 6, 2);
		}
		return toRet;
	};
	$tab_RefLineHitTestLink.$doExactHitTest = function RefLineHitTestLink$DoExactHitTest(refLineNode, p) {
		var toRet = $tab_HitTestResult.createEmptyHitTestResult();
		var expandedSelectionRect = tab.RectXYUtil.dialate({ x: p.x, y: p.y, w: 0, h: 0 }, $tab_RefLineHitTestLink.$exactHitTestExpansion);
		var exactHit = tab.RectXYUtil.intersectsWithMoreThanSharedEdge(refLineNode.get_boundingBox(), expandedSelectionRect);
		if (exactHit) {
			toRet = new $tab_HitTestResult.$ctor1(refLineNode.get_objectId(), 6, 3);
		}
		return toRet;
	};
	$tab_RefLineHitTestLink.$resolveHitTestReults = function RefLineHitTestLink$ResolveHitTestReults(isSingleSelect, bestSingleHitResult, multiSelectResults) {
		if (isSingleSelect) {
			if (bestSingleHitResult.get_hitType() === 0) {
				return [$tab_HitTestResult.createEmptyHitTestResult()];
			}
			return [bestSingleHitResult];
		}
		return multiSelectResults;
	};
	global.tab.RefLineHitTestLink = $tab_RefLineHitTestLink;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.RegionGeometry
	var $tab_RegionGeometry = function(geo, containerWidth, containerHeight) {
		this.$neededWidth = 0;
		this.$neededHeight = 0;
		this.$scrollableWidth = 0;
		this.$scrollableHeight = 0;
		this.$scrollXLeft = 0;
		this.$scrollYTop = 0;
		this.$widthScrollOffset = 0;
		this.$heightScrollOffset = 0;
		this.$viewWidth = 0;
		this.$viewHeight = 0;
		this.$scrollWidth = 0;
		this.$scrollHeight = 0;
		this.$overallWidth = 0;
		this.$overallHeight = 0;
		if (ss.isValue(geo.title)) {
			this.$neededHeight = $tab_RegionGeometry.$updateNeededHeight(this.$neededHeight, geo.title);
		}
		if (ss.isValue(geo.xheader)) {
			this.$scrollXLeft = geo.xheader.x;
			this.$scrollableWidth = geo.xheader.w;
			this.$neededHeight = $tab_RegionGeometry.$updateNeededHeight(this.$neededHeight, geo.xheader);
		}
		if (ss.isValue(geo.bottomaxis)) {
			this.$scrollXLeft = geo.bottomaxis.x;
			this.$scrollableWidth = geo.bottomaxis.w;
			this.$neededHeight = $tab_RegionGeometry.$updateNeededHeight(this.$neededHeight, geo.bottomaxis);
		}
		if (ss.isValue(geo.topaxis)) {
			this.$neededHeight = $tab_RegionGeometry.$updateNeededHeight(this.$neededHeight, geo.topaxis);
		}
		if (ss.isValue(geo.viz)) {
			this.$scrollXLeft = geo.viz.x;
			this.$scrollableWidth = geo.viz.w;
			this.$neededHeight = $tab_RegionGeometry.$updateNeededHeight(this.$neededHeight, geo.viz);
		}
		if (ss.isValue(geo.caption)) {
			this.$neededHeight = $tab_RegionGeometry.$updateNeededHeight(this.$neededHeight, geo.caption);
		}
		if (ss.isValue(geo.yheader)) {
			this.$scrollYTop = geo.yheader.y;
			this.$scrollableHeight = geo.yheader.h;
			this.$neededWidth = $tab_RegionGeometry.$updateNeededWidth(this.$neededWidth, geo.yheader);
		}
		if (ss.isValue(geo.leftaxis)) {
			this.$scrollYTop = geo.leftaxis.y;
			this.$scrollableHeight = geo.leftaxis.h;
			this.$neededWidth = $tab_RegionGeometry.$updateNeededWidth(this.$neededWidth, geo.leftaxis);
		}
		if (ss.isValue(geo.rightaxis)) {
			this.$neededWidth = $tab_RegionGeometry.$updateNeededWidth(this.$neededWidth, geo.rightaxis);
		}
		if (ss.isValue(geo.viz)) {
			this.$scrollYTop = geo.viz.y;
			this.$scrollableHeight = geo.viz.h;
			this.$neededWidth = $tab_RegionGeometry.$updateNeededWidth(this.$neededWidth, geo.viz);
		}
		if (this.$scrollableHeight > 0) {
			var neededHeightPlusScrollbar = this.$neededHeight;
			if (this.$neededWidth > containerWidth) {
				neededHeightPlusScrollbar += tab.Metrics.get_scrollH();
			}
			if (neededHeightPlusScrollbar > containerHeight) {
				this.$scrollWidth = tab.Metrics.get_scrollW();
			}
		}
		if (this.$scrollableWidth > 0 && this.$neededWidth > containerWidth) {
			this.$scrollHeight = tab.Metrics.get_scrollH();
		}
		if (BrowserSupport.BrowserSupport.IsIE() && this.$scrollWidth > 0) {
			this.$scrollWidth += 1;
		}
		if (BrowserSupport.BrowserSupport.IsIE() && this.$scrollHeight > 0) {
			this.$scrollHeight += 1;
		}
		if (this.$scrollableHeight > 0) {
			var fixedHeight = this.$neededHeight - this.$scrollableHeight;
			this.$viewHeight = containerHeight - fixedHeight - this.$scrollHeight;
			this.$viewHeight = Math.min(this.$scrollableHeight, this.$viewHeight);
			this.$heightScrollOffset = this.$scrollableHeight - this.$viewHeight;
		}
		if (this.$scrollableWidth > 0) {
			var fixedWidth = this.$neededWidth - this.$scrollableWidth;
			this.$viewWidth = containerWidth - fixedWidth - this.$scrollWidth;
			this.$viewWidth = Math.min(this.$scrollableWidth, this.$viewWidth);
			this.$widthScrollOffset = this.$scrollableWidth - this.$viewWidth;
		}
		this.$overallHeight = Math.min(this.$neededHeight - this.$heightScrollOffset, containerHeight);
		this.$overallWidth = Math.min(this.$neededWidth - this.$widthScrollOffset, containerWidth);
		if (this.$viewHeight < 0) {
			this.$viewHeight = 0;
		}
		if (this.$viewWidth < 0) {
			this.$viewWidth = 0;
		}
	};
	$tab_RegionGeometry.__typeName = 'tab.RegionGeometry';
	$tab_RegionGeometry.$updateNeededWidth = function RegionGeometry$UpdateNeededWidth(currentNeededWidth, regionToConsider) {
		var rightSideOfRegion = regionToConsider.x + regionToConsider.w;
		return Math.max(currentNeededWidth, rightSideOfRegion);
	};
	$tab_RegionGeometry.$updateNeededHeight = function RegionGeometry$UpdateNeededHeight(currentNeededHeight, regionToConsider) {
		var bottomOfRegion = regionToConsider.y + regionToConsider.h;
		return Math.max(currentNeededHeight, bottomOfRegion);
	};
	global.tab.RegionGeometry = $tab_RegionGeometry;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.RegionPositionPair
	var $tab_RegionPositionPair = function() {
		this.position = null;
		this.imageRegion = null;
	};
	$tab_RegionPositionPair.__typeName = 'tab.RegionPositionPair';
	global.tab.RegionPositionPair = $tab_RegionPositionPair;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.RuntimeUIModule
	var $tab_RuntimeUIModule = function() {
	};
	$tab_RuntimeUIModule.__typeName = 'tab.RuntimeUIModule';
	$tab_RuntimeUIModule.get_instance = function RuntimeUIModule$get_Instance() {
		if (ss.isNullOrUndefined($tab_RuntimeUIModule.$module)) {
			tab.ModuleManager.load($tab_IRuntimeUIModule).call(null, []).done(function(newModule) {
				$tab_RuntimeUIModule.$module = newModule;
			});
		}
		return $tab_RuntimeUIModule.$module;
	};
	global.tab.RuntimeUIModule = $tab_RuntimeUIModule;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.SceneInfo
	var $tab_SceneInfo = function() {
		this.$hashToImageEltMap = new Map();
		this.$paneDrawInfoMap = new Map();
		this.$markBoundingBoxes = new Map();
		this.$labelBoundingBoxes = new Map();
		this.$fullMarkBoundingBoxes = new Map();
		this.$isTargetOfBrushingAction = false;
		this.$emptyHighlightFogAll = false;
		this.$impliedSelection = null;
		this.$hiddenTuples = new Map();
		this.$filteredTuples = new Map();
		this.$markGeometries = new Map();
		this.$runtimeData = null;
		this.scene = null;
		this.customShapes = null;
		this.brushings = null;
		this.selections = null;
		this.sceneUserPaneInfo = null;
		this.colorModel = null;
		this.$1$ReferenceLinesField = null;
		this.$currentPage = 0;
		this.$numPages = 0;
		this.$1$SceneRectField = null;
		this.customShapes = [];
		this.$currentPage = 0;
		this.$numPages = 0;
	};
	$tab_SceneInfo.__typeName = 'tab.SceneInfo';
	$tab_SceneInfo.getPaneMarksKey$1 = function SceneInfo$GetPaneMarksKey(paneKey, rowCol, paneIndex) {
		return paneKey + '_' + rowCol['columnIndex'.toString()] + '_' + rowCol['rowIndex'.toString()] + '_' + paneIndex;
	};
	$tab_SceneInfo.getPaneMarksKey = function SceneInfo$GetPaneMarksKey(paneMarksInfo) {
		return $tab_SceneInfo.getPaneMarksKey$1(paneMarksInfo.get_paneKey(), paneMarksInfo.get_paneId(), paneMarksInfo.get_paneIndex());
	};
	$tab_SceneInfo.extractCustomShapes = function SceneInfo$ExtractCustomShapes(runtimeData) {
		var customShapeIds = [];
		if (!ss.isValue(runtimeData)) {
			return customShapeIds;
		}
		var dataStore = runtimeData.get_finalDataStore();
		var pdMarks = dataStore.PDMarks;
		var $t1 = _.keys(pdMarks);
		for (var $t2 = 0; $t2 < $t1.length; $t2++) {
			var pdMarkKey = $t1[$t2];
			var markLayoutOutput = pdMarks[pdMarkKey];
			var encodings = markLayoutOutput.Encodings;
			if (ss.isValue(encodings.shape_id)) {
				var shapeIds = encodings.shape_id;
				for (var $t3 = 0; $t3 < shapeIds.length; $t3++) {
					var shapeId = shapeIds[$t3];
					if (ss.isValue(shapeId) && tab.SceneDataUtil.isCustomShape(shapeId)) {
						customShapeIds.push(shapeId);
					}
				}
			}
			var markLayoutData = markLayoutOutput.MarkLayoutData;
			var parameters = markLayoutData.Parameters;
			if (ss.isValue(parameters.shape_id)) {
				var shapeId1 = parameters.shape_id;
				if (tab.SceneDataUtil.isCustomShape(shapeId1)) {
					customShapeIds.push(shapeId1);
				}
			}
		}
		return customShapeIds;
	};
	$tab_SceneInfo.$addBoundingBoxesForPane = function SceneInfo$AddBoundingBoxesForPane(paneDrawInfo, boxesToAdd, bboxCollection) {
		var offsetX = paneDrawInfo.paneRect.x;
		var offsetY = paneDrawInfo.paneRect.y;
		boxesToAdd.forEach(function(rect, key) {
			tab.RectXYUtil.offsetRectXYInPlace(rect, offsetX, offsetY);
			bboxCollection.set(key, rect);
		});
	};
	global.tab.SceneInfo = $tab_SceneInfo;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.SceneUserPaneInfo
	var $tab_SceneUserPaneInfo = function(userPaneInfoPM) {
		$tab_SceneUserPaneInfo.$ctor1.call(this, userPaneInfoPM.xPixelOffsets, userPaneInfoPM.yPixelOffsets);
	};
	$tab_SceneUserPaneInfo.__typeName = 'tab.SceneUserPaneInfo';
	$tab_SceneUserPaneInfo.$ctor1 = function(pixelsX, pixelsY) {
		this.$pixelsX = null;
		this.$pixelsY = null;
		this.$hasPanesX = false;
		this.$hasPanesY = false;
		this.$colCount = 0;
		this.$rowCount = 0;
		this.$pixelsX = pixelsX;
		this.$pixelsY = pixelsY;
		this.$hasPanesX = ss.isValue(pixelsX) && pixelsX.length > 0;
		this.$hasPanesY = ss.isValue(pixelsY) && pixelsY.length > 0;
		this.$colCount = (this.$hasPanesX ? (pixelsX.length - 1) : 1);
		this.$rowCount = (this.$hasPanesY ? (pixelsY.length - 1) : 1);
	};
	global.tab.SceneUserPaneInfo = $tab_SceneUserPaneInfo;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ServerRenderVizHitTestDebouncer
	var $tab_ServerRenderVizHitTestDebouncer = function(paneTable, region) {
		$tab_VizHitTestDebouncer.call(this, paneTable, region);
	};
	$tab_ServerRenderVizHitTestDebouncer.__typeName = 'tab.ServerRenderVizHitTestDebouncer';
	global.tab.ServerRenderVizHitTestDebouncer = $tab_ServerRenderVizHitTestDebouncer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.ShapeDependencyManager
	var $tab_ShapeDependencyManager = function(shapeLoadedCallback) {
		this.$shapes = new Set();
		this.$shapeLoadedCallback = null;
		this.$shapeLoadedCallback = shapeLoadedCallback;
		tab.ApplicationModel.get_instance().get_shapeManager().add_shapeLoaded(ss.mkdel(this, this.onShapeLoaded));
	};
	$tab_ShapeDependencyManager.__typeName = 'tab.ShapeDependencyManager';
	global.tab.ShapeDependencyManager = $tab_ShapeDependencyManager;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ShapeSelectorBase
	var $tab_ShapeSelectorBase = function(svgSize, htmlTemplate, divClassName) {
		this.$svgWidth = null;
		this.$svgHeight = null;
		this.$htmlTemplate = null;
		this.$divClassName = null;
		this.$dom = null;
		this.$pi = null;
		this.$latestPoint = { x: 0, y: 0 };
		this.$dragStart = { x: 0, y: 0 };
		this.$connectNodePos = { x: 0, y: 0, w: 0, h: 0 };
		this.$totalScrollOffset = { x: 0, y: 0 };
		this.$autoScrollOffset = { x: 0, y: 0 };
		this.$svgWidth = (ss.isNullOrUndefined(svgSize) ? '0' : svgSize.w.toString());
		this.$svgHeight = (ss.isNullOrUndefined(svgSize) ? '0' : svgSize.h.toString());
		this.$htmlTemplate = htmlTemplate;
		this.$divClassName = divClassName;
	};
	$tab_ShapeSelectorBase.__typeName = 'tab.ShapeSelectorBase';
	global.tab.ShapeSelectorBase = $tab_ShapeSelectorBase;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ShapeStateBase
	var $tab_ShapeStateBase = function() {
	};
	$tab_ShapeStateBase.__typeName = 'tab.ShapeStateBase';
	global.tab.ShapeStateBase = $tab_ShapeStateBase;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.ShapeUtil
	var $tab_ShapeUtil = function() {
	};
	$tab_ShapeUtil.__typeName = 'tab.ShapeUtil';
	$tab_ShapeUtil.generateSelectedUnderCustomShape = function ShapeUtil$GenerateSelectedUnderCustomShape(image, color, borderSize, scaleWidth, scaleHeight) {
		var element = $tab_ShapeUtil.colorTransformImage(image, color, scaleWidth, scaleHeight);
		var selected = document.createElement('canvas');
		var sizeIncrease = borderSize * 2;
		selected.width = Math.ceil(scaleWidth + sizeIncrease);
		selected.height = Math.ceil(scaleHeight + sizeIncrease);
		var context = ss.cast(selected.getContext('2d'), CanvasRenderingContext2D);
		context.drawImage(element, 0, 0, scaleWidth, scaleHeight);
		context.drawImage(element, borderSize, 0, scaleWidth, scaleHeight);
		context.drawImage(element, sizeIncrease, 0, scaleWidth, scaleHeight);
		context.drawImage(element, sizeIncrease, borderSize, scaleWidth, scaleHeight);
		context.drawImage(element, sizeIncrease, sizeIncrease, scaleWidth, scaleHeight);
		context.drawImage(element, borderSize, sizeIncrease, scaleWidth, scaleHeight);
		context.drawImage(element, 0, sizeIncrease, scaleWidth, scaleHeight);
		context.drawImage(element, 0, borderSize, scaleWidth, scaleHeight);
		return selected;
	};
	$tab_ShapeUtil.generateOverlayForShape = function ShapeUtil$GenerateOverlayForShape(image, color, overlayBorderSize, scaleWidth, scaleHeight) {
		var element = $tab_ShapeUtil.generateSelectedUnderCustomShape(image, color, overlayBorderSize, scaleWidth, scaleHeight);
		var context = ss.cast(element.getContext('2d'), CanvasRenderingContext2D);
		context.globalCompositeOperation = 'destination-out';
		context.drawImage(image, overlayBorderSize, overlayBorderSize, scaleWidth, scaleHeight);
		return element;
	};
	$tab_ShapeUtil.colorTransformImage = function ShapeUtil$ColorTransformImage(image, color, width, height) {
		var element = $tab_ShapeUtil.generateCanvasAndPrescaleAsNeeded(image, width, height);
		var context = ss.cast(element.getContext('2d'), CanvasRenderingContext2D);
		var pixels = context.getImageData(0, 0, element.width, element.height);
		var numBytes = pixels.data.length;
		for (var i = 0; i < numBytes; i += 4) {
			if (pixels.data[i + 3] > 0) {
				pixels.data[i] = color.get_r();
				pixels.data[i + 1] = color.get_g();
				pixels.data[i + 2] = color.get_b();
			}
		}
		context.putImageData(pixels, 0, 0);
		return element;
	};
	$tab_ShapeUtil.applyFoggingToImage = function ShapeUtil$ApplyFoggingToImage(image, fogBackgroundColor, fogBlendAlpha, width, height) {
		var element = $tab_ShapeUtil.generateCanvasAndPrescaleAsNeeded(image, width, height);
		var context = ss.cast(element.getContext('2d'), CanvasRenderingContext2D);
		var pixels = context.getImageData(0, 0, element.width, element.height);
		for (var i = 0; i < pixels.data.length; i += 4) {
			if (pixels.data[i + 3] > 0) {
				pixels.data[i] = Math.round(fogBackgroundColor.get_r() + pixels.data[i] * fogBlendAlpha);
				pixels.data[i + 1] = Math.round(fogBackgroundColor.get_g() + pixels.data[i + 1] * fogBlendAlpha);
				pixels.data[i + 2] = Math.round(fogBackgroundColor.get_b() + pixels.data[i + 2] * fogBlendAlpha);
			}
		}
		context.putImageData(pixels, 0, 0);
		return element;
	};
	$tab_ShapeUtil.generateCanvasAndPrescaleAsNeeded = function ShapeUtil$GenerateCanvasAndPrescaleAsNeeded(image, finalWidth, finalHeight) {
		var element = document.createElement('canvas');
		if (!ss.isValue(image)) {
			return element;
		}
		if (image.width > finalWidth * 2 && image.height > finalHeight * 2) {
			element.width = Math.max(ss.Int32.div(image.naturalWidth, 2), 1);
			element.height = Math.max(ss.Int32.div(image.naturalHeight, 2), 1);
		}
		else {
			element.width = image.naturalWidth;
			element.height = image.naturalHeight;
		}
		var context = ss.cast(element.getContext('2d'), CanvasRenderingContext2D);
		context.drawImage(image, 0, 0, element.width, element.height);
		return element;
	};
	global.tab.ShapeUtil = $tab_ShapeUtil;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.SimpleRegionCanvasView
	var $tab_SimpleRegionCanvasView = function(viewModel, domNode, paneTableVM) {
		this.$paneTableVM = null;
		ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_VisualListViewModel]).call(this, viewModel, domNode, (paneTableVM.get_visualModel().get_backgroundColor().get_isOpaque() ? 'opaque' : 'transparent'));
		var colors = (ss.isValue(paneTableVM.get_scene()) ? paneTableVM.get_scene().colorModel : $tab_InteractionColorModel.defaultColors);
		this.renderer = new $tab_DisplayList2DRenderer(this.canvasElt, this.context, colors);
		this.$paneTableVM = paneTableVM;
		this.$paneTableVM.add_propertyChanged(ss.mkdel(this, this.$handleImageLoadedChanged));
	};
	$tab_SimpleRegionCanvasView.__typeName = 'tab.SimpleRegionCanvasView';
	global.tab.SimpleRegionCanvasView = $tab_SimpleRegionCanvasView;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Views.SmoothTooltipsOnboardingComponent
	var $tab_SmoothTooltipsOnboardingComponent = function(props, context) {
		this.$boundOnTransitionEnd = null;
		this.$pendingProps = null;
		this.$animationIsInProgress = false;
		this.$forceTransitionEndTimeoutId = 0;
		React.Component.call(this, props, context);
		this.$boundOnTransitionEnd = ss.mkdel(this, function(e) {
			this.$onTransitionEnd();
		});
		this.state = { visible: props.visible, transitionDurationMs: props.transitionDurationMs, transitionDelayMs: props.transitionDelayMs, animationId: 0 };
	};
	$tab_SmoothTooltipsOnboardingComponent.__typeName = 'tab.SmoothTooltipsOnboardingComponent';
	global.tab.SmoothTooltipsOnboardingComponent = $tab_SmoothTooltipsOnboardingComponent;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ViewModels.SmoothTooltipsOnboardingViewModel
	var $tab_SmoothTooltipsOnboardingViewModel = function() {
		this.$visible = false;
		this.$transitionDurationMs = 0;
		this.$transitionDelayMs = 0;
		ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
	};
	$tab_SmoothTooltipsOnboardingViewModel.__typeName = 'tab.SmoothTooltipsOnboardingViewModel';
	global.tab.SmoothTooltipsOnboardingViewModel = $tab_SmoothTooltipsOnboardingViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.TiledViewerRegion
	var $tab_TiledViewerRegion = function(regionPart, domNode, allowPanZoomActions, sheetID, viewModel, toolModeViewModel) {
		this.$imagesContainer = null;
		this.backgroundMap = $tab_TiledViewerRegion.$createMapControl();
		this.disposables = new tab.DisposableHolder();
		this.allowPanZoomActions = null;
		this.connectNode = null;
		this.domPanZoomRect = null;
		this.domDragImage = null;
		this.domDragMask = null;
		this.regionContent = new $tab_EmptyContentProvider();
		this.scroller = null;
		this.isScrolling = false;
		this.wasScrolling = false;
		this.waitingOnPanZoomServerResponse = null;
		this.paneTableViewModel = null;
		this.backgroundDiv = null;
		this.resetIsWaitingOnTransition = false;
		this.zoomAnimationProtectionGlass = null;
		this.$regionPart = null;
		this.$sheetid = null;
		this.$shapeSelector = null;
		this.$regionSize = null;
		this.$domDragTransformed = false;
		this.$domDragShown = false;
		this.$visualObjectBoundsComputerAndHitTester = null;
		this.$toolModeViewModel = null;
		this.$regionPart = regionPart;
		this.connectNode = $(domNode);
		this.backgroundDiv = this.connectNode.find('.tvBackgroundContainer');
		this.$imagesContainer = this.connectNode.find('.tvimagesContainer');
		this.allowPanZoomActions = allowPanZoomActions;
		this.domPanZoomRect = new $tab_RectShapeSelector();
		this.$shapeSelector = new $tab_RectShapeSelector();
		this.$sheetid = sheetID;
		this.paneTableViewModel = viewModel;
		this.waitingOnPanZoomServerResponse = 'normal';
		this.$toolModeViewModel = toolModeViewModel;
		if (this.$regionPart === 'viz') {
			this.makeDomDragImage();
		}
		this.get_toolModeViewModel().add_toolbarToolModeUpdated(ss.mkdel(this, this.updateForToolMode));
		this.$visualObjectBoundsComputerAndHitTester = new $tab_VisualObjectBoundsComputerAndHitTester();
	};
	$tab_TiledViewerRegion.__typeName = 'tab.TiledViewerRegion';
	$tab_TiledViewerRegion.$createAnchorZoomTransform = function TiledViewerRegion$CreateAnchorZoomTransform(paneInfo, anchorPoint, zoomFactor) {
		var scale = 1 / zoomFactor;
		var xCoordPane = ((paneInfo.x > 0) ? (anchorPoint.x % paneInfo.x) : anchorPoint.x);
		var yCoordPane = ((paneInfo.y > 0) ? (anchorPoint.y % paneInfo.y) : anchorPoint.y);
		var anchorPointPane = { x: xCoordPane, y: yCoordPane };
		var transform = { scaleX: scale, scaleY: scale, time: $tab_TiledViewerRegion.zoomToAnchorAnimationTime, transformOrigin: anchorPointPane, scale: 1, translateX: 0, translateY: 0 };
		return transform;
	};
	$tab_TiledViewerRegion.$createZoomOnPointTransform = function TiledViewerRegion$CreateZoomOnPointTransform(paneInfo, point, scaleX, scaleY) {
		var x = ((scaleX < 1) ? -1 : ((scaleX > 1) ? 1 : 0));
		var y = ((scaleY < 1) ? -1 : ((scaleY > 1) ? 1 : 0));
		var direction = { x: x, y: y };
		var paneCenter = $tab_TiledViewerRegion.getCenterPoint(paneInfo);
		var translateX = Math.floor((paneCenter.x - point.x) * direction.x * scaleX);
		var translateY = Math.floor((paneCenter.y - point.y) * direction.y * scaleY);
		var transform = { translateX: translateX, translateY: translateY, scaleX: scaleX, scaleY: scaleY, time: $tab_TiledViewerRegion.zoomAnimationTime, scale: 1, transformOrigin: null };
		return transform;
	};
	$tab_TiledViewerRegion.getCenterPoint = function TiledViewerRegion$GetCenterPoint(rect) {
		var x = Math.floor(rect.w / 2) + rect.x;
		var y = Math.floor(rect.h / 2) + rect.y;
		return { x: x, y: y };
	};
	$tab_TiledViewerRegion.getCenterPointFromRectXY = function TiledViewerRegion$GetCenterPointFromRectXY(rect) {
		var x = Math.floor(rect.w / 2) + rect.x;
		var y = Math.floor(rect.h / 2) + rect.y;
		return { x: x, y: y };
	};
	$tab_TiledViewerRegion.getCanvasElement = function TiledViewerRegion$GetCanvasElement(parent) {
		if (tab.FeatureFlags.isEnabled('MapboxVector')) {
			var $t1 = parent.find('.tabCanvas').get(0);
			return ss.cast($t1, ss.isValue($t1) && (ss.isInstanceOfType($t1, Element) && $t1.tagName === 'CANVAS'));
		}
		var $t2 = parent.find('canvas').get(0);
		return ss.cast($t2, ss.isValue($t2) && (ss.isInstanceOfType($t2, Element) && $t2.tagName === 'CANVAS'));
	};
	$tab_TiledViewerRegion.$createMapControl = function TiledViewerRegion$CreateMapControl() {
		if (tab.FeatureFlags.isEnabled('MapboxVector')) {
			return new $tab_MapboxMapControl();
		}
		return new $tab_LeafletMapControl();
	};
	global.tab.TiledViewerRegion = $tab_TiledViewerRegion;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.TiledViewerRegionMetrics
	var $tab_TiledViewerRegionMetrics = function() {
	};
	$tab_TiledViewerRegionMetrics.__typeName = 'tab.TiledViewerRegionMetrics';
	$tab_TiledViewerRegionMetrics.createMapZoomLocalWorkCompleteContext = function TiledViewerRegionMetrics$CreateMapZoomLocalWorkCompleteContext() {
		return tabBootstrap.MetricsController.createContext('MapZoomLocalWorkComplete', 32, null);
	};
	$tab_TiledViewerRegionMetrics.createMapZoomFullyCompleteContext = function TiledViewerRegionMetrics$CreateMapZoomFullyCompleteContext() {
		return tabBootstrap.MetricsController.createContext('MapZoomFullyComplete', 32, null);
	};
	global.tab.TiledViewerRegionMetrics = $tab_TiledViewerRegionMetrics;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Telemetry.TiledViewerRegionWebMetrics
	var $tab_TiledViewerRegionWebMetrics = function() {
	};
	$tab_TiledViewerRegionWebMetrics.__typeName = 'tab.TiledViewerRegionWebMetrics';
	$tab_TiledViewerRegionWebMetrics.createZoomRectLocalWorkCompleteContext = function TiledViewerRegionWebMetrics$CreateZoomRectLocalWorkCompleteContext() {
		return tabBootstrap.MetricsController.createContext('ZoomRectLocalWorkComplete', 32, null);
	};
	$tab_TiledViewerRegionWebMetrics.createZoomRectFullyCompleteContext = function TiledViewerRegionWebMetrics$CreateZoomRectFullyCompleteContext() {
		return tabBootstrap.MetricsController.createContext('ZoomRectFullyComplete', 32, null);
	};
	$tab_TiledViewerRegionWebMetrics.createPanMapMouseUpFullyCompleteContext = function TiledViewerRegionWebMetrics$CreatePanMapMouseUpFullyCompleteContext() {
		return tabBootstrap.MetricsController.createContext('PanMapMouseUpFullyComplete', 32, null);
	};
	$tab_TiledViewerRegionWebMetrics.createPanMapMouseUpLocalWorkCompleteContext = function TiledViewerRegionWebMetrics$CreatePanMapMouseUpLocalWorkCompleteContext() {
		return tabBootstrap.MetricsController.createContext('PanMapMouseUpLocalWorkComplete', 32, null);
	};
	global.tab.TiledViewerRegionWebMetrics = $tab_TiledViewerRegionWebMetrics;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.TiledWindow
	var $tab_TiledWindow = function(domNode, session, controller, getRequestID, shouldScrollDomNode) {
		this.$domNode = null;
		this.$downloadQueue = null;
		this.$geometry = null;
		this.$session = null;
		this.$imageContainers = null;
		this.$imageNodes = null;
		this.$tilesX = 0;
		this.$tilesY = 0;
		this.$tileSize = null;
		this.$cacheUrl = null;
		this.$tilesNeedingReload = 0;
		this.$getRequestID = null;
		this.$viewController = null;
		this.$topOffset = 0;
		this.$leftOffset = 0;
		this.$shouldScrollDomNode = false;
		this.$firstTileLoad = false;
		this.$1$LoadCompleteField = null;
		this.$getRequestID = getRequestID;
		this.$domNode = domNode;
		this.$session = session;
		this.$viewController = controller;
		this.$shouldScrollDomNode = shouldScrollDomNode;
		this.$geometry = { x: 0, y: 0, w: 0, h: 0, r: '' };
		this.$tileSize = { w: 0, h: 0 };
		this.$downloadQueue = new $tab_DownloadQueue();
		this.$downloadQueue.add_imageLoaded(ss.mkdel(this, this.$onImageLoaded));
		this.$downloadQueue.add_imageTimedOut(ss.mkdel(this, this.$onImageTimedOut));
		this.$downloadQueue.add_complete(ss.mkdel(this, this.$onQueueComplete));
		this.$imageNodes = [];
		this.$imageContainers = $('.tvimagesContainer', this.$domNode);
		this.$firstTileLoad = true;
	};
	$tab_TiledWindow.__typeName = 'tab.TiledWindow';
	global.tab.TiledWindow = $tab_TiledWindow;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ToolModeViewModel
	var $tab_ToolModeViewModel = function(regionPart, lockedPointerToolMode) {
		this.$currentToolbarToolMode = null;
		this.$lockedPointerToolMode = null;
		this.$isAppendMode = false;
		this.$deferredModeChange = null;
		this.$2$ToolbarToolModeUpdatedField = null;
		this.$2$AppendModeUpdatedField = null;
		this.defaultPointerToolMode = null;
		this.currentModifierKeyToolMode = null;
		this.isDeferringModeChanges = false;
		spiff.BaseViewModel.call(this);
		this.set_isAppendMode(false);
		this.isDeferringModeChanges = false;
		if (regionPart === 'viz') {
			this.currentModifierKeyToolMode = 'no-tools';
		}
		this.setLockedPointerToolMode(lockedPointerToolMode);
	};
	$tab_ToolModeViewModel.__typeName = 'tab.ToolModeViewModel';
	global.tab.ToolModeViewModel = $tab_ToolModeViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.TooltipDisabledMode
	var $tab_TooltipDisabledMode = function(contextProvider, visualId) {
		tab.TooltipBaseMode.call(this, 'disabled', contextProvider, visualId);
	};
	$tab_TooltipDisabledMode.__typeName = 'tab.TooltipDisabledMode';
	global.tab.TooltipDisabledMode = $tab_TooltipDisabledMode;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.TooltipOfflineResponsiveMode
	var $tab_TooltipOfflineResponsiveMode = function(contextProvider, visualId, tooltipRegion, changeBehaviorOnMouseStop) {
		$tab_TooltipResponsiveMode.call(this, contextProvider, visualId, tooltipRegion, changeBehaviorOnMouseStop);
	};
	$tab_TooltipOfflineResponsiveMode.__typeName = 'tab.TooltipOfflineResponsiveMode';
	global.tab.TooltipOfflineResponsiveMode = $tab_TooltipOfflineResponsiveMode;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.TooltipResponsiveMode
	var $tab_TooltipResponsiveMode = function(contextProvider, visualId, tooltipRegion, changeBehaviorOnMouseStop) {
		this.$uniqueMouseMoveEventType = null;
		this.$uniqueTouchMoveEventType = null;
		this.$uniqueMouseOutEventType = null;
		this.$tooltipRegion = null;
		this.$mouseHandlerAttached = false;
		this.$changeBehaviorOnMouseStop = false;
		tab.TooltipBaseMode.call(this, 'smooth', contextProvider, visualId);
		var smoothTooltipBehavior = ss.cast(this.get_currentBehavior(), tab.SmoothTooltipBehavior);
		smoothTooltipBehavior.attach();
		smoothTooltipBehavior.add_onMouseStop(ss.mkdel(this, this.$onMouseStop));
		this.$tooltipRegion = tooltipRegion;
		this.$changeBehaviorOnMouseStop = changeBehaviorOnMouseStop;
		this.$uniqueMouseMoveEventType = $tab_TooltipResponsiveMode.$getNewUniqueMouseMoveEventType();
		this.$uniqueTouchMoveEventType = $tab_TooltipResponsiveMode.$getNewUniqueTouchMoveEventType();
		this.$uniqueMouseOutEventType = $tab_TooltipResponsiveMode.$getNewUniqueMouseOutEventType();
		this.$attachMouseHandler();
		this.get_tooltip().add_prePosition(ss.mkdel(this, this.prepareForPositioning));
		this.get_tooltip().add_positionCalculated(ss.mkdel(this, this.handleUbertipButtons));
		this.get_tooltip().add_showed(ss.mkdel(this, this.$onTooltipShowed));
		this.get_tooltip().add_closed(ss.mkdel(this, this.$onTooltipClosed));
	};
	$tab_TooltipResponsiveMode.__typeName = 'tab.TooltipResponsiveMode';
	$tab_TooltipResponsiveMode.$getNewUniqueMouseMoveEventType = function TooltipResponsiveMode$GetNewUniqueMouseMoveEventType() {
		$tab_TooltipResponsiveMode.$uniqueEventTypeCounter++;
		return 'mousemove.TooltipResponsiveMode' + $tab_TooltipResponsiveMode.$uniqueEventTypeCounter;
	};
	$tab_TooltipResponsiveMode.$getNewUniqueTouchMoveEventType = function TooltipResponsiveMode$GetNewUniqueTouchMoveEventType() {
		$tab_TooltipResponsiveMode.$uniqueEventTypeCounter++;
		return 'touchmove.TooltipResponsiveMode' + $tab_TooltipResponsiveMode.$uniqueEventTypeCounter;
	};
	$tab_TooltipResponsiveMode.$getNewUniqueMouseOutEventType = function TooltipResponsiveMode$GetNewUniqueMouseOutEventType() {
		$tab_TooltipResponsiveMode.$uniqueEventTypeCounter++;
		return 'mouseout.TooltipResponsiveMode' + $tab_TooltipResponsiveMode.$uniqueEventTypeCounter;
	};
	global.tab.TooltipResponsiveMode = $tab_TooltipResponsiveMode;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.HitTest.TrendLineHitTestLink
	var $tab_TrendLineHitTestLink = function(ptvm) {
		this.$hitTestStructureList = null;
		$tab_HitTestLink.call(this, ptvm);
	};
	$tab_TrendLineHitTestLink.__typeName = 'tab.TrendLineHitTestLink';
	$tab_TrendLineHitTestLink.hitTestTrendLines = function TrendLineHitTestLink$HitTestTrendLines(trendLineHitTestStructures, selectionRect, isSingleSelect) {
		var bestNearHitResult = $tab_HitTestResult.createEmptyHitTestResult();
		var multiSelectResults = [];
		for (var i = trendLineHitTestStructures.length - 1; i >= 0; i--) {
			var hitTestResult = $tab_TrendLineHitTestLink.$hitTestTrendLine(trendLineHitTestStructures[i], selectionRect, isSingleSelect);
			if (hitTestResult.get_hitType() === 3) {
				if (isSingleSelect) {
					return [hitTestResult];
				}
				else {
					multiSelectResults.push(hitTestResult);
				}
			}
			if (isSingleSelect && hitTestResult.get_hitType() === 2 && bestNearHitResult.get_hitType() === 0) {
				bestNearHitResult = hitTestResult;
			}
		}
		if (isSingleSelect) {
			if (bestNearHitResult.get_hitType() === 0) {
				return [$tab_HitTestResult.createEmptyHitTestResult()];
			}
			return [bestNearHitResult];
		}
		return multiSelectResults;
	};
	$tab_TrendLineHitTestLink.$hitTestTrendLine = function TrendLineHitTestLink$HitTestTrendLine(root, selectionRect, isSingleSelect) {
		var toRet = $tab_HitTestResult.createEmptyHitTestResult();
		if (isSingleSelect) {
			var expandedSelectionRect = tab.RectXYUtil.dialate(selectionRect, $tab_VisualPartsHitTest.visualPartNearHitTestExpansionPixels);
			var nearHitId = $tab_TrendLineHitTestLink.$hitTestTrendLineHelper(root, expandedSelectionRect);
			if (ss.isValue(nearHitId)) {
				toRet = new $tab_HitTestResult.$ctor1(ss.unbox(nearHitId), 3, 2);
			}
		}
		if (toRet.get_hitType() === 2 || !isSingleSelect) {
			var exactHitId = $tab_TrendLineHitTestLink.$hitTestTrendLineHelper(root, selectionRect);
			if (ss.isValue(exactHitId)) {
				toRet = new $tab_HitTestResult.$ctor1(ss.unbox(exactHitId), 3, 3);
			}
		}
		return toRet;
	};
	$tab_TrendLineHitTestLink.$hitTestTrendLineHelper = function TrendLineHitTestLink$HitTestTrendLineHelper(root, selectionRect) {
		var stack = new Array();
		stack.push(root);
		while (stack.length > 0) {
			var node = stack.pop();
			var hit = tab.RectXYUtil.intersectsWith(node.get_boundingBox(), selectionRect);
			if (hit) {
				if (node.get_nodeType() === 4 || node.get_nodeType() === 0) {
					var children = node.get_children();
					children.forEach(function(child) {
						stack.push(child);
					});
				}
				else if (node.get_nodeType() === 5) {
					return node.get_objectId();
				}
			}
		}
		return null;
	};
	global.tab.TrendLineHitTestLink = $tab_TrendLineHitTestLink;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.UserPaneInfo
	var $tab_UserPaneInfo = function(sceneUserPaneInfo, paneDrawInfo) {
		this.$sceneUserPaneInfo = null;
		this.$userPaneCount = 0;
		this.$markOffsets = null;
		this.$markToUserPane = null;
		this.$columns = null;
		this.$rows = null;
		this.$userPaneRectangles = null;
		this.$sceneUserPaneInfo = sceneUserPaneInfo;
		var hasPanesX = sceneUserPaneInfo.$hasPanesX;
		var hasPanesY = sceneUserPaneInfo.$hasPanesY;
		var allocatedUserPaneCount = sceneUserPaneInfo.$rowCount * sceneUserPaneInfo.$colCount;
		this.$markOffsets = new Array(allocatedUserPaneCount + 1);
		this.$userPaneRectangles = new Array(allocatedUserPaneCount);
		this.$columns = (hasPanesX ? new Array(allocatedUserPaneCount) : null);
		this.$rows = (hasPanesY ? new Array(allocatedUserPaneCount) : null);
		this.$markToUserPane = new Array(paneDrawInfo.markCount);
		this.$userPaneCount = this.$computeData(paneDrawInfo);
	};
	$tab_UserPaneInfo.__typeName = 'tab.UserPaneInfo';
	global.tab.UserPaneInfo = $tab_UserPaneInfo;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VisualListViewModel
	var $tab_VisualListViewModel = function(visualListModel, visualId, regionPart, selModel, brushModel) {
		this.$model = null;
		this.$visualId = null;
		this.$regionPart = null;
		this.$selectionModel = null;
		this.$brushingModel = null;
		this.$defaultBackgroundColor = null;
		this.$currHoveredNodeOrAxis = null;
		this.$prevHoveredNodeOrAxis = null;
		spiff.BaseViewModel.call(this);
		this.$model = visualListModel;
		this.$visualId = visualId;
		this.$regionPart = regionPart;
		this.$model.add_newVisualList(ss.mkdel(this, this.handleModelChange));
		if (ss.isValue(selModel)) {
			this.$selectionModel = selModel.nodeSelection;
			this.$selectionModel.add_newSelection(ss.mkdel(this, this.$handleNewSelectionOrNewBrushing));
		}
		if (ss.isValue(brushModel)) {
			this.$brushingModel = brushModel.nodeSelection;
			this.$brushingModel.add_newSelection(ss.mkdel(this, this.$handleNewSelectionOrNewBrushing));
		}
		if (ss.isValue(selModel) || ss.isValue(brushModel)) {
			this.$handleNewSelectionOrNewBrushing();
		}
		var waitForFontsToLoad = ss.mkdel(this, function() {
			this.notifyPropertyChanged(tab.FontNotificationUtil.fontPropertyName);
		});
		tab.ServerFontLoader.get_instance().add_fontPreparationComplete(waitForFontsToLoad);
		this.disposables.add$1(new tab.CallOnDispose(function() {
			tab.ServerFontLoader.get_instance().remove_fontPreparationComplete(waitForFontsToLoad);
		}));
	};
	$tab_VisualListViewModel.__typeName = 'tab.VisualListViewModel';
	global.tab.VisualListViewModel = $tab_VisualListViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VisualObjectBoundsComputerAndHitTester
	var $tab_VisualObjectBoundsComputerAndHitTester = function() {
	};
	$tab_VisualObjectBoundsComputerAndHitTester.__typeName = 'tab.VisualObjectBoundsComputerAndHitTester';
	global.tab.VisualObjectBoundsComputerAndHitTester = $tab_VisualObjectBoundsComputerAndHitTester;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VisualPartsHitTest
	var $tab_VisualPartsHitTest = function() {
	};
	$tab_VisualPartsHitTest.__typeName = 'tab.VisualPartsHitTest';
	global.tab.VisualPartsHitTest = $tab_VisualPartsHitTest;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Rendering.VisualPartTargetState
	var $tab_VisualPartTargetState = function() {
	};
	$tab_VisualPartTargetState.__typeName = 'tab.VisualPartTargetState';
	global.tab.VisualPartTargetState = $tab_VisualPartTargetState;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VisualRegionCanvasView
	var $tab_VisualRegionCanvasView$1 = function(TViewModel) {
		var $type = function(viewModel, domNode, backgroundMode) {
			this.renderer = null;
			this.completeDocSize = { w: 0, h: 0 };
			this.containers = null;
			this.$domNode = null;
			this.$4$LoadCompleteField = null;
			ss.makeGenericType($tab_CanvasView$1, [TViewModel]).call(this, viewModel, backgroundMode);
			this.$domNode = domNode;
			this.containers = $('.tvimagesContainer', this.$domNode);
			this.add_sizeChange(ss.mkdel(this, this.$handleSizeChange));
		};
		ss.registerGenericClassInstance($type, $tab_VisualRegionCanvasView$1, [TViewModel], {
			add_loadComplete: function VisualRegionCanvasView$add_LoadComplete(value) {
				this.$4$LoadCompleteField = ss.delegateCombine(this.$4$LoadCompleteField, value);
			},
			remove_loadComplete: function VisualRegionCanvasView$remove_LoadComplete(value) {
				this.$4$LoadCompleteField = ss.delegateRemove(this.$4$LoadCompleteField, value);
			},
			get_docSize: function VisualRegionCanvasView$get_DocSize() {
				return this.completeDocSize;
			},
			get_hasContent: function VisualRegionCanvasView$get_HasContent() {
				return true;
			},
			destroy: function VisualRegionCanvasView$Destroy() {
				this.dispose();
			},
			dispose: function VisualRegionCanvasView$Dispose() {
				this.remove_sizeChange(ss.mkdel(this, this.$handleSizeChange));
				this.renderer = null;
				ss.makeGenericType($tab_CanvasView$1, [TViewModel]).prototype.dispose.call(this);
			},
			refreshImages: function VisualRegionCanvasView$RefreshImages(tileCacheUrl) {
			},
			reset: function VisualRegionCanvasView$Reset(newGeometry, newTileSize) {
				if (ss.isNullOrUndefined(newGeometry)) {
					return;
				}
				var newSize = { w: newGeometry.w, h: newGeometry.h };
				var docSizeChanged = ss.isValue(this.completeDocSize) && !tab.SizeUtil.equals(newSize, this.completeDocSize);
				this.completeDocSize = newSize;
				this.containers.width(newGeometry.w);
				this.containers.height(newGeometry.h);
				if (docSizeChanged) {
					this.$updateScrollPos();
				}
			},
			copyContent: function VisualRegionCanvasView$CopyContent(destContext) {
				destContext.drawImage1(this.canvasElt, 0, 0);
			},
			redraw: function VisualRegionCanvasView$Redraw() {
				if (!this.get_needsRedraw() && !tab.AnimationUtil.isUpdating() || ss.isNullOrUndefined(this.renderer)) {
					return;
				}
				this.renderer.reset();
				this.context.save();
				this.context.setClip(this.$createDirtyRectWithPixelRatioApplied());
				tab.CanvasUtil.scaleCanvasDrawing(this.context, this.get_pixelRatio());
				this.renderer.set_renderOffset(this.scrollOffset);
				this.performRender();
				this.context.restore();
				this.postRenderFinalPass();
				this.clearDirty();
				this.raiseLoadComplete();
			},
			redrawFinished: function VisualRegionCanvasView$RedrawFinished() {
			},
			raiseLoadComplete: function VisualRegionCanvasView$RaiseLoadComplete() {
				tab.Log.get(this).debug('Load complete', []);
				if (ss.isValue(this.$4$LoadCompleteField)) {
					this.$4$LoadCompleteField(this, ss.EventArgs.Empty);
				}
			},
			onViewModelPropertyChanged: function VisualRegionCanvasView$OnViewModelPropertyChanged(sender, e) {
				this.invalidate(false);
			},
			performRender: null,
			postRenderFinalPass: null,
			$createDirtyRectWithPixelRatioApplied: function VisualRegionCanvasView$CreateDirtyRectWithPixelRatioApplied() {
				var pixelRatio = this.get_pixelRatio();
				var dirtyRect = this.get_dirtyRect();
				var x1 = dirtyRect.x * pixelRatio;
				var y1 = dirtyRect.y * pixelRatio;
				var x2 = (dirtyRect.x + dirtyRect.w) * pixelRatio;
				var y2 = (dirtyRect.y + dirtyRect.h) * pixelRatio;
				var startX = Math.floor(x1);
				var startY = Math.floor(y1);
				return { x: startX, y: startY, w: Math.ceil(x2) - startX, h: Math.ceil(y2) - startY };
			},
			$handleSizeChange: function VisualRegionCanvasView$HandleSizeChange() {
				this.$updateScrollPos();
			},
			$updateScrollPos: function VisualRegionCanvasView$UpdateScrollPos() {
				var viewSize = this.get_effectiveViewSize();
				var newScrollPos = { x: Math.min(this.completeDocSize.w - viewSize.w, this.scrollOffset.x), y: Math.min(this.completeDocSize.h - viewSize.h, this.scrollOffset.y) };
				newScrollPos.x = Math.max(0, newScrollPos.x);
				newScrollPos.y = Math.max(0, newScrollPos.y);
				this.set_scrollPos(newScrollPos);
			}
		}, function() {
			return ss.makeGenericType($tab_CanvasView$1, [TViewModel]);
		}, function() {
			return [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [TViewModel]), spiff.IScrollable, tab.IRegionContentProvider];
		});
		return $type;
	};
	$tab_VisualRegionCanvasView$1.__typeName = 'tab.VisualRegionCanvasView$1';
	ss.initGenericClass($tab_VisualRegionCanvasView$1, $asm, 1);
	global.tab.VisualRegionCanvasView$1 = $tab_VisualRegionCanvasView$1;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.VizContextMenuItemsHandler
	var $tab_VizContextMenuItemsHandler = function(result, p, visualId) {
		$tab_VizContextMenuItemsHandler.$ctor1.call(this, result.get_id(), result.get_hitObjectType(), p, visualId);
	};
	$tab_VizContextMenuItemsHandler.__typeName = 'tab.VizContextMenuItemsHandler';
	$tab_VizContextMenuItemsHandler.$ctor1 = function(id, type, p, visualId) {
		this.$id = 0;
		this.$type = 0;
		this.$visualId = null;
		this.$location = null;
		this.$id = id;
		this.$visualId = visualId;
		this.$type = type;
		this.$location = p;
	};
	global.tab.VizContextMenuItemsHandler = $tab_VizContextMenuItemsHandler;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.ViewModels.VizContextMenuViewModel
	var $tab_VizContextMenuViewModel = function(overlayDiv) {
		this.isHidden = false;
		this.location = null;
		this.vizOverlayDiv = null;
		this.$menuItemClickHandlers = null;
		this.$contextMenuHandlers = null;
		this.$scrollOffset = null;
		ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
		this.vizOverlayDiv = overlayDiv;
		this.isHidden = true;
		this.$scrollOffset = { x: 0, y: 0 };
	};
	$tab_VizContextMenuViewModel.__typeName = 'tab.VizContextMenuViewModel';
	global.tab.VizContextMenuViewModel = $tab_VizContextMenuViewModel;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VizHitInfo
	var $tab_VizHitInfo = function(region, paneId, paneColumnIndex, paneRowIndex, regionCoordinates, pageCoordinates, hit) {
		this.$hitResult = null;
		this.$1$InstanceIdField = 0;
		this.$1$RegionField = null;
		this.$1$PaneIdField = 0;
		this.$1$PaneColumnIndexField = 0;
		this.$1$PaneRowIndexField = 0;
		this.$1$RegionCoordinatesField = null;
		this.$1$PageCoordinatesField = null;
		this.set_instanceId(++$tab_VizHitInfo.$staticId);
		this.set_region(region);
		this.set_paneId(paneId);
		this.set_paneColumnIndex(paneColumnIndex);
		this.set_paneRowIndex(paneRowIndex);
		this.set_regionCoordinates(regionCoordinates);
		this.set_pageCoordinates(pageCoordinates);
		this.$hitResult = hit;
	};
	$tab_VizHitInfo.__typeName = 'tab.VizHitInfo';
	global.tab.VizHitInfo = $tab_VizHitInfo;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VizHitTestDebouncer
	var $tab_VizHitTestDebouncer = function(paneTable, region) {
		this.$currentHit = null;
		this.$debouncer = null;
		this.paneTable = null;
		this.region = null;
		this.lastEvent = null;
		this.$1$UpdatedField = null;
		tab.Param.verifyValue(paneTable, 'paneTable');
		tab.Param.verifyValue(region, 'region');
		this.paneTable = paneTable;
		this.region = region;
		this.$debouncer = new tab.Debouncer(ss.mkdel(this, function() {
			var regionCoordinates = this.region.toLocalCoordsEvent(this.lastEvent, false);
			var pageCoordinates = tab.PointUtil.add(regionCoordinates, this.region.getLocalOffsetPoint(false));
			this.hitTest(regionCoordinates, pageCoordinates);
		}), $tab_VizHitTestDebouncer.hitTestDelay);
	};
	$tab_VizHitTestDebouncer.__typeName = 'tab.VizHitTestDebouncer';
	global.tab.VizHitTestDebouncer = $tab_VizHitTestDebouncer;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.VizZoneFactory
	var $tab_VizZoneFactory = function() {
	};
	$tab_VizZoneFactory.__typeName = 'tab.VizZoneFactory';
	global.tab.VizZoneFactory = $tab_VizZoneFactory;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.WorkerDoneEventArgs
	var $tab_WorkerDoneEventArgs = function(id, image) {
		this.$workerID = 0;
		this.$image = null;
		ss.EventArgs.call(this);
		this.$workerID = id;
		this.$image = image;
	};
	$tab_WorkerDoneEventArgs.__typeName = 'tab.WorkerDoneEventArgs';
	global.tab.WorkerDoneEventArgs = $tab_WorkerDoneEventArgs;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.WorkerTimeoutEventArgs
	var $tab_WorkerTimeoutEventArgs = function(id) {
		this.$workerID = 0;
		ss.EventArgs.call(this);
		this.$workerID = id;
	};
	$tab_WorkerTimeoutEventArgs.__typeName = 'tab.WorkerTimeoutEventArgs';
	global.tab.WorkerTimeoutEventArgs = $tab_WorkerTimeoutEventArgs;
	////////////////////////////////////////////////////////////////////////////////
	// Tableau.JavaScript.Vql.VizZone.Utility.ZoomComputer
	var $tab_ZoomComputer = function() {
	};
	$tab_ZoomComputer.__typeName = 'tab.ZoomComputer';
	$tab_ZoomComputer.resolveDesiredZoom = function ZoomComputer$ResolveDesiredZoom(model, desiredZoomLevel) {
		if (!model.get_hasPresModel()) {
			return desiredZoomLevel;
		}
		var intermediateLevels = ss.coalesce(model.get_intermediateTileLevels(), 1);
		var lowerLevel = Math.floor(desiredZoomLevel * intermediateLevels) / intermediateLevels;
		lowerLevel += Math.log(ss.coalesce(model.get_maxStretch(), 1)) / Math.LN2;
		var higherLevel = Math.ceil(desiredZoomLevel * intermediateLevels) / intermediateLevels;
		higherLevel += Math.log(ss.coalesce(model.get_minShrink(), 1)) / Math.LN2;
		return ((desiredZoomLevel + $tab_ZoomComputer.$zoomLevelSelectionTolerance < higherLevel) ? Math.min(lowerLevel, desiredZoomLevel) : Math.max(higherLevel, desiredZoomLevel));
	};
	$tab_ZoomComputer.resolveDesiredScale = function ZoomComputer$ResolveDesiredScale(mapData, desiredScale) {
		var desiredZoomDiff = Math.log(desiredScale) / Math.LN2;
		var finalZoom = $tab_ZoomComputer.resolveDesiredZoom(mapData.get_rasterMapSourceModel(), mapData.get_requestZoom() + desiredZoomDiff);
		var actualZoomDiff = finalZoom - mapData.get_requestZoom();
		var finalScale = Math.pow(2, actualZoomDiff);
		return finalScale;
	};
	$tab_ZoomComputer.incrementZoom = function ZoomComputer$IncrementZoom(currentZoom, zoomDir) {
		var zoomLevel = currentZoom + zoomDir;
		return zoomLevel;
	};
	$tab_ZoomComputer.combineTileZoomAndStretch = function ZoomComputer$CombineTileZoomAndStretch(tileZoom, stretch) {
		return tileZoom + Math.log(stretch) / Math.LN2;
	};
	global.tab.ZoomComputer = $tab_ZoomComputer;
	ss.initClass($tab_$ContextStatePreserver, $asm, {
		$resetState: function ContextStatePreserver$ResetState(context) {
			context.set_alpha(this.$alpha);
			context.set_lineJoin(this.$lineJoin);
			context.set_lineCap(this.$lineCap);
			context.set_linePattern(this.$linePattern);
			context.set_strokeStyle(this.$strokeStyle);
			context.set_lineWidth(this.$lineWidth);
			context.set_textAngle(this.$textAngle);
			context.set_font(this.$font);
			context.set_shapeFillStyle(this.$shapeFillStyle);
			context.set_textFillStyle(this.$textFillStyle);
			context.set_textAlign(this.$textAlign);
		}
	});
	ss.initClass($tab_$DownloadWorker, $asm, {
		add_$done: function DownloadWorker$add_Done(value) {
			this.$1$DoneField = ss.delegateCombine(this.$1$DoneField, value);
		},
		remove_$done: function DownloadWorker$remove_Done(value) {
			this.$1$DoneField = ss.delegateRemove(this.$1$DoneField, value);
		},
		add_$timedOut: function DownloadWorker$add_TimedOut(value) {
			this.$1$TimedOutField = ss.delegateCombine(this.$1$TimedOutField, value);
		},
		remove_$timedOut: function DownloadWorker$remove_TimedOut(value) {
			this.$1$TimedOutField = ss.delegateRemove(this.$1$TimedOutField, value);
		},
		get_$busy: function DownloadWorker$get_Busy() {
			return !this.$completed;
		},
		$destroy: function DownloadWorker$Destroy() {
			this.$clearHandlers();
		},
		$start: function DownloadWorker$Start(image) {
			if (ss.isNullOrUndefined(image)) {
				this.$sendDone();
				return;
			}
			if (this.$timeoutID !== -1) {
				window.clearTimeout(this.$timeoutID);
				this.$timeoutID = -1;
			}
			this.$imageData = image;
			this.$completed = false;
			this.$clearHandlers();
			var setBounds = true;
			var imgElement = image.get_imageNode();
			var imgObj = $(imgElement);
			if (ss.isNullOrUndefined(imgElement)) {
				var $t1 = document.createElement('img');
				image.set_imageNode($t1);
				imgElement = $t1;
				imgObj = $(imgElement);
			}
			else {
				setBounds = tab.DoubleUtil.roundToInt(imgObj.width()) !== image.get_bounds().w || tab.DoubleUtil.roundToInt(imgObj.height()) !== image.get_bounds().h;
				imgElement.style.visibility = '';
			}
			if (setBounds) {
				$(imgElement).css(ss.mkdict(['left', image.get_bounds().l + 'px', 'top', image.get_bounds().t + 'px']));
			}
			imgObj.on('load', ss.mkdel(this, this.$onImageCompleted));
			imgObj.on('error', ss.mkdel(this, this.$onCompletedWithError));
			imgObj.on('abort', ss.mkdel(this, this.$onImageCompleted));
			this.$timeoutID = window.setTimeout(ss.mkdel(this, function() {
				this.$onTimeout();
			}), 600000);
			var oldSrc = imgObj.attr('src');
			if (!BrowserSupport.BrowserSupport.ImageLoadIsSynchronous()) {
				imgObj.attr('src', image.get_src());
			}
			else {
				window.setTimeout(function() {
					imgObj.attr('src', image.get_src());
				}, 0);
			}
			if (ss.referenceEquals(image.get_src(), oldSrc) && !BrowserSupport.BrowserSupport.RaisesEventOnImageReassignment()) {
				window.setTimeout(ss.mkdel(this, function() {
					this.$onImageCompleted(null);
				}), 0);
			}
		},
		$clearHandlers: function DownloadWorker$ClearHandlers() {
			if (ss.isValue(this.$imageData) && ss.isValue(this.$imageData.get_imageNode())) {
				var imgObj = $(this.$imageData.get_imageNode());
				if (ss.isValue(imgObj)) {
					imgObj.on('load', ss.mkdel(this, this.$onImageCompleted));
					imgObj.on('error', ss.mkdel(this, this.$onImageCompleted));
					imgObj.on('abort', ss.mkdel(this, this.$onImageCompleted));
				}
			}
		},
		$onCompletedWithError: function DownloadWorker$OnCompletedWithError(evt) {
			if (ss.isValue(evt.currentTarget)) {
				evt.currentTarget.style.visibility = 'none';
			}
			this.$onImageCompleted(evt);
		},
		$onImageCompleted: function DownloadWorker$OnImageCompleted(evt) {
			window.clearTimeout(this.$timeoutID);
			this.$timeoutID = -1;
			if (this.$completed) {
				return;
			}
			this.$completed = true;
			this.$sendDone();
		},
		$onTimeout: function DownloadWorker$OnTimeout() {
			this.$completed = true;
			this.$timeoutID = -1;
			this.$clearHandlers();
			this.$sendTimedOut();
		},
		$sendDone: function DownloadWorker$SendDone() {
			if (ss.isValue(this.$1$DoneField)) {
				this.$1$DoneField(this, new $tab_WorkerDoneEventArgs(this.$id, this.$imageData));
			}
		},
		$sendTimedOut: function DownloadWorker$SendTimedOut() {
			if (ss.isValue(this.$1$TimedOutField)) {
				this.$1$TimedOutField(this, new $tab_WorkerTimeoutEventArgs(this.$id));
			}
		}
	});
	ss.initClass($tab_$GroupStatePreserver, $asm, {
		get_$state: function GroupStatePreserver$get_State() {
			return this.$state;
		},
		get_$hasPreservedState: function GroupStatePreserver$get_HasPreservedState() {
			return this.$hasPreservedState;
		}
	});
	ss.initClass($tab_$LeafletMapControl$LocalMapData, $asm, {
		get_$center: function LocalMapData$get_Center() {
			return this.$1$CenterField;
		},
		set_$center: function LocalMapData$set_Center(value) {
			this.$1$CenterField = value;
		},
		get_$zoomLevel: function LocalMapData$get_ZoomLevel() {
			return this.$1$ZoomLevelField;
		},
		set_$zoomLevel: function LocalMapData$set_ZoomLevel(value) {
			this.$1$ZoomLevelField = value;
		}
	});
	ss.initClass($tab_$LeafletMapTemplate, $asm, {
		get_$mapHolderElement: function LeafletMapTemplate$get_MapHolderElement() {
			return this.$mapHolder.get(0);
		},
		get_$mapHolderWidth: function LeafletMapTemplate$get_MapHolderWidth() {
			return tab.DoubleUtil.roundToInt(this.$mapHolder.width());
		},
		$setBackground: function LeafletMapTemplate$SetBackground(map) {
			var fillColorDict = ss.mkdict(['backgroundColor', map.get_mapBGFillColor()]);
			this.$leftBarnDoor.css(fillColorDict);
			this.$rightBarnDoor.css(fillColorDict);
			var mapHolderColorDict = ss.mkdict(['backgroundColor', map.get_mapHolderBackgroundColor()]);
			this.$mapHolder.css(mapHolderColorDict);
		},
		$adjustBarnDoors: function LeafletMapTemplate$AdjustBarnDoors(mapPixelWidth, animate) {
			var doorWidthDict = ss.mkdict(['width', mapPixelWidth + 'px']);
			if (animate) {
				this.$leftBarnDoor.addClass('leaflet-zoom-anim').addClass('leaflet-zoom-animated');
				this.$rightBarnDoor.addClass('leaflet-zoom-anim').addClass('leaflet-zoom-animated');
			}
			this.$leftBarnDoor.css(doorWidthDict);
			this.$rightBarnDoor.css(doorWidthDict);
		},
		$clearAnimationClasses: function LeafletMapTemplate$ClearAnimationClasses() {
			this.$leftBarnDoor.removeClass('leaflet-zoom-anim').removeClass('leaflet-zoom-animated');
			this.$rightBarnDoor.removeClass('leaflet-zoom-anim').removeClass('leaflet-zoom-animated');
		}
	}, spiff.Template, [ss.IDisposable]);
	ss.initClass($tab_$MapboxMapControl$LocalMapData, $asm, {
		get_$center: function LocalMapData$get_Center() {
			return this.$1$CenterField;
		},
		set_$center: function LocalMapData$set_Center(value) {
			this.$1$CenterField = value;
		},
		get_$zoomLevel: function LocalMapData$get_ZoomLevel() {
			return this.$1$ZoomLevelField;
		},
		set_$zoomLevel: function LocalMapData$set_ZoomLevel(value) {
			this.$1$ZoomLevelField = value;
		}
	});
	ss.initClass($tab_$MapControlEventProperty, $asm, {});
	ss.initInterface($tab_IMapsSearchViewTemplate, $asm, { get_template: null, get_mapsSearchViewRootElement: null });
	ss.initClass($tab_$MapsSearchViewTemplate, $asm, {
		get_template: function MapsSearchViewTemplate$get_Template() {
			return this;
		},
		get_mapsSearchViewRootElement: function MapsSearchViewTemplate$get_MapsSearchViewRootElement() {
			return this.$mapsSearchViewRootElement;
		}
	}, spiff.Template, [ss.IDisposable, $tab_IMapsSearchViewTemplate]);
	ss.initClass($tab_$PaneDrawInfo$WorldAndInstanceOffsets, $asm, {});
	ss.initClass($tab_$PaneTableCornersRenderer, $asm, {
		$resetRegionImages: function PaneTableCornersRenderer$ResetRegionImages() {
			this.$regionImages = [];
		},
		$setupCornerRenderer: function PaneTableCornersRenderer$SetupCornerRenderer(rect, cornerNode, cornerName, backgroundDisplayList) {
			if (ss.isValue(backgroundDisplayList)) {
				var $t1 = $tab_$PaneTableCornersRenderer.$ensureFirstChildIsGivenTag(cornerNode, 'canvas');
				var canvasElt = ss.cast($t1, ss.isValue($t1) && (ss.isInstanceOfType($t1, Element) && $t1.tagName === 'CANVAS'));
				var pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
				tab.CanvasUtil.setCanvasSizeAndDensify(canvasElt, pixelRatio, { w: rect.w, h: rect.h });
			}
			else if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				$tab_$PaneTableCornersRenderer.$ensureFirstChildIsGivenTag(cornerNode, 'div');
			}
			else {
				$tab_$PaneTableCornersRenderer.$ensureFirstChildIsGivenTag(cornerNode, 'img');
				this.$regionImages.push({ name: cornerName, node: cornerNode });
			}
		},
		$refreshCornerImages: function PaneTableCornersRenderer$RefreshCornerImages(tileCacheUrl, session, requestId) {
			if (this.$regionImages.length > 0) {
				var len = this.$regionImages.length;
				for (var i = 0; i < len; i++) {
					var div = this.$regionImages[i].node;
					if (ss.isValue(div)) {
						var url = session.formatRegionTileURL(tileCacheUrl, this.$regionImages[i].name, requestId);
						var img = div.children().first();
						var devicePixelRatio = tab.RenderUtil.calculatePixelRatio(false);
						if (tab.DoubleUtil.isGreaterThanAndNotApproximatelyEqual(devicePixelRatio, 1)) {
							img.css('width', div[0].offsetWidth + 'px');
						}
						img.attr('src', url);
					}
				}
			}
		}
	});
	ss.initClass($tab_$TargetObject, $asm, {
		get_$targetState: function TargetObject$get_TargetState() {
			return this.$targetState;
		},
		get_$hasValidTupleId: function TargetObject$get_HasValidTupleId() {
			return this.$hasValidId;
		},
		get_$id: function TargetObject$get_Id() {
			if (!this.get_$hasValidTupleId()) {
				tab.Log.get(this).warn('This target ID is no longer valid: %s', [this.$id]);
			}
			return this.$id;
		},
		get_$invalidationRects: function TargetObject$get_InvalidationRects() {
			return (this.$hasValidId ? this.$invalidationRects : null);
		},
		$update: function TargetObject$Update(newId, newTargetType, invalidRects) {
			this.$id = newId;
			this.$targetType = newTargetType;
			this.$hasValidId = true;
			this.$invalidationRects = invalidRects;
		},
		$invalidateId: function TargetObject$InvalidateId() {
			this.$hasValidId = false;
			this.$invalidationRects = null;
		},
		$isSameValidTarget: function TargetObject$IsSameValidTarget(otherTargetId, otherTargetType) {
			return this.$isSameTarget(otherTargetId, otherTargetType) && this.$hasValidId;
		},
		$isSameTarget: function TargetObject$IsSameTarget(otherTargetId, otherTargetType) {
			return this.$id === otherTargetId && this.$targetType === otherTargetType;
		}
	});
	ss.initClass($tab_$VersionedImageElement, $asm, {
		get_$imageElt: function VersionedImageElement$get_ImageElt() {
			return this.$elt;
		},
		set_$imageElt: function VersionedImageElement$set_ImageElt(value) {
			this.$elt = value;
		},
		$isSame: function VersionedImageElement$IsSame(imgSrc, version) {
			if (!ss.isValue(this.$elt)) {
				return false;
			}
			return ss.referenceEquals(this.$elt.getAttribute('src'), imgSrc) && this.$cacheVersion === version;
		}
	});
	ss.initClass($tab_AnnotationDragHandler, $asm, {
		get_dragObjectDictionary: function AnnotationDragHandler$get_DragObjectDictionary() {
			if (ss.isNullOrUndefined(this.dragDictionary)) {
				this.dragDictionary = ss.mkdict([$tab_AnnotationSelectionChromeViewModel.movePointTargetHandler, 2, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.SE, 9, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.NE, 7, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.SW, 10, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.NW, 8, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.n, 3, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.s, 5, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.e, 4, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.w, 6]);
			}
			return this.dragDictionary;
		},
		get_isDragging: function AnnotationDragHandler$get_IsDragging() {
			return this.dragType !== 0 && ss.isValue(this.get_currentAnnotation());
		},
		get_isResizing: function AnnotationDragHandler$get_IsResizing() {
			return this.get_isDragging() && this.dragType !== 1 && this.dragType !== 2 && (tab.FeatureFlags.isEnabled('AnnotationAreaResize') || tab.FeatureFlags.isEnabled('AnnotationMarkAndPointResize'));
		},
		get_isMovingPointTarget: function AnnotationDragHandler$get_IsMovingPointTarget() {
			return this.get_isDragging() && this.dragType === 2 && tab.FeatureFlags.isEnabled('AnnotationMovePointTarget');
		},
		get_currentAnnotation: function AnnotationDragHandler$get_CurrentAnnotation() {
			return this.$movingAnnotation;
		},
		set_currentAnnotation: function AnnotationDragHandler$set_CurrentAnnotation(value) {
			this.$movingAnnotation = value;
		},
		get_domRegion: function AnnotationDragHandler$get_DomRegion() {
			return this.vizRegion;
		},
		set_domRegion: function AnnotationDragHandler$set_DomRegion(value) {
			this.vizRegion = value;
		},
		get_validRegion: function AnnotationDragHandler$get_ValidRegion() {
			return this.convertToAbsolute$1({ x: 0, y: 0, w: this.get_domRegion().w - $tab_AnnotationDragHandler.regionPadding, h: this.get_domRegion().h - $tab_AnnotationDragHandler.regionPadding });
		},
		get_snappingRegion: function AnnotationDragHandler$get_SnappingRegion() {
			var annotationWidth = (ss.isValue(this.get_currentAnnotation()) ? this.get_currentAnnotation().areaRect.w : 0);
			var annotationHeight = (ss.isValue(this.get_currentAnnotation()) ? this.get_currentAnnotation().areaRect.h : 0);
			var snap = this.get_validRegion();
			snap.w = snap.w - annotationWidth;
			snap.h = snap.h - annotationHeight;
			return snap;
		},
		getShadow: function AnnotationDragHandler$GetShadow(cursorPosition) {
			this.$annotationShadow.rectShadow = this.getBodyShadow(cursorPosition);
			var line = this.$getLineShadow(cursorPosition);
			this.$annotationShadow.point1 = line.point1;
			this.$annotationShadow.point2 = line.point2;
			return this.$annotationShadow;
		},
		getBodyShadow: function AnnotationDragHandler$GetBodyShadow(cursorPosition) {
			if (!this.get_isDragging() || this.get_isMovingPointTarget()) {
				return null;
			}
			if (this.get_isResizing()) {
				return this.convertToRelative$1(this.generateNewAnnotationRegion(this.convertToAbsolute(cursorPosition)));
			}
			var offsetCursor = tab.PointUtil.subtract(cursorPosition, this.dragOffset);
			var snappingBounds = this.convertToRelative$1(this.get_snappingRegion());
			var draggingOffset = tab.RectXYUtil.clampCoords(offsetCursor, snappingBounds);
			return { x: draggingOffset.x, y: draggingOffset.y, w: this.get_currentAnnotation().areaRect.w, h: this.get_currentAnnotation().areaRect.h };
		},
		$getLineShadow: function AnnotationDragHandler$GetLineShadow(cursorPosition) {
			var shadow = new $tab_AnnotationShadow();
			if (!tab.FeatureFlags.isEnabled('AnnotationMovePointTarget') || !this.get_isDragging() || this.get_isResizing() || this.get_currentAnnotation().annotateEnum === 'area') {
				shadow.point1 = null;
				shadow.point2 = null;
			}
			else if (this.dragType === 1) {
				var targetPoint = tab.PointUtil.fromPresModel(this.get_currentAnnotation().targetPoint);
				targetPoint = this.convertToRelative(targetPoint);
				var bestRoutePoint = $tab_AnnotationDragHandler.getBestConnectionPoint(targetPoint, this.$annotationShadow.rectShadow);
				shadow.point1 = bestRoutePoint;
				shadow.point2 = targetPoint;
			}
			else {
				var offsetCursor = tab.PointUtil.subtract(cursorPosition, this.dragOffset);
				var snappingBounds = this.convertToRelative$1(this.get_validRegion());
				var draggingOffset = tab.RectXYUtil.clampCoords(offsetCursor, snappingBounds);
				var centerOfAnnotation = tab.RectXYUtil.getCenter(tab.RectXYUtil.fromPresModel(this.get_currentAnnotation().areaRect));
				centerOfAnnotation = this.convertToRelative(centerOfAnnotation);
				var xDiffFromCenter = ss.Int32.div(this.get_currentAnnotation().areaRect.w, 2);
				var yDiffFromCenter = ss.Int32.div(this.get_currentAnnotation().areaRect.h, 2);
				var annotation = { x: centerOfAnnotation.x - xDiffFromCenter, y: centerOfAnnotation.y - yDiffFromCenter, w: this.get_currentAnnotation().areaRect.w, h: this.get_currentAnnotation().areaRect.h };
				var bestConnectionPoint = $tab_AnnotationDragHandler.getBestConnectionPoint(cursorPosition, annotation);
				shadow.point1 = bestConnectionPoint;
				shadow.point2 = draggingOffset;
			}
			return shadow;
		},
		canMoveAnnotation: function AnnotationDragHandler$CanMoveAnnotation(htr, selected) {
			return htr.get_hitObjectType() === 2 && tab.FeatureFlags.isEnabled('AnnotationMove') && ss.keyExists(selected, htr.get_id());
		},
		onHandlerMouseDown: function AnnotationDragHandler$OnHandlerMouseDown(className, annotation) {
			this.dragType = this.get_dragObjectDictionary()[className];
			this.set_currentAnnotation(annotation);
		},
		canDrag: function AnnotationDragHandler$CanDrag(htr, selected) {
			return tsConfig.is_authoring && $tab_AnnotationSelectionChromeViewModel.canAnnotationInCurrentSheetType() && ss.isValue(selected) && (this.get_isResizing() || this.canMoveAnnotation(htr, selected) || this.get_isMovingPointTarget());
		},
		clearDrag: function AnnotationDragHandler$ClearDrag() {
			this.dragOffset.x = 0;
			this.dragOffset.y = 0;
			this.set_currentAnnotation(null);
			this.dragType = 0;
		},
		dragStarted: function AnnotationDragHandler$DragStarted(htr, selected, startPoint) {
			if (this.canDrag(htr, selected)) {
				if (!this.get_isResizing() && !this.get_isMovingPointTarget() && this.canMoveAnnotation(htr, selected)) {
					this.dragType = 1;
					this.set_currentAnnotation(selected[htr.get_id()]);
					this.$setDragOffset(startPoint, this.get_currentAnnotation());
				}
				return true;
			}
			this.clearDrag();
			return false;
		},
		$setDragOffset: function AnnotationDragHandler$SetDragOffset(clickPoint, annotation) {
			this.dragOffset.x = clickPoint.x - annotation.areaRect.x;
			this.dragOffset.y = clickPoint.y - annotation.areaRect.y;
		},
		dragEnded: function AnnotationDragHandler$DragEnded(endPoint) {
			if (!this.get_isDragging()) {
				return false;
			}
			if (this.dragType === 1) {
				var dragOffsetPoint = tab.PointUtil.subtract(endPoint, this.dragOffset);
				var snappedPoint = tab.RectXYUtil.clampCoords(dragOffsetPoint, this.get_snappingRegion());
				tab.AnnotationClientCommands.moveAnnotation(this.get_currentAnnotation(), this.visualId, snappedPoint);
				$tab_AnnotationTelemetryUtil.reportMovedAnnotationTelemetry(this.get_currentAnnotation().annotateEnum);
			}
			else if (this.dragType === 2) {
				var snappedPoint1 = tab.RectXYUtil.clampCoords(endPoint, this.get_validRegion());
				tab.AnnotationClientCommands.movePointTargetAnnotation(this.get_currentAnnotation(), this.visualId, snappedPoint1);
				$tab_AnnotationTelemetryUtil.reportMovedAnnotationPointTargetTelemetry();
			}
			else if (this.dragType !== 0) {
				var newRegion = this.generateNewAnnotationRegion(endPoint);
				if (ss.isValue(newRegion)) {
					tab.AnnotationClientCommands.resizeAnnotation(this.get_currentAnnotation(), this.visualId, newRegion);
					$tab_AnnotationTelemetryUtil.reportResizeAnnotationTelemetry(this.get_currentAnnotation().annotateEnum);
				}
			}
			this.clearDrag();
			return true;
		},
		generateNewAnnotationRegion: function AnnotationDragHandler$GenerateNewAnnotationRegion(cursorPosition) {
			var prevAnnotationRect = this.get_currentAnnotation().areaRect;
			var endPoint = { x: cursorPosition.x, y: cursorPosition.y };
			var prevLeft = prevAnnotationRect.x;
			var prevTop = prevAnnotationRect.y;
			var prevRight = prevAnnotationRect.x + prevAnnotationRect.w;
			var prevBottom = prevAnnotationRect.y + prevAnnotationRect.h;
			var anchorPoint = null;
			switch (this.dragType) {
				case 9: {
					anchorPoint = { x: prevLeft, y: prevTop };
					break;
				}
				case 7: {
					anchorPoint = { x: prevLeft, y: prevBottom };
					break;
				}
				case 8: {
					anchorPoint = { x: prevRight, y: prevBottom };
					break;
				}
				case 10: {
					anchorPoint = { x: prevRight, y: prevTop };
					break;
				}
				case 3: {
					anchorPoint = { x: prevLeft, y: prevBottom };
					endPoint.x = prevRight;
					break;
				}
				case 5: {
					anchorPoint = { x: prevLeft, y: prevTop };
					endPoint.x = prevRight;
					break;
				}
				case 4: {
					anchorPoint = { x: prevLeft, y: prevTop };
					endPoint.y = prevBottom;
					endPoint.x = this.$restrictAnnotationWidth(endPoint.x, prevLeft);
					break;
				}
				case 6: {
					anchorPoint = { x: prevRight, y: prevTop };
					endPoint.y = prevBottom;
					endPoint.x = this.$restrictAnnotationWidth(endPoint.x, prevRight);
					break;
				}
				default: {
					tab.Logger.getLogger($tab_AnnotationDragHandler, null).debug('Annotation drag type does not exist', []);
					return null;
				}
			}
			endPoint = tab.RectXYUtil.clampCoords(endPoint, this.get_validRegion());
			return tab.RectXYUtil.rectXYFromCorners$2(endPoint.x, endPoint.y, anchorPoint.x, anchorPoint.y);
		},
		$restrictAnnotationWidth: function AnnotationDragHandler$RestrictAnnotationWidth(currentX, anchorX) {
			if (this.get_currentAnnotation().annotateEnum === 'area') {
				return currentX;
			}
			if (this.dragType === 4) {
				return Math.max(anchorX + $tab_AnnotationDragHandler.minWidth, currentX);
			}
			if (this.dragType === 6) {
				return Math.min(anchorX - $tab_AnnotationDragHandler.minWidth, currentX);
			}
			return currentX;
		},
		convertToAbsolute: function AnnotationDragHandler$ConvertToAbsolute(relativePoint) {
			return tab.PointUtil.add(relativePoint, this.scrollOffset);
		},
		convertToRelative: function AnnotationDragHandler$ConvertToRelative(absolutePoint) {
			return tab.PointUtil.subtract(absolutePoint, this.scrollOffset);
		},
		convertToAbsolute$1: function AnnotationDragHandler$ConvertToAbsolute(relativeRect) {
			return tab.RectXYUtil.offsetRectXY(relativeRect, this.scrollOffset.x, this.scrollOffset.y);
		},
		convertToRelative$1: function AnnotationDragHandler$ConvertToRelative(absoluteRect) {
			return tab.RectXYUtil.offsetRectXY(absoluteRect, -this.scrollOffset.x, -this.scrollOffset.y);
		}
	});
	ss.initEnum($tab_AnnotationDragType, $asm, { none: 0, move: 1, movePointTarget: 2, resizeN: 3, resizeE: 4, resizeS: 5, resizeW: 6, resizeNE: 7, resizeNW: 8, resizeSE: 9, resizeSW: 10 });
	ss.initInterface($tab_IHitTestLink, $asm, { hitTest: null, clearCache: null }, [ss.IDisposable]);
	ss.initClass($tab_HitTestLink, $asm, {
		hitTest: null,
		clearCache: function HitTestLink$ClearCache() {
			return;
		},
		dispose: function HitTestLink$Dispose() {
			return;
		}
	}, null, [ss.IDisposable, $tab_IHitTestLink]);
	ss.initClass($tab_AnnotationHitTestLink, $asm, {
		get_hitTestStructures: function AnnotationHitTestLink$get_HitTestStructures() {
			if (ss.isValue(this.$hitTestStructureList)) {
				return this.$hitTestStructureList;
			}
			this.$hitTestStructureList = [];
			var annotations = this.paneTableVM.get_visualModel().getAnnotationList();
			if (!ss.isValue(annotations)) {
				return this.$hitTestStructureList;
			}
			for (var $t1 = 0; $t1 < annotations.length; $t1++) {
				var annotation = annotations[$t1];
				var hitbox = tab.RecordCast.rectPresModelAsRectXY(annotation.areaRect);
				this.$hitTestStructureList.push(new $tab_HitTargetNode(hitbox, 7, annotation.annotationId, null, 0));
				if (ss.isValue(annotation.textRect)) {
					this.$hitTestStructureList.push(new $tab_HitTargetNode(tab.RecordCast.rectPresModelAsRectXY(annotation.textRect), 7, annotation.annotationId, null, 0));
				}
			}
			return this.$hitTestStructureList;
		},
		hitTest: function AnnotationHitTestLink$HitTest(p, isSingleSelect) {
			return $tab_AnnotationHitTestLink.getHitTestResult(p, this.get_hitTestStructures());
		},
		clearCache: function AnnotationHitTestLink$ClearCache() {
			this.$hitTestStructureList = null;
		}
	}, $tab_HitTestLink, [ss.IDisposable, $tab_IHitTestLink]);
	ss.initClass($tab_AnnotationSelectionChromeViewModel, $asm, {
		get_annotationDictionary: function AnnotationSelectionChromeViewModel$get_AnnotationDictionary() {
			return this.getAnnotationDictionary();
		},
		get_$renderableAnnotations: function AnnotationSelectionChromeViewModel$get_RenderableAnnotations() {
			var annotations = [];
			if (this.visible) {
				annotations = this.nonNullAnnotations();
			}
			return annotations;
		},
		nonNullAnnotations: function AnnotationSelectionChromeViewModel$NonNullAnnotations() {
			return tab.ListExtensions.where(Object).call(null, _.values(this.selectedAnnotations), function(annotation) {
				return ss.isValue(annotation);
			});
		},
		isCaretMenuOpened: function AnnotationSelectionChromeViewModel$IsCaretMenuOpened() {
			return ss.isValue(this.$vizContextMenuViewModel) && !this.$vizContextMenuViewModel.isHidden;
		},
		setBounds: function AnnotationSelectionChromeViewModel$SetBounds(domRegion) {
			this.dragHandler.set_domRegion(domRegion);
			this.updateRegionScroll();
			this.incrementProps();
		},
		updateRegionScroll: function AnnotationSelectionChromeViewModel$UpdateRegionScroll() {
			if (ss.isValue(tab.ApplicationModel.get_instance().pm) && !tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				this.dragHandler.get_domRegion().x = this.dragHandler.scrollOffset.x;
				this.dragHandler.get_domRegion().y = this.dragHandler.scrollOffset.y;
			}
			else {
				this.dragHandler.get_domRegion().x = 0;
				this.dragHandler.get_domRegion().y = 0;
			}
		},
		setContextMenuViewModel: function AnnotationSelectionChromeViewModel$SetContextMenuViewModel(viewModel) {
			this.$vizContextMenuViewModel = viewModel;
		},
		$handleAnnotationSelected: function AnnotationSelectionChromeViewModel$HandleAnnotationSelected(id, toggle) {
			var prevHover = this.hoverAnnotation;
			var prevSelected = _.keys(this.selectedAnnotations);
			if (!toggle || !tab.FeatureFlags.isEnabled('RichTextSelectAnnotation')) {
				ss.clearKeys(this.selectedAnnotations);
			}
			if (ss.keyExists(this.selectedAnnotations, id) && !ss.referenceEquals(this.hoverAnnotation, this.selectedAnnotations[id])) {
				delete this.selectedAnnotations[id];
			}
			else {
				this.hoverAnnotation = null;
				this.selectedAnnotations[id] = this.get_annotationDictionary()[id];
			}
			this.visible = tab.FeatureFlags.isEnabled('RichTextSelectAnnotation') && ss.getKeyCount(this.selectedAnnotations) > 0;
			if (!ss.referenceEquals(prevHover, this.hoverAnnotation) || !ss.referenceEquals(prevSelected, _.keys(this.selectedAnnotations))) {
				this.incrementProps();
			}
		},
		handleAnnotationClicked: function AnnotationSelectionChromeViewModel$HandleAnnotationClicked(id, e, toggle) {
			if (!$tab_AnnotationSelectionChromeViewModel.canAnnotationInCurrentSheetType() || !tsConfig.is_authoring) {
				return;
			}
			if (this.$respondToChevronTap(id, e, toggle)) {
				return;
			}
			this.$handleAnnotationSelected(id, toggle);
		},
		onHover: function AnnotationSelectionChromeViewModel$OnHover(htr) {
			var prevHover = this.hoverAnnotation;
			if (htr.get_hitObjectType() !== 2 || ss.keyExists(this.selectedAnnotations, htr.get_id())) {
				this.hoverAnnotation = null;
				this.visible = this.$isChromeVisible();
			}
			else if (!this.dragHandler.get_isDragging()) {
				this.hoverAnnotation = this.get_annotationDictionary()[htr.get_id()];
				this.visible = true;
			}
			if (!ss.referenceEquals(prevHover, this.hoverAnnotation)) {
				this.incrementProps();
			}
		},
		clearSelection: function AnnotationSelectionChromeViewModel$ClearSelection() {
			if (!$tab_AnnotationSelectionChromeViewModel.canAnnotationInCurrentSheetType() || !tsConfig.is_authoring) {
				return;
			}
			ss.clearKeys(this.selectedAnnotations);
			this.dragHandler.clearDrag();
			this.visible = ss.isValue(this.hoverAnnotation);
			this.incrementProps();
		},
		hideAll: function AnnotationSelectionChromeViewModel$HideAll() {
			this.visible = false;
			this.incrementProps();
		},
		scrollX: function AnnotationSelectionChromeViewModel$ScrollX(offset) {
			this.dragHandler.scrollOffset.x = offset;
			this.updateRegionScroll();
			this.incrementProps();
		},
		scrollY: function AnnotationSelectionChromeViewModel$ScrollY(offset) {
			this.dragHandler.scrollOffset.y = offset;
			this.updateRegionScroll();
			this.incrementProps();
		},
		dragStarted: function AnnotationSelectionChromeViewModel$DragStarted(htr, startPoint) {
			if (BrowserSupport.BrowserSupport.IsSafari()) {
				window.getSelection().removeAllRanges();
			}
			if (this.dragHandler.dragStarted(htr, this.selectedAnnotations, startPoint)) {
				var annotation = this.dragHandler.get_currentAnnotation();
				ss.clearKeys(this.selectedAnnotations);
				this.selectedAnnotations[annotation.annotationId] = annotation;
				this.incrementProps();
				return true;
			}
			this.hoverAnnotation = null;
			return false;
		},
		onDrag: function AnnotationSelectionChromeViewModel$OnDrag(cursor) {
			this.$cursorPosition = this.dragHandler.convertToRelative(cursor);
			this.incrementProps();
		},
		dragEnded: function AnnotationSelectionChromeViewModel$DragEnded(endpoint) {
			if (BrowserSupport.BrowserSupport.IsSafari()) {
				window.getSelection().removeAllRanges();
			}
			this.dragHandler.dragEnded(endpoint);
			this.incrementProps();
		},
		update: function AnnotationSelectionChromeViewModel$Update() {
			var annotationDict = this.get_annotationDictionary();
			_.map(Object.keys(this.selectedAnnotations), ss.mkdel(this, function(id) {
				return this.selectedAnnotations[id] = annotationDict[id];
			}));
			this.visible = this.$isChromeVisible();
			this.incrementProps();
		},
		deleteSelectedAnnotationsFromKeystroke: function AnnotationSelectionChromeViewModel$DeleteSelectedAnnotationsFromKeystroke() {
			var ids = Array.prototype.slice.call(ss.arrayFromEnumerable(Object.keys(this.selectedAnnotations)));
			this.clearSelection();
			if (ids.length > 0 && tab.FeatureFlags.isEnabled('RichTextDeleteAnnotation') && tab.FeatureFlags.isEnabled('RichTextSelectAnnotation')) {
				tab.AnnotationClientCommands.removeAnnotation(ids, this.visualId);
				$tab_AnnotationTelemetryUtil.reportDeletedAnnotationTelemetry($tab_AnnotationTelemetryUtil.annotationFromDelete);
			}
		},
		handleRightClick: function AnnotationSelectionChromeViewModel$HandleRightClick(result, p) {
			this.$respondToAnnotationInteraction(result.get_id(), p, tab.FormattingTelemetryClient.richTextEditorOpenedByContextMenu, false);
		},
		$onAnnotationChevronClicked: function AnnotationSelectionChromeViewModel$OnAnnotationChevronClicked(id, p, toggle) {
			this.$respondToAnnotationInteraction(id, p, tab.FormattingTelemetryClient.richTextEditorOpenedByChevron, toggle);
		},
		$clearDrag: function AnnotationSelectionChromeViewModel$ClearDrag() {
			this.dragHandler.clearDrag();
			this.incrementProps();
		},
		createUpdatedProps: function AnnotationSelectionChromeViewModel$CreateUpdatedProps() {
			return { visible: this.visible, renderRegion: this.dragHandler.get_domRegion(), hoveredAnnotation: this.hoverAnnotation, annotations: this.get_$renderableAnnotations(), scrollOffset: this.dragHandler.scrollOffset, onHandlerMouseDown: ss.mkdel(this.dragHandler, this.dragHandler.onHandlerMouseDown), clearMouseUp: ss.mkdel(this, this.$clearDrag), shadow: this.dragHandler.getShadow(this.$cursorPosition) };
		},
		$respondToAnnotationInteraction: function AnnotationSelectionChromeViewModel$RespondToAnnotationInteraction(id, p, openedBy, toggle) {
			if (!ss.keyExists(this.selectedAnnotations, id)) {
				this.$handleAnnotationSelected(id, toggle);
			}
			var handler = new $tab_AnnotationVizContextMenuItemsHandler(this.visualId, this.selectedAnnotations, openedBy, ss.mkdel(this, function() {
				this.clearSelection();
			}));
			this.$vizContextMenuViewModel.show(p, [handler]);
		},
		$respondToChevronTap: function AnnotationSelectionChromeViewModel$RespondToChevronTap(id, e, toggle) {
			if (ss.isNullOrUndefined(e) || !tab.FeatureFlags.isEnabled('RichTextSelectAnnotation') || !e.target.classList.contains('tabAuthoringAnnotationChevronIcon') || !ss.keyExists(this.get_annotationDictionary(), id) || ss.isNullOrUndefined(this.get_annotationDictionary()[id])) {
				return false;
			}
			var annotation = this.get_annotationDictionary()[id];
			var annotationTopRight = { x: annotation.areaRect.x + annotation.areaRect.w, y: annotation.areaRect.y };
			var targetRect = e.target.getBoundingClientRect();
			var coords = { x: annotationTopRight.x - ss.Int32.trunc(targetRect.width), y: annotationTopRight.y + ss.Int32.trunc(targetRect.height) };
			this.$onAnnotationChevronClicked(id, coords, toggle);
			return true;
		},
		$isChromeVisible: function AnnotationSelectionChromeViewModel$IsChromeVisible() {
			return this.nonNullAnnotations().length > 0 || ss.isValue(this.hoverAnnotation);
		},
		isDragging: function AnnotationSelectionChromeViewModel$IsDragging() {
			return this.dragHandler.get_isDragging();
		}
	}, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [ss.IDisposable, tab.IViewModel, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
	ss.initClass($tab_AnnotationShadow, $asm, {});
	ss.initClass($tab_AnnotationTelemetryUtil, $asm, {});
	ss.initInterface($tab_IVizContextMenuItemsHandler, $asm, { buildMenuItems: null, handleItemClicked: null });
	ss.initClass($tab_AnnotationVizContextMenuItemsHandler, $asm, {
		buildMenuItems: function AnnotationVizContextMenuItemsHandler$BuildMenuItems() {
			var menuItems = [];
			if (tab.FeatureFlags.isEnabled('RichTextDeleteAnnotation') && this.$selectionIds.length > 0) {
				var displayValue = ((this.$selectionIds.length > 1) ? tab.Strings.DeleteSelectedAnnotationFromVizContextMenu : tab.Strings.DeleteAnnotationFromVizContextMenu);
				menuItems.push({ value: $tab_AnnotationVizContextMenuItemsHandler.deleteAnnotationMenuItem, displayValue: displayValue, disabled: false });
			}
			if (this.$selectionIds.length === 1) {
				menuItems.push({ value: $tab_AnnotationVizContextMenuItemsHandler.editAnnotationMenuItem, displayValue: tab.Strings.EditAnnotationFromVizContextMenu, disabled: false });
			}
			return menuItems;
		},
		handleItemClicked: function AnnotationVizContextMenuItemsHandler$HandleItemClicked(itemName) {
			switch (itemName) {
				case 'Delete Annotation': {
					tab.AnnotationClientCommands.removeAnnotation(this.$selectionIds, this.$visualId);
					$tab_AnnotationTelemetryUtil.reportDeletedAnnotationTelemetry(this.$telemetryOpenedBy);
					break;
				}
				case 'Edit Annotation': {
					tab.RichTextClientCommands.createAnnotationRichTextEditor(this.$visualId.worksheet, this.$selectionIds);
					tab.FormattingTelemetryClient.logRichTextEditorEvent(ss.mkdict([tab.FormattingTelemetryClient.richTextEditorOpenedBy, this.$telemetryOpenedBy, tab.FormattingTelemetryClient.richTextEditorOpenedFrom, tab.FormattingTelemetryClient.annotation]));
					break;
				}
				default: {
					throw new ss.Exception('Unknown menu option ' + itemName);
				}
			}
			if (!ss.staticEquals(this.$afterClickCallback, null)) {
				this.$afterClickCallback();
			}
		}
	}, null, [$tab_IVizContextMenuItemsHandler]);
	ss.initClass($tab_CanvasTemplate, $asm, {}, spiff.Template, [ss.IDisposable]);
	ss.initClass($tab_ShapeSelectorBase, $asm, {
		get_dom: function ShapeSelectorBase$get_Dom() {
			return this.$dom;
		},
		get_pi: function ShapeSelectorBase$get_Pi() {
			return this.$pi;
		},
		set_pi: function ShapeSelectorBase$set_Pi(value) {
			this.$pi = value;
		},
		get_dragStart: function ShapeSelectorBase$get_DragStart() {
			return this.$dragStart;
		},
		get_connectNodePos: function ShapeSelectorBase$get_ConnectNodePos() {
			return this.$connectNodePos;
		},
		get_totalScrollOffset: function ShapeSelectorBase$get_TotalScrollOffset() {
			return this.$totalScrollOffset;
		},
		get_drawOffsets: function ShapeSelectorBase$get_DrawOffsets() {
			return ((tab.ApplicationModel.get_instance().get_isLocalRenderMode() || tsConfig.is_mobile) ? { x: 0, y: 0 } : this.get_totalScrollOffset());
		},
		get_autoScrollOffset: function ShapeSelectorBase$get_AutoScrollOffset() {
			return this.$autoScrollOffset;
		},
		get_tooltipAnchor: function ShapeSelectorBase$get_TooltipAnchor() {
			return { x: this.$latestPoint.x + this.$totalScrollOffset.x, y: this.$latestPoint.y + this.$totalScrollOffset.y };
		},
		get_hitTestingBox: null,
		isSingleSelect: null,
		setSingleSelectPoint: function ShapeSelectorBase$SetSingleSelectPoint(p) {
			this.$latestPoint = { x: p.x, y: p.y };
		},
		dragStarted: function ShapeSelectorBase$DragStarted(dragStartX, dragStartY, connectedNodePosition) {
			this.$dragStart = { x: dragStartX, y: dragStartY };
			this.$connectNodePos = connectedNodePosition;
			this.$autoScrollOffset = { x: 0, y: 0 };
		},
		recordScrollingOffsets: function ShapeSelectorBase$RecordScrollingOffsets(scrOffset) {
			this.$totalScrollOffset = { x: scrOffset.x, y: scrOffset.y };
		},
		updateAndRenderShape: function ShapeSelectorBase$UpdateAndRenderShape(gestureInfo) {
			this.constrainShape(gestureInfo);
			this.updateSpecificShape(this.$latestPoint);
			this.renderShape();
		},
		constrainShape: function ShapeSelectorBase$ConstrainShape(gestureInfo) {
			this.$latestPoint = { x: gestureInfo.pageX - this.$connectNodePos.x, y: gestureInfo.pageY - this.$connectNodePos.y };
			if (ss.isInstanceOfType(this, $tab_CircleShapeSelector)) {
				return;
			}
			this.$latestPoint.y = Math.max(0, Math.min(this.$latestPoint.y, this.$connectNodePos.h));
			this.$latestPoint.x = Math.max(0, Math.min(this.$latestPoint.x, this.$connectNodePos.w));
		},
		shapeScrolled: function ShapeSelectorBase$ShapeScrolled(scrolledX, scrolledY) {
			this.get_dragStart().x -= scrolledX;
			this.get_dragStart().y -= scrolledY;
			this.$totalScrollOffset.x += scrolledX;
			this.$totalScrollOffset.y += scrolledY;
			this.$autoScrollOffset.x += scrolledX;
			this.$autoScrollOffset.y += scrolledY;
			this.updateSpecificShape(this.$latestPoint);
			this.renderShape();
		},
		updateSpecificShape: null,
		renderShape: null,
		createDomAndAppend: function ShapeSelectorBase$CreateDomAndAppend(parentNode) {
			this.$dom = $(this.$htmlTemplate);
			this.$dom.addClass(this.$divClassName);
			this.$dom.css('display', 'none');
			this.$dom.find('svg').attr('width', this.$svgWidth).attr('height', this.$svgHeight);
			parentNode.append(this.$dom);
		},
		show: null,
		hide: null,
		hitTest: function ShapeSelectorBase$HitTest(hitTester, isSingleSelect, sceneInfo) {
			var toSingleSelect = isSingleSelect || this.isSingleSelect();
			return (toSingleSelect ? this.$hitTestPoint(hitTester, sceneInfo) : this.$hitTestShape(hitTester, sceneInfo));
		},
		$hitTestPoint: function ShapeSelectorBase$HitTestPoint(hitTester, sceneInfo) {
			var rect = { x: this.$latestPoint.x, y: this.$latestPoint.y, w: 1, h: 1 };
			var intersectedBBoxes = hitTester.hitTestBoundingBoxes(rect, true, sceneInfo);
			return hitTester.hitTestSingle(rect, sceneInfo, intersectedBBoxes);
		},
		$hitTestShape: function ShapeSelectorBase$HitTestShape(hitTester, sceneInfo) {
			var intersectedBBoxes = hitTester.hitTestBoundingBoxes(this.get_hitTestingBox(), false, sceneInfo);
			var selectedIds = [];
			var selectBounds = this.get_hitTestingBox();
			for (var i = intersectedBBoxes.length - 1; i >= 0; i--) {
				var nn = intersectedBBoxes[i];
				var markIndex = nn.get_objectId();
				if (markIndex < 0) {
					tab.Log.get(this).warn('Mark Node has invalid mark index: ' + markIndex, []);
					continue;
				}
				var paneNode = $tab_HitTargetNode.findPaneNode(nn);
				if (ss.isNullOrUndefined(paneNode)) {
					tab.Log.get(this).warn("Couldn't find idx #" + markIndex + "'s pane node.", []);
					continue;
				}
				var paneDrawInfo = sceneInfo.getPaneDrawInfoFromKey(paneNode.get_paneKey());
				var t = $tab_HitTester.getTransformInfo(paneDrawInfo, nn);
				var clippedSelection = tab.RectXYUtil.intersect(selectBounds, paneNode.get_boundingBox());
				var areaHit = this.shapeAreaHit(clippedSelection, paneDrawInfo, nn, t);
				if (areaHit) {
					selectedIds.push(new $tab_HitTestResult.$ctor1(paneDrawInfo.c.get('tuple_id').gv(markIndex), 7, 1));
				}
			}
			return selectedIds;
		},
		shapeAreaHit: null,
		sendSelectionCommand: null,
		updateLastState: function ShapeSelectorBase$UpdateLastState(shapeState) {
			if (this.isStateObjectTypeCorrect(shapeState)) {
				shapeState.updateLastState();
			}
		},
		getStateDiff: function ShapeSelectorBase$GetStateDiff(shapeState) {
			if (this.isStateObjectTypeCorrect(shapeState)) {
				this.saveCurrentState(shapeState);
				return shapeState.getStateDiff();
			}
			var changedArea = new Array(1);
			changedArea[0] = this.get_hitTestingBox();
			return changedArea;
		},
		retrieveStateObject: null,
		saveCurrentState: null,
		isStateObjectTypeCorrect: null
	});
	ss.initClass($tab_CircleShapeSelector, $asm, {
		get_hitTestingBox: function CircleShapeSelector$get_HitTestingBox() {
			return tab.RectXYUtil.nonemptyify(this.$getBoxHelper(true));
		},
		isSingleSelect: function CircleShapeSelector$IsSingleSelect() {
			return this.$dragCircle.radius < 1;
		},
		$getBoxHelper: function CircleShapeSelector$GetBoxHelper(isForHitTesting) {
			return tab.CircleUtil.boundingBox((isForHitTesting ? this.$hitTestCircle : this.$dragCircle));
		},
		updateSpecificShape: function CircleShapeSelector$UpdateSpecificShape(lastPoint) {
			var cx = this.get_dragStart().x - this.get_connectNodePos().x;
			var cy = this.get_dragStart().y - this.get_connectNodePos().y;
			var radius = Math.sqrt(Math.pow(cx - lastPoint.x, 2) + Math.pow(cy - lastPoint.y, 2));
			this.$dragCircle = { center: { x: cx + this.get_drawOffsets().x, y: cy + this.get_drawOffsets().y }, radius: radius };
			this.$hitTestCircle = { center: { x: cx + this.get_totalScrollOffset().x, y: cy + this.get_totalScrollOffset().y }, radius: radius };
			if (this.$shouldShowRadialDistance()) {
				this.$updateRadialDistance();
			}
		},
		$shouldShowRadialDistance: function CircleShapeSelector$ShouldShowRadialDistance() {
			return ss.isValue(this.$radialDistanceModel) && ss.isValue(this.$radialDistanceModel.get_radialSelectionDistanceInfoPresModel()) && this.$radialDistanceModel.get_shouldShowDistance();
		},
		$updateRadialDistance: function CircleShapeSelector$UpdateRadialDistance() {
			var rightEdgePt = { x: this.$dragCircle.center.x + this.$dragCircle.radius, y: this.$dragCircle.center.y };
			var distance = this.$computeRadialDistance(rightEdgePt);
			if (distance > 0) {
				this.displayDistance(distance);
			}
		},
		$computeRadialDistance: function CircleShapeSelector$ComputeRadialDistance(rightEdgePt) {
			var mapBounds = this.$radialDistanceModel.get_latLongRect();
			if (ss.isNullOrUndefined(mapBounds) || this.$radialDistanceModel.get_mapWidth() <= 0 || this.$radialDistanceModel.get_mapHeight() <= 0) {
				return 0;
			}
			var adjustedCenterPt = { x: this.$dragCircle.center.x % this.$radialDistanceModel.get_mapWidth(), y: this.$dragCircle.center.y % this.$radialDistanceModel.get_mapHeight() };
			var adjustedRightEdgePt = { x: adjustedCenterPt.x + (rightEdgePt.x - this.$dragCircle.center.x), y: adjustedCenterPt.y };
			var latitudePerPixel = (mapBounds.maxLatitude - mapBounds.minLatitude) / this.$radialDistanceModel.get_mapHeight();
			var latitudeEstimate = mapBounds.maxLatitude - latitudePerPixel * adjustedCenterPt.y;
			var lonLat1 = { item1: mapBounds.minLongitude, item2: latitudeEstimate };
			var lonLat2 = { item1: mapBounds.maxLongitude, item2: latitudeEstimate };
			var distanceDeltaTop = $tab_GeometryUtil.haversineDistance(lonLat1, lonLat2, this.$radialDistanceModel.get_earthRadius());
			var distancePerPixel = distanceDeltaTop / this.$radialDistanceModel.get_mapWidth();
			return Math.abs(adjustedRightEdgePt.x - adjustedCenterPt.x) * distancePerPixel;
		},
		displayDistance: function CircleShapeSelector$DisplayDistance(distance) {
			var distanceReadout = this.get_dom().find('.tabDistanceReadout');
			distanceReadout.text(this.$formatReadoutText(distance));
			var readoutPosition = { x: ss.round(this.$dragCircle.center.x + this.$dragCircle.radius + this.$radialDistanceModel.get_readoutOffsetPixels()), y: ss.round(this.$dragCircle.center.y) - ss.Int32.div(tab.DoubleUtil.roundToInt(distanceReadout.height()), 2) };
			distanceReadout.css('left', readoutPosition.x + 'px');
			distanceReadout.css('top', readoutPosition.y + 'px');
		},
		$formatReadoutText: function CircleShapeSelector$FormatReadoutText(distance) {
			var units = this.$radialDistanceModel.get_smallUnitDisplay();
			if (distance >= this.$radialDistanceModel.get_unitTransition()) {
				distance /= this.$radialDistanceModel.get_smallToLargeUnitDivisor();
				units = this.$radialDistanceModel.get_largeUnitDisplay();
			}
			var roundedDistance = tab.DoubleUtil.sigFigs(distance, this.$radialDistanceModel.get_sigFigs());
			var digitsAfterDecimal = 0;
			if (roundedDistance !== 0) {
				var numDigits = Math.floor(Math.log(Math.abs(roundedDistance)) / Math.log(10)) + 1;
				digitsAfterDecimal = Math.max(0, this.$radialDistanceModel.get_sigFigs() - numDigits);
			}
			var numericPart = roundedDistance.toFixed(digitsAfterDecimal);
			if (this.$radialDistanceModel.get_decimalMark() === ',' && numericPart.indexOf('.') !== -1) {
				numericPart = ss.replaceAllString(numericPart, '.', this.$radialDistanceModel.get_decimalMark());
			}
			return ss.formatString('{0}  {1}', numericPart, units);
		},
		formatReadoutTestHook: function CircleShapeSelector$FormatReadoutTestHook(distance) {
			return this.$formatReadoutText(distance);
		},
		computeRadialDistanceTestHook: function CircleShapeSelector$ComputeRadialDistanceTestHook(rightEdgePt) {
			return this.$computeRadialDistance(rightEdgePt);
		},
		renderShape: function CircleShapeSelector$RenderShape() {
			var crosshairs = this.get_dom().find('.circle_crosshair');
			var radiusLine = this.get_dom().find('.circle_radius');
			this.get_dom().find('svg circle').attr('cx', this.$dragCircle.center.x.toString()).attr('cy', this.$dragCircle.center.y.toString()).attr('r', this.$dragCircle.radius.toString());
			crosshairs.eq(0).attr('x1', (this.$dragCircle.center.x - 4).toString()).attr('x2', (this.$dragCircle.center.x + 4).toString()).attr('y1', this.$dragCircle.center.y.toString()).attr('y2', this.$dragCircle.center.y.toString());
			crosshairs.eq(1).attr('x1', this.$dragCircle.center.x.toString()).attr('x2', this.$dragCircle.center.x.toString()).attr('y1', (this.$dragCircle.center.y - 4).toString()).attr('y2', (this.$dragCircle.center.y + 4).toString());
			radiusLine.attr('x1', this.$dragCircle.center.x.toString()).attr('x2', (this.$dragCircle.center.x + this.$dragCircle.radius).toString()).attr('y1', this.$dragCircle.center.y.toString()).attr('y2', this.$dragCircle.center.y.toString());
		},
		show: function CircleShapeSelector$Show() {
			var distanceReadout = this.get_dom().find('.tabDistanceReadout');
			var radiusLine = this.get_dom().find('.circle_radius');
			if (this.$shouldShowRadialDistance()) {
				distanceReadout.css('font-size', this.$radialDistanceModel.get_fontSizePixels());
				distanceReadout.css('color', this.$radialDistanceModel.get_fontColor());
				distanceReadout.show();
				radiusLine.show();
			}
			else {
				distanceReadout.hide();
				radiusLine.hide();
			}
			this.get_dom().show();
		},
		hide: function CircleShapeSelector$Hide() {
			this.get_dom().hide();
		},
		shapeAreaHit: function CircleShapeSelector$ShapeAreaHit(clippedSelection, paneDrawInfo, markHitTargetNode, t) {
			var hitTestMarkCenter = this.$shouldShowRadialDistance();
			return $tab_HitTester.circleAreaHit(paneDrawInfo, markHitTargetNode.get_boundingBox(), this.$hitTestCircle, markHitTargetNode.get_objectId(), t, paneDrawInfo.markType, hitTestMarkCenter);
		},
		sendSelectionCommand: function CircleShapeSelector$SendSelectionCommand(region, action, visualId, tooltipCallback) {
			var hitTestMarkCenter = this.$shouldShowRadialDistance();
			tab.SelectionClientCommands.selectCircleRegionAndDoUbertip(region, this.get_hitTestingBox(), this.$hitTestCircle, action, visualId, tooltipCallback, hitTestMarkCenter);
		},
		retrieveStateObject: function CircleShapeSelector$RetrieveStateObject(shapeState) {
			return (this.isStateObjectTypeCorrect(shapeState) ? shapeState : new $tab_CircleShapeState());
		},
		saveCurrentState: function CircleShapeSelector$SaveCurrentState(shapeState) {
			if (this.isStateObjectTypeCorrect(shapeState)) {
				var circleShapeState = ss.cast(shapeState, $tab_CircleShapeState);
				circleShapeState.saveCurrentState(this.$hitTestCircle);
			}
		},
		isStateObjectTypeCorrect: function CircleShapeSelector$IsStateObjectTypeCorrect(shapeState) {
			if (ss.isValue(shapeState)) {
				if (ss.referenceEquals(ss.getInstanceType(shapeState), $tab_CircleShapeState)) {
					return true;
				}
				tab.Log.get(this).warn('CircleShapeSelector expects to work on only CircleShapeState objects', []);
			}
			return false;
		}
	}, $tab_ShapeSelectorBase);
	ss.initClass($tab_ShapeStateBase, $asm, { updateLastState: null, getStateDiff: null });
	ss.initClass($tab_CircleShapeState, $asm, {
		saveCurrentState: function CircleShapeState$SaveCurrentState(dragCircle) {
			this.$currentState = tab.CircleUtil.clone(dragCircle);
		},
		updateLastState: function CircleShapeState$UpdateLastState() {
			this.$lastState = this.$currentState;
		},
		getStateDiff: function CircleShapeState$GetStateDiff() {
			if (!tab.CircleUtil.isEmpty(this.$lastState)) {
				return tab.CircleUtil.getChangedRects(this.$currentState, this.$lastState);
			}
			var changedArea = new Array(1);
			changedArea[0] = tab.CircleUtil.boundingBox(this.$currentState);
			return changedArea;
		}
	}, $tab_ShapeStateBase);
	ss.initClass($tab_DisplayList2DRenderer, $asm, {
		renderVisualListHelper: function DisplayList2DRenderer$RenderVisualListHelper(vlvm, imageDict) {
			var items = vlvm.get_visualListPM().drawItems;
			this.renderDrawItems(items, vlvm, imageDict, null);
		},
		renderDrawItems: function DisplayList2DRenderer$RenderDrawItems(items, vlvm, imageDict, mapClipRect) {
			var context = this.get_currentContext();
			var originalNumSavedStates = context.get_numberSavedStates();
			var MaxItemstoCheckForTranslate = 4;
			for (var ii = 0; ii < items.length; ++ii) {
				var item = items[ii];
				if ($tab_DisplayList2DRenderer.$turnOnHacksToLookPretty && ii < MaxItemstoCheckForTranslate && item.type === 'transform') {
				}
				else if (item.type === 'draw-group') {
					var drawGroup = item;
					this.$drawGroup(vlvm, drawGroup, imageDict, mapClipRect);
				}
				else {
					this.$renderDrawItem(context, item, imageDict, null, mapClipRect, false);
				}
			}
			while (context.get_numberSavedStates() > originalNumSavedStates) {
				context.restore();
			}
		},
		renderVisualList: function DisplayList2DRenderer$RenderVisualList(vlvm, imageDict) {
			this.startCachingVisibleRect();
			var visibleRectangle = this.get_visibleRect();
			if (ss.isValue(vlvm.get_defaultBackgroundColor())) {
				this.get_currentContext().set_shapeFillStyle(vlvm.get_defaultBackgroundColor());
				this.get_currentContext().fillRect(visibleRectangle.x, visibleRectangle.y, visibleRectangle.w, visibleRectangle.h);
			}
			this.renderVisualListHelper(vlvm, imageDict);
			this.stopCachingVisibleRect();
		},
		renderDrawItemList: function DisplayList2DRenderer$RenderDrawItemList(items) {
			this.renderDrawItems(items, null, null, null);
		},
		renderCanvasBorders: function DisplayList2DRenderer$RenderCanvasBorders(vlvm) {
			var visualPart = vlvm.get_visualListPM().visualPart;
			var $t1 = vlvm.get_visualListPM().drawItems;
			for (var $t2 = 0; $t2 < $t1.length; $t2++) {
				var item = $t1[$t2];
				if (item.type === 'draw-pen' || item.type === 'draw-solid-brush') {
					this.renderDrawItemDefaultOptions(this.get_currentContext(), item);
				}
				else if (item.type === 'draw-polyline') {
					var canvasWidth = this.get_currentCanvas().width;
					var canvasHeight = this.get_currentCanvas().height;
					var drawPoints = item;
					var points = drawPoints.points;
					if (ss.contains($tab_DisplayList2DRenderer.$scrollableXParts, visualPart)) {
						if (Math.abs(points[3] - points[1]) >= canvasHeight) {
							var newItem = { type: item.type, points: [0, 0, 0, canvasHeight] };
							this.renderDrawItemDefaultOptions(this.get_currentContext(), newItem);
							newItem.points[0] += canvasWidth - 1;
							newItem.points[2] += canvasWidth - 1;
							this.renderDrawItemDefaultOptions(this.get_currentContext(), newItem);
							return;
						}
					}
					else if (ss.contains($tab_DisplayList2DRenderer.$scrollableYParts, visualPart)) {
						if (Math.abs(points[2] - points[0]) >= this.get_currentCanvas().width) {
							var newItem1 = { type: item.type, points: [0, 0, canvasWidth, 0] };
							this.renderDrawItemDefaultOptions(this.get_currentContext(), newItem1);
							newItem1.points[1] += canvasHeight - 1;
							newItem1.points[3] += canvasHeight - 1;
							this.renderDrawItemDefaultOptions(this.get_currentContext(), newItem1);
							return;
						}
					}
				}
			}
		},
		renderDrawItemDefaultOptions: function DisplayList2DRenderer$RenderDrawItemDefaultOptions(context, item) {
			this.$renderDrawItem(context, item, null, null, null, false);
		},
		$renderDrawItem: function DisplayList2DRenderer$RenderDrawItem(context, item, imageDict, enclosingRect, mapClipRect, alignNeighboringTextRuns) {
			if (!ss.isValue(context) || !ss.isValue(item)) {
				return;
			}
			switch (item.type) {
				case 'draw-pen': {
					{
						var drawPen = item;
						context.set_lineJoin((ss.isValue(drawPen.lineJoin) ? tab.CanvasRenderer.toCanvasLineJoin(drawPen.lineJoin) : tab.TabRenderContext2D.defaultLineJoin));
						var linePattern = drawPen.linePattern || tab.TabRenderContext2D.defaultLinePattern;
						context.set_lineCap($tab_DisplayList2DRenderer.resolveLineCap(linePattern, drawPen.lineCap));
						context.set_linePattern(linePattern);
						context.set_strokeStyle(tab.ColorModel.convertColorForCanvas(drawPen.color) || tab.TabRenderContext2D.defaultColor);
						context.set_lineWidth(drawPen.strokeWidth || tab.TabRenderContext2D.defaultLineWidth);
					}
					break;
				}
				case 'draw-solid-brush': {
					{
						var drawSolidBrush = item;
						context.set_shapeFillStyle(tab.ColorModel.convertColorForCanvas(drawSolidBrush.color));
					}
					break;
				}
				case 'draw-gradient-brush': {
					{
						var drawGradientBrush = item;
						var p1 = drawGradientBrush.pt1;
						var p2 = drawGradientBrush.pt2;
						var colorGrad = context.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
						colorGrad.addColorStop(0, tab.ColorModel.convertColorForCanvas(drawGradientBrush.color1));
						colorGrad.addColorStop(1, tab.ColorModel.convertColorForCanvas(drawGradientBrush.color2));
						context.set_shapeFillStyle(colorGrad);
					}
					break;
				}
				case 'draw-rect': {
					{
						var drawPoints = item;
						if (drawPoints.points.length !== 4) {
							ss.Debug.fail('the draw item for a rectangle should always specify 4 values.');
							return;
						}
						var rect = $tab_DisplayList2DUtils.rectXYFromDrawRect(drawPoints.points);
						context.strokeRect(rect.x, rect.y, rect.w, rect.h);
					}
					break;
				}
				case 'draw-fill-rect': {
					{
						var drawPoints1 = item;
						if (drawPoints1.points.length !== 4) {
							ss.Debug.fail('the draw item for a rectangle should always specify 4 values.');
							return;
						}
						var rect1 = $tab_DisplayList2DUtils.rectXYFromDrawRect(drawPoints1.points);
						context.fillRect(rect1.x, rect1.y, rect1.w, rect1.h);
					}
					break;
				}
				case 'draw-ellipse': {
					{
						$tab_DisplayList2DRenderer.$drawEllipse(context, item, false);
					}
					break;
				}
				case 'draw-fill-ellipse': {
					{
						$tab_DisplayList2DRenderer.$drawEllipse(context, item, true);
					}
					break;
				}
				case 'draw-polyline': {
					{
						var drawPoints2 = item;
						var points = drawPoints2.points;
						tab.CanvasRenderer.strokePath(context, points, false, true);
					}
					break;
				}
				case 'draw-polygon': {
					{
						var drawPoints3 = item;
						tab.CanvasRenderer.strokePath(context, drawPoints3.points, true, true);
					}
					break;
				}
				case 'draw-fill-polygon': {
					{
						var drawPoints4 = item;
						tab.CanvasRenderer.fillPath(context, drawPoints4.points, true);
					}
					break;
				}
				case 'draw-fill-path': {
					{
						$tab_DisplayList2DRenderer.$drawPath(context, item, true);
					}
					break;
				}
				case 'draw-path': {
					{
						$tab_DisplayList2DRenderer.$drawPath(context, item, false);
					}
					break;
				}
				case 'clip-rect': {
					{
						var drawPoints5 = item;
						ss.Debug.assert(drawPoints5.points.length === 4, 'the draw item for a clip-rect should always specify 4 values.');
						if (drawPoints5.points.length === 4) {
							if ($tab_DisplayList2DRenderer.$turnOnHacksToLookPretty && drawPoints5.points[2] - drawPoints5.points[0] === 2) {
								break;
							}
							context.setClip({ x: drawPoints5.points[0], y: drawPoints5.points[1], w: drawPoints5.points[2] - drawPoints5.points[0], h: drawPoints5.points[3] - drawPoints5.points[1] });
						}
					}
					break;
				}
				case 'draw-text': {
					{
						var drawText = item;
						if (drawText.points.length !== 2) {
							ss.Debug.fail('the draw item for a text should always specify a point with 2 values');
							return;
						}
						var xPos = drawText.points[0];
						var yPos = drawText.points[1];
						var maxTextWidth = -1;
						if (ss.isValue(enclosingRect) && enclosingRect.w !== 0 && enclosingRect.h !== 0) {
							var textStartPos;
							var rectExtent;
							if (context.get_isTextAngleHorizontal()) {
								textStartPos = ((enclosingRect.x > xPos) ? xPos : (xPos - enclosingRect.x));
								rectExtent = enclosingRect.w;
							}
							else {
								textStartPos = ((enclosingRect.y > yPos) ? yPos : (yPos - enclosingRect.y));
								rectExtent = enclosingRect.h;
							}
							maxTextWidth = Math.max(textStartPos, rectExtent - textStartPos);
						}
						this.renderText(drawText.text, xPos, yPos, maxTextWidth, null, alignNeighboringTextRuns);
					}
					break;
				}
				case 'draw-text-props': {
					{
						$tab_DisplayList2DRenderer.$applyDrawTextProps(context, item);
					}
					break;
				}
				case 'transform': {
					{
						var transformProperties = item;
						if (ss.isValue(transformProperties.transformOffset) && transformProperties.transformOffset.length === 2) {
							context.translate(transformProperties.transformOffset[0], transformProperties.transformOffset[1]);
						}
						if (ss.isValue(transformProperties.transformScale) && transformProperties.transformScale.length === 2) {
							context.scale(transformProperties.transformScale[0], transformProperties.transformScale[1]);
						}
						if (ss.isValue(transformProperties.transformAngle)) {
							context.rotate(transformProperties.transformAngle * Math.PI / 180);
						}
					}
					break;
				}
				case 'transform-pop': {
					{
						var oldStateToPreserve = new $tab_$ContextStatePreserver(context);
						context.restore();
						oldStateToPreserve.$resetState(context);
					}
					break;
				}
				case 'transform-push': {
					{
						context.save();
					}
					break;
				}
				case 'draw-antialias': {
					{
						var antialias = item;
						context.set_shouldAntialias(antialias.state);
					}
					break;
				}
				case 'draw-image': {
					{
						var imagePM = item;
						if (ss.isValue(imageDict) && imageDict.has(imagePM.imageHash)) {
							var imgData = imageDict.get(imagePM.imageHash);
							if (ss.isValue(imgData) && imgData.complete) {
								context.save();
								if (ss.isValue(mapClipRect)) {
									context.setClip(mapClipRect);
								}
								context.set_alpha(imagePM.alpha);
								context.drawImage4(imgData, imagePM.destBox[0], imagePM.destBox[1], imagePM.destBox[2] - imagePM.destBox[0], imagePM.destBox[3] - imagePM.destBox[1]);
								context.restore();
							}
						}
						else {
							tab.Log.get(context).debug("Couldn't find image dict entry when requested for hash %s", [imagePM.imageHash]);
						}
					}
					break;
				}
				default: {
					{
						ss.Debug.fail('Unknown display list directive: ' + item.type);
					}
					break;
				}
			}
		},
		$drawGroup: function DisplayList2DRenderer$DrawGroup(vlvm, drawGroup, imageDict, mapClipRect) {
			var isAnnotationsPart = ss.isValue(vlvm) && vlvm.get_visualListPM().visualPart === 'annotations';
			this.clearPrevTextRunInfo();
			var context = this.get_currentContext();
			var skipDrawItems = false;
			drawGroup.extentsX = drawGroup.extentsX || 0;
			drawGroup.extentsY = drawGroup.extentsY || 0;
			drawGroup.extentsWidth = drawGroup.extentsWidth || 0;
			drawGroup.extentsHeight = drawGroup.extentsHeight || 0;
			var extentsXY = { x: drawGroup.extentsX, y: drawGroup.extentsY, w: drawGroup.extentsWidth, h: drawGroup.extentsHeight };
			var dirtyRect = tab.RectXYUtil.offsetRect(context.dirtyRect, this.get_renderOffset());
			if (drawGroup.extentsWidth > 0 && drawGroup.extentsHeight > 0 && (!this.isRectVisible(extentsXY) || !tab.RectXYUtil.intersectsWith(dirtyRect, extentsXY))) {
				skipDrawItems = true;
			}
			var statePreserver = this.$preserveGroupState(vlvm, drawGroup, skipDrawItems);
			var drawItems = $tab_DisplayList2DRenderer.$modifyDrawItemOrderForRightAlignedText(drawGroup.drawItems, isAnnotationsPart);
			for (var $t1 = 0; $t1 < drawItems.length; $t1++) {
				var groupSubItem = drawItems[$t1];
				if (statePreserver.get_$hasPreservedState() && groupSubItem.type === 'draw-solid-brush') {
					var drawSolidBrush = groupSubItem;
					statePreserver.$shapeFillStyle = tab.ColorModel.convertColorForCanvas(drawSolidBrush.color);
				}
				else {
					var tempFilledTextStyle = null;
					if (statePreserver.get_$hasPreservedState() && groupSubItem.type === 'draw-text-props') {
						var textProperties = groupSubItem;
						statePreserver.$textFillStyle = tab.ColorModel.convertColorForCanvas(textProperties.color);
						tempFilledTextStyle = context.get_textFillStyle();
					}
					if (!skipDrawItems || $tab_DisplayList2DRenderer.$isPropertyItem(groupSubItem)) {
						this.$renderDrawItem(context, groupSubItem, imageDict, extentsXY, mapClipRect, isAnnotationsPart);
					}
					if (ss.isValue(tempFilledTextStyle)) {
						context.set_textFillStyle(ss.cast(tempFilledTextStyle, String));
					}
				}
			}
			if (statePreserver.get_$hasPreservedState()) {
				context.set_shapeFillStyle(ss.cast(statePreserver.$shapeFillStyle, String));
				context.set_textFillStyle(ss.cast(statePreserver.$textFillStyle, String));
			}
		},
		$preserveGroupState: function DisplayList2DRenderer$PreserveGroupState(vlvm, drawGroup, skipDrawItems) {
			var statePreserver = null;
			if (!skipDrawItems && ss.isValue(vlvm)) {
				if (vlvm.isSelected(drawGroup)) {
					statePreserver = new $tab_$GroupStatePreserver('selected');
				}
				else if (vlvm.isBrushed(drawGroup)) {
					statePreserver = new $tab_$GroupStatePreserver('highlighted');
				}
				else if (vlvm.isNodeOrAxisHovered(drawGroup)) {
					statePreserver = new $tab_$GroupStatePreserver('hover');
				}
			}
			if (ss.isNullOrUndefined(statePreserver)) {
				return new $tab_$GroupStatePreserver('normal');
			}
			var context = this.get_currentContext();
			statePreserver.$shapeFillStyle = context.get_shapeFillStyle();
			statePreserver.$textFillStyle = context.get_textFillStyle();
			switch (statePreserver.get_$state()) {
				case 'selected': {
					context.set_textFillStyle(this.$interactionColors.selectionTextColor.toRgba());
					context.set_shapeFillStyle(this.$interactionColors.selectionBgColor.toRgba());
					break;
				}
				case 'highlighted': {
					context.set_textFillStyle(this.$interactionColors.highlightTextColor.toRgba());
					context.set_shapeFillStyle(this.$interactionColors.highlightBgColor.toRgba());
					break;
				}
				case 'hover': {
					context.set_textFillStyle($tab_DisplayList2DRenderer.$hoveredNodeTextStyle);
					context.set_shapeFillStyle($tab_DisplayList2DRenderer.$hoveredNodeBackgroundStyle);
					break;
				}
			}
			var accountForDrawGroupExtentsOffset = ss.isValue(drawGroup.offsetX) || ss.isValue(drawGroup.offsetY);
			if (accountForDrawGroupExtentsOffset) {
				drawGroup.offsetX = drawGroup.offsetX || 0;
				drawGroup.offsetY = drawGroup.offsetY || 0;
				context.translate(-drawGroup.offsetX, -drawGroup.offsetY);
			}
			context.fillRect(drawGroup.extentsX, drawGroup.extentsY, drawGroup.extentsWidth, drawGroup.extentsHeight);
			if (accountForDrawGroupExtentsOffset) {
				context.translate(drawGroup.offsetX, drawGroup.offsetY);
			}
			return statePreserver;
		}
	}, tab.CanvasRenderer);
	ss.initClass($tab_DisplayList2DUtils, $asm, {});
	ss.initClass($tab_DownloadQueue, $asm, {
		add_complete: function DownloadQueue$add_Complete(value) {
			this.$1$CompleteField = ss.delegateCombine(this.$1$CompleteField, value);
		},
		remove_complete: function DownloadQueue$remove_Complete(value) {
			this.$1$CompleteField = ss.delegateRemove(this.$1$CompleteField, value);
		},
		add_imageLoaded: function DownloadQueue$add_ImageLoaded(value) {
			this.$1$ImageLoadedField = ss.delegateCombine(this.$1$ImageLoadedField, value);
		},
		remove_imageLoaded: function DownloadQueue$remove_ImageLoaded(value) {
			this.$1$ImageLoadedField = ss.delegateRemove(this.$1$ImageLoadedField, value);
		},
		add_imageTimedOut: function DownloadQueue$add_ImageTimedOut(value) {
			this.$1$ImageTimedOutField = ss.delegateCombine(this.$1$ImageTimedOutField, value);
		},
		remove_imageTimedOut: function DownloadQueue$remove_ImageTimedOut(value) {
			this.$1$ImageTimedOutField = ss.delegateRemove(this.$1$ImageTimedOutField, value);
		},
		addImage: function DownloadQueue$AddImage(image) {
			if (!ss.isValue(image)) {
				return;
			}
			for (var i = 0, len = this.$workers.length; i < len; i++) {
				if (!this.$workers[i].get_$busy()) {
					this.$runningWorkers++;
					this.$workers[i].$start(image);
					return;
				}
			}
			if (this.$workers.length < $tab_DownloadQueue.$maxNumWorkers) {
				var worker = new $tab_$DownloadWorker(this.$workers.length);
				worker.add_$done(ss.mkdel(this, this.onWorkerFinished));
				worker.add_$timedOut(ss.mkdel(this, this.onWorkerTimedOut));
				this.$workers.push(worker);
				this.$runningWorkers++;
				worker.$start(image);
			}
			else {
				this.$imageQueue.push(image);
			}
		},
		clear: function DownloadQueue$Clear() {
			ss.clear(this.$imageQueue);
		},
		destroy: function DownloadQueue$Destroy() {
			for (var $t1 = 0; $t1 < this.$workers.length; $t1++) {
				var worker = this.$workers[$t1];
				worker.$destroy();
			}
			ss.clear(this.$imageQueue);
			this.$1$ImageLoadedField = null;
			this.$1$ImageTimedOutField = null;
			this.$1$CompleteField = null;
		},
		onWorkerFinished: function DownloadQueue$OnWorkerFinished(sender, e) {
			if (ss.isValue(this.$1$ImageLoadedField)) {
				this.$1$ImageLoadedField(this, new $tab_ImageLoadedEventArgs(e.get_image()));
			}
			this.$handleWorkerIdled(e.get_workerID());
		},
		onWorkerTimedOut: function DownloadQueue$OnWorkerTimedOut(sender, e) {
			if (ss.isValue(this.$1$ImageTimedOutField)) {
				this.$1$ImageTimedOutField(this, ss.EventArgs.Empty);
			}
			this.$handleWorkerIdled(e.get_workerID());
		},
		$handleWorkerIdled: function DownloadQueue$HandleWorkerIdled(workerID) {
			this.$runningWorkers--;
			if (this.$imageQueue.length === 0) {
				if (this.$runningWorkers === 0) {
					if (ss.isValue(this.$1$CompleteField)) {
						this.$1$CompleteField(this, ss.EventArgs.Empty);
					}
				}
			}
			else {
				this.$workers[workerID].$start(this.$imageQueue.shift());
				this.$runningWorkers++;
			}
		}
	});
	ss.initClass($tab_EmptyContentProvider, $asm, {
		add_loadComplete: function EmptyContentProvider$add_LoadComplete(value) {
		},
		remove_loadComplete: function EmptyContentProvider$remove_LoadComplete(value) {
		},
		get_canScrollX: function EmptyContentProvider$get_CanScrollX() {
			return false;
		},
		get_canScrollY: function EmptyContentProvider$get_CanScrollY() {
			return false;
		},
		get_docSize: function EmptyContentProvider$get_DocSize() {
			return { w: 0, h: 0 };
		},
		get_actualViewSize: function EmptyContentProvider$get_ActualViewSize() {
			return { w: 0, h: 0 };
		},
		set_actualViewSize: function EmptyContentProvider$set_ActualViewSize(value) {
			tab.Log.get(this).warn('Empty content has no ActualViewSize to set', []);
		},
		get_effectiveViewSize: function EmptyContentProvider$get_EffectiveViewSize() {
			return { w: 0, h: 0 };
		},
		get_scrollPos: function EmptyContentProvider$get_ScrollPos() {
			return { x: 0, y: 0 };
		},
		set_scrollPos: function EmptyContentProvider$set_ScrollPos(value) {
			tab.Log.get(this).warn('Empty content has no ScrollPos to set', []);
		},
		get_hasContent: function EmptyContentProvider$get_HasContent() {
			return false;
		},
		setXPos: function EmptyContentProvider$SetXPos(xPos) {
			tab.Log.get(this).warn('Empty content has no X-position to set', []);
		},
		setYPos: function EmptyContentProvider$SetYPos(yPos) {
			tab.Log.get(this).warn('Empty content has no Y-position to set', []);
		},
		refreshImages: function EmptyContentProvider$RefreshImages(tileCacheUrl) {
		},
		destroy: function EmptyContentProvider$Destroy() {
		},
		reset: function EmptyContentProvider$Reset(newGeometry, newTileSize) {
			tab.Log.get(this).warn('Empty content has no geometry to set', []);
		}
	}, null, [spiff.IScrollable, tab.IRegionContentProvider]);
	ss.initClass($tab_FloatingMenuFlyoutButtonComponent, $asm, {
		render: function FloatingMenuFlyoutButtonComponent$Render() {
			var enclosingClassName = 'fztButton';
			if (this.props.isSelected) {
				enclosingClassName += ' selected';
			}
			var iconClassName = ['tab-fzt-toggle-button-icon', this.props.iconClassName, (this.props.shouldShowAppendSubIcon ? 'tab-select-tool-append-mode' : null)].join(' ');
			var mobileTooltip = (ss.isNullOrEmptyString(this.props.buttonTooltip) ? null : spiff.DOMElements.div({ className: 'tab-mobileTooltip', key: 'tooltipText' }, this.props.buttonTooltip));
			var flyoutCaret = (this.props.shouldShowFlyoutCaret ? spiff.DOMElements.div({ className: 'tab-floating-toolbar-flyout-caret', key: 'caretIcon' }) : null);
			return EventUtils.EventForwarder.span(this.$buildButtonTouchSpec(), { className: enclosingClassName, title: this.props.buttonTooltip, role: 'button' }, spiff.DOMElements.div({ className: iconClassName, key: 'buttonIcon' }), flyoutCaret, mobileTooltip);
		},
		$handleButtonTap: function FloatingMenuFlyoutButtonComponent$HandleButtonTap(ev) {
			this.props.onTap();
		},
		$buildButtonTouchSpec: function FloatingMenuFlyoutButtonComponent$BuildButtonTouchSpec() {
			var $t1 = new EventUtils.EventHandleSpec();
			$t1.tap = ss.mkdel(this, this.$handleButtonTap);
			return $t1;
		}
	}, React.Component);
	ss.initEnum($tab_FloatingToolbarButton, $asm, { radialSelect: 'radialSelect', lassoSelect: 'lassoSelect', rectangleSelect: 'rectangleSelect', appendSelect: 'appendSelect', pan: 'pan', zoomHome: 'zoomHome', close: 'close', currentSelectionTool: 'currentSelectionTool' }, true);
	ss.initClass($tab_FloatingToolbarButtonPressEventProperties, $asm, {});
	ss.initClass($tab_FloatingToolbarContainerComponent, $asm, {
		render: function FloatingToolbarContainerComponent$Render() {
			return (this.props.showToolbar ? ss.mkdel(this, this.renderContainer)() : null);
		},
		renderContainer: function FloatingToolbarContainerComponent$RenderContainer() {
			return React.createElement($tab_FloatingToolbarPositioningComponent, { getAnchorPosition: this.props.getAnchorPosition }, [this.$renderCloseButton(), (this.props.showMapsSearch ? ss.mkdel(this, this.$renderMapsSearch)() : null), this.$renderToolsFlyout()]);
		},
		$renderCloseButton: function FloatingToolbarContainerComponent$RenderCloseButton() {
			return EventUtils.EventForwarder.div(this.$buildCloseButtonTouchSpec(), { className: $tab_FloatingToolbarContainerComponent.closeButtonContainerClass, role: 'button', title: tab.Strings.PanZoomSelectToolsCloseButtonTooltipMobile, key: 'closeButton' }, spiff.DOMElements.div({ className: $tab_FloatingToolbarContainerComponent.closeButtonClass }));
		},
		$renderMapsSearch: function FloatingToolbarContainerComponent$RenderMapsSearch() {
			return React.createElement($tab_MapsSearchComponent, this.props.mapsSearchProps);
		},
		$renderToolsFlyout: function FloatingToolbarContainerComponent$RenderToolsFlyout() {
			var shouldRenderToolsButtonContainer = this.props.showTools || this.props.showPanAndZoom && !this.props.isHomeButtonHidden;
			return spiff.DOMElements.div({ className: [$tab_FloatingToolbarContainerComponent.toolButtonsRootClass, tab.Application.suppressVizTooltipsAndOverlays].join(' '), key: 'tools' }, (shouldRenderToolsButtonContainer ? ss.mkdel(this, this.$renderToolsButtonContainer)() : null), this.$renderToolsFlyoutContainer());
		},
		$renderToolsButtonContainer: function FloatingToolbarContainerComponent$RenderToolsButtonContainer() {
			return spiff.DOMElements.div({ className: $tab_FloatingToolbarContainerComponent.toolButtonsContainerClass }, (this.props.showTools ? ss.mkdel(this, this.$renderSelectedToolButton)() : null), ((this.props.showTools && this.props.showPanAndZoom) ? ss.mkdel(this, this.$renderPanButton)() : null), ((this.props.showPanAndZoom && !this.props.isHomeButtonHidden) ? ss.mkdel(this, this.$renderZoomHomeButton)() : null));
		},
		$renderSelectedToolButton: function FloatingToolbarContainerComponent$RenderSelectedToolButton() {
			return spiff.DOMElements.div({ className: $tab_FloatingToolbarContainerComponent.selectionToolContainerClass }, React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.selectedButtonProps));
		},
		$renderPanButton: function FloatingToolbarContainerComponent$RenderPanButton() {
			return React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.panButtonProps);
		},
		$renderZoomHomeButton: function FloatingToolbarContainerComponent$RenderZoomHomeButton() {
			return React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.homeButtonProps);
		},
		$renderToolsFlyoutContainer: function FloatingToolbarContainerComponent$RenderToolsFlyoutContainer() {
			var flyoutMenu = spiff.DOMElements.div({ className: $tab_FloatingToolbarContainerComponent.toolFlyoutContainerClass }, spiff.DOMElements.div({ className: $tab_FloatingToolbarContainerComponent.toolFlyoutButtonsClass }, React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.radialSelectButtonProps), React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.lassoSelectButtonProps), React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.rectangleSelectButtonProps), React.createElement($tab_FloatingMenuFlyoutButtonComponent, this.props.appendSelectButtonProps)));
			return (this.props.isFlyoutCollapsed ? null : flyoutMenu);
		},
		$handleCloseButtonTap: function FloatingToolbarContainerComponent$HandleCloseButtonTap(ev) {
			this.props.onClose();
		},
		$buildCloseButtonTouchSpec: function FloatingToolbarContainerComponent$BuildCloseButtonTouchSpec() {
			var $t1 = new EventUtils.EventHandleSpec();
			$t1.tap = ss.mkdel(this, this.$handleCloseButtonTap);
			return $t1;
		}
	}, React.Component);
	ss.initClass($tab_FloatingToolbarContainerViewModel, $asm, {
		add_dismissRequested: function FloatingToolbarContainerViewModel$add_DismissRequested(value) {
			this.$3$DismissRequestedField = ss.delegateCombine(this.$3$DismissRequestedField, value);
		},
		remove_dismissRequested: function FloatingToolbarContainerViewModel$remove_DismissRequested(value) {
			this.$3$DismissRequestedField = ss.delegateRemove(this.$3$DismissRequestedField, value);
		},
		add_toolSelectionRequested: function FloatingToolbarContainerViewModel$add_ToolSelectionRequested(value) {
			this.$3$ToolSelectionRequestedField = ss.delegateCombine(this.$3$ToolSelectionRequestedField, value);
		},
		remove_toolSelectionRequested: function FloatingToolbarContainerViewModel$remove_ToolSelectionRequested(value) {
			this.$3$ToolSelectionRequestedField = ss.delegateRemove(this.$3$ToolSelectionRequestedField, value);
		},
		add_appendModeSettingRequested: function FloatingToolbarContainerViewModel$add_AppendModeSettingRequested(value) {
			this.$3$AppendModeSettingRequestedField = ss.delegateCombine(this.$3$AppendModeSettingRequestedField, value);
		},
		remove_appendModeSettingRequested: function FloatingToolbarContainerViewModel$remove_AppendModeSettingRequested(value) {
			this.$3$AppendModeSettingRequestedField = ss.delegateRemove(this.$3$AppendModeSettingRequestedField, value);
		},
		add_zoomHomeRequested: function FloatingToolbarContainerViewModel$add_ZoomHomeRequested(value) {
			this.$3$ZoomHomeRequestedField = ss.delegateCombine(this.$3$ZoomHomeRequestedField, value);
		},
		remove_zoomHomeRequested: function FloatingToolbarContainerViewModel$remove_ZoomHomeRequested(value) {
			this.$3$ZoomHomeRequestedField = ss.delegateRemove(this.$3$ZoomHomeRequestedField, value);
		},
		get_mapsSearchViewModel: function FloatingToolbarContainerViewModel$get_MapsSearchViewModel() {
			return this.$3$MapsSearchViewModelField;
		},
		set_mapsSearchViewModel: function FloatingToolbarContainerViewModel$set_MapsSearchViewModel(value) {
			this.$3$MapsSearchViewModelField = value;
		},
		get_$isAppendMode: function FloatingToolbarContainerViewModel$get_IsAppendMode() {
			return this.$flyoutMenuButtonProps['appendSelect'].isSelected;
		},
		get_$isInPanMode: function FloatingToolbarContainerViewModel$get_IsInPanMode() {
			return this.$panButtonProps.isSelected;
		},
		get_$areOnlySelectionToolsVisible: function FloatingToolbarContainerViewModel$get_AreOnlySelectionToolsVisible() {
			return this.$showTools && !this.$showMapsSearch && !this.$showPanAndZoom && this.$isZoomHomeHidden;
		},
		get_$shouldSelectedButtonBeHighlighted: function FloatingToolbarContainerViewModel$get_ShouldSelectedButtonBeHighlighted() {
			return this.$selectedButtonProps.isSelected && !this.get_$areOnlySelectionToolsVisible();
		},
		showToolbar: function FloatingToolbarContainerViewModel$ShowToolbar(anchorPositionFunc) {
			this.$showToolbar = true;
			this.$getAnchorPosition = anchorPositionFunc;
			this.incrementProps();
			$tab_FloatingToolbarTelemetry.trackShow(this.$showMapsSearch, this.$showTools, this.$showPanAndZoom, !this.$isZoomHomeHidden);
		},
		hideToolbar: function FloatingToolbarContainerViewModel$HideToolbar() {
			if (!this.$showToolbar) {
				return;
			}
			this.$showToolbar = false;
			this.incrementProps();
		},
		showTools: function FloatingToolbarContainerViewModel$ShowTools(shouldShow) {
			this.$showTools = shouldShow;
			if (!shouldShow) {
				this.$isFlyoutCollapsed = true;
			}
			this.incrementProps();
		},
		showMapsSearch: function FloatingToolbarContainerViewModel$ShowMapsSearch() {
			this.$showMapsSearch = true;
			this.incrementProps();
		},
		hideMapsSearch: function FloatingToolbarContainerViewModel$HideMapsSearch() {
			this.$showMapsSearch = false;
			this.incrementProps();
		},
		shouldEnablePanAndZoom: function FloatingToolbarContainerViewModel$ShouldEnablePanAndZoom(shouldEnable) {
			this.$showPanAndZoom = shouldEnable;
			this.incrementProps();
		},
		updateZoomHomeState: function FloatingToolbarContainerViewModel$UpdateZoomHomeState(shouldZoomHomeBeHidden) {
			this.$isZoomHomeHidden = shouldZoomHomeBeHidden;
			this.incrementProps();
		},
		$onToolModeUpdated: function FloatingToolbarContainerViewModel$OnToolModeUpdated(tool) {
			if (tool === 'pan-map') {
				this.$setPanAsSelected();
			}
			else {
				var toolButton = $tab_FloatingToolbarContainerViewModel.$buttonForTool(tool);
				this.$setSelectedFlyoutButton(toolButton);
			}
		},
		$onAppendModeUpdated: function FloatingToolbarContainerViewModel$OnAppendModeUpdated(isAppending) {
			this.$flyoutMenuButtonProps['appendSelect'].isSelected = isAppending;
			this.$selectedButtonProps.shouldShowAppendSubIcon = isAppending;
			this.incrementProps();
		},
		$setPanAsSelected: function FloatingToolbarContainerViewModel$SetPanAsSelected() {
			this.$panButtonProps.isSelected = true;
			this.$flyoutMenuButtonProps[this.$currentlySelectedButtonId].isSelected = false;
			this.$selectedButtonProps.isSelected = false;
			this.incrementProps();
		},
		$setSelectedFlyoutButton: function FloatingToolbarContainerViewModel$SetSelectedFlyoutButton(buttonId) {
			this.$flyoutMenuButtonProps[this.$currentlySelectedButtonId].isSelected = false;
			this.$flyoutMenuButtonProps[buttonId].isSelected = true;
			this.$currentlySelectedButtonId = buttonId;
			this.$selectedButtonProps.iconClassName = this.$flyoutMenuButtonProps[buttonId].iconClassName;
			this.$selectedButtonProps.buttonTooltip = this.$flyoutMenuButtonProps[buttonId].buttonTooltip;
			this.$selectedButtonProps.isSelected = true;
			this.$panButtonProps.isSelected = false;
			this.incrementProps();
		},
		$collapseFlyout: function FloatingToolbarContainerViewModel$CollapseFlyout() {
			this.$isFlyoutCollapsed = true;
			this.incrementProps();
		},
		$onAppendButtonTap: function FloatingToolbarContainerViewModel$OnAppendButtonTap() {
			var toggledAppendMode = !this.get_$isAppendMode();
			this.raiseActionEvent$1(Boolean).call(this, this.$3$AppendModeSettingRequestedField, toggledAppendMode);
			this.$collapseFlyout();
			$tab_FloatingToolbarTelemetry.trackButtonPress('appendSelect'.toString());
		},
		$onRadialSelectTap: function FloatingToolbarContainerViewModel$OnRadialSelectTap() {
			this.$onToolButtonTap('radialSelect');
		},
		$onLassoSelectTap: function FloatingToolbarContainerViewModel$OnLassoSelectTap() {
			this.$onToolButtonTap('lassoSelect');
		},
		$onRectangleSelectTap: function FloatingToolbarContainerViewModel$OnRectangleSelectTap() {
			this.$onToolButtonTap('rectangleSelect');
		},
		$onPanTap: function FloatingToolbarContainerViewModel$OnPanTap() {
			this.$onToolButtonTap('pan');
		},
		$onToolButtonTap: function FloatingToolbarContainerViewModel$OnToolButtonTap(buttonId) {
			this.raiseActionEvent$1(Object).call(this, this.$3$ToolSelectionRequestedField, $tab_FloatingToolbarContainerViewModel.$toolForButton(buttonId));
			this.$collapseFlyout();
			$tab_FloatingToolbarTelemetry.trackButtonPress(buttonId.toString());
		},
		$onHomeButtonTap: function FloatingToolbarContainerViewModel$OnHomeButtonTap() {
			this.raiseActionEvent(this.$3$ZoomHomeRequestedField);
			this.$collapseFlyout();
			$tab_FloatingToolbarTelemetry.trackButtonPress('zoomHome'.toString());
		},
		$onSelectedButtonTap: function FloatingToolbarContainerViewModel$OnSelectedButtonTap() {
			if (this.get_$isInPanMode()) {
				this.raiseActionEvent$1(Object).call(this, this.$3$ToolSelectionRequestedField, $tab_FloatingToolbarContainerViewModel.$toolForButton(this.$currentlySelectedButtonId));
			}
			else {
				this.$isFlyoutCollapsed = !this.$isFlyoutCollapsed;
				this.incrementProps();
			}
			$tab_FloatingToolbarTelemetry.trackButtonPress('currentSelectionTool'.toString());
		},
		$onToolbarClosed: function FloatingToolbarContainerViewModel$OnToolbarClosed() {
			this.raiseActionEvent(this.$3$DismissRequestedField);
			$tab_FloatingToolbarTelemetry.trackButtonPress('close'.toString());
		},
		createInitialProps: function FloatingToolbarContainerViewModel$CreateInitialProps() {
			return { onClose: ss.mkdel(this, this.$onToolbarClosed), homeButtonProps: { iconClassName: 'tab-map-home', buttonTooltip: tab.Strings.PanZoomSelectToolsZoomHomeTooltip, onTap: ss.mkdel(this, this.$onHomeButtonTap) } };
		},
		createUpdatedProps: function FloatingToolbarContainerViewModel$CreateUpdatedProps() {
			var adjustedSelectedButtonProps = $.extend({}, this.$selectedButtonProps, { isSelected: this.get_$shouldSelectedButtonBeHighlighted() });
			return { mapsSearchProps: { viewModel: this.get_mapsSearchViewModel(), key: 'mapsSearchContainer' }, showToolbar: this.$showToolbar, showTools: this.$showTools, showMapsSearch: this.$showMapsSearch, showPanAndZoom: this.$showPanAndZoom, panButtonProps: this.$panButtonProps, radialSelectButtonProps: this.$flyoutMenuButtonProps['radialSelect'], lassoSelectButtonProps: this.$flyoutMenuButtonProps['lassoSelect'], rectangleSelectButtonProps: this.$flyoutMenuButtonProps['rectangleSelect'], appendSelectButtonProps: this.$flyoutMenuButtonProps['appendSelect'], selectedButtonProps: adjustedSelectedButtonProps, isFlyoutCollapsed: this.$isFlyoutCollapsed, isHomeButtonHidden: this.$isZoomHomeHidden, getAnchorPosition: this.$getAnchorPosition };
		}
	}, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [ss.IDisposable, tab.IViewModel, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
	ss.initClass($tab_FloatingToolbarPositioningComponent, $asm, {
		$addViewportChangeListener: function FloatingToolbarPositioningComponent$AddViewportChangeListener() {
			tab.ViewportChangeDetector.get_instance().add_viewportChanged(ss.mkdel(this, this.$onViewportChanged));
			tab.Application.get_instance().get_client().get_dashboardViewport().add_scrolled(ss.mkdel(this, this.$onViewportChanged));
		},
		$removeViewportChangeListener: function FloatingToolbarPositioningComponent$RemoveViewportChangeListener() {
			tab.ViewportChangeDetector.get_instance().remove_viewportChanged(ss.mkdel(this, this.$onViewportChanged));
			tab.Application.get_instance().get_client().get_dashboardViewport().remove_scrolled(ss.mkdel(this, this.$onViewportChanged));
		},
		componentDidMount: function FloatingToolbarPositioningComponent$ComponentDidMount() {
			this.$temporarilyHide();
			this.$addViewportChangeListener();
			this.$onViewportChanged();
		},
		componentWillUnmount: function FloatingToolbarPositioningComponent$ComponentWillUnmount() {
			this.$removeViewportChangeListener();
		},
		$temporarilyHide: function FloatingToolbarPositioningComponent$TemporarilyHide() {
			if (ss.isValue(this.$containerElement)) {
				this.$containerElement.style.display = 'none';
			}
		},
		$unhide: function FloatingToolbarPositioningComponent$Unhide() {
			if (ss.isValue(this.$containerElement)) {
				this.$containerElement.style.display = '';
			}
		},
		$onViewportChanged: function FloatingToolbarPositioningComponent$OnViewportChanged() {
			if (ss.isNullOrUndefined(tab.ViewportChangeDetector.get_instance().get_lastViewportRect())) {
				return;
			}
			this.$temporarilyHide();
			tab.WindowHelper.cancelAnimationFrame(this.$delayedRepositionRequestId);
			this.$delayedRepositionStartTime = tab.DateUtil.get_nowAsTime();
			this.$delayedRepositionRequestId = tab.WindowHelper.requestAnimationFrame(ss.mkdel(this, this.$delayedReposition));
		},
		$delayedReposition: function FloatingToolbarPositioningComponent$DelayedReposition() {
			var currentTime = tab.DateUtil.get_nowAsTime();
			if (currentTime - this.$delayedRepositionStartTime >= 300) {
				this.$reposition();
			}
			else {
				this.$delayedRepositionRequestId = tab.WindowHelper.requestAnimationFrame(ss.mkdel(this, this.$delayedReposition));
			}
		},
		$reposition: function FloatingToolbarPositioningComponent$Reposition() {
			if (ss.isValue(this.$containerElement)) {
				var dashboardViewport = tab.Application.get_instance().get_client().get_dashboardViewport();
				var browserViewportRectInPageCoords = tab.ViewportChangeDetector.get_instance().get_lastViewportRect();
				var browserViewportOriginInPageCoords = { x: browserViewportRectInPageCoords.l, y: browserViewportRectInPageCoords.t };
				var browserViewportOriginInDashboardCoords = dashboardViewport.convertPointFromPageToDashboardCoords(browserViewportOriginInPageCoords);
				var browserViewportRectInDashboardCoords = { l: browserViewportOriginInDashboardCoords.x, t: browserViewportOriginInDashboardCoords.y, w: browserViewportRectInPageCoords.w, h: browserViewportRectInPageCoords.h };
				var userVisibleRectInDashboardCoords = tab.RectUtil.intersect(browserViewportRectInDashboardCoords, dashboardViewport.get_visibleRect());
				var anchorPosInPageCoords = this.props.getAnchorPosition();
				var anchorPosInDashboardCoords = dashboardViewport.convertPointFromPageToDashboardCoords(anchorPosInPageCoords);
				this.$containerElement.style.left = Math.max(anchorPosInDashboardCoords.x, userVisibleRectInDashboardCoords.l) + 'px';
				this.$containerElement.style.top = Math.max(anchorPosInDashboardCoords.y, userVisibleRectInDashboardCoords.t) + 'px';
				this.$unhide();
			}
		},
		render: function FloatingToolbarPositioningComponent$Render() {
			return spiff.DOMElements.div({ className: 'tab-floating-toolbar-container', ref: this.$boundContainerElementRef }, this.props.children);
		}
	}, React.Component);
	ss.initClass($tab_FloatingToolbarShowEventProperties, $asm, {});
	ss.initClass($tab_FloatingToolbarTelemetry, $asm, {});
	ss.initClass($tab_FloatingZoomToolbar, $asm, {
		get_currentToolMode: function FloatingZoomToolbar$get_CurrentToolMode() {
			return this.$currentToolMode;
		},
		set_currentToolMode: function FloatingZoomToolbar$set_CurrentToolMode(value) {
			if (value !== this.$currentToolMode) {
				var oldMode = this.$currentToolMode;
				this.$currentToolMode = value;
				this.toolModeChanged(oldMode);
			}
			else if (value === this.api.defaultPointerToolMode()) {
				this.updateFlyOutVisibility(false);
				this.updateButtonState(value, true);
			}
		},
		get_floatingToolbarType: function FloatingZoomToolbar$get_FloatingToolbarType() {
			return this.toolbarType;
		},
		dispose: function FloatingZoomToolbar$Dispose() {
			try {
				this.disposables.dispose();
			}
			catch ($t1) {
				tab.Log.get(this).warn('fzt dismantle dom fail', []);
			}
			if (ss.isValue(this.buttonContainer)) {
				this.buttonContainer.remove();
			}
			if (ss.isValue(this.flyOutButtons)) {
				this.flyOutButtons.remove();
			}
			if (ss.isValue(this.flyOutContainer)) {
				this.flyOutContainer.remove();
			}
			this.api = null;
			this.buttonContainer = null;
			this.flyOutButtons = null;
			this.flyOutContainer = null;
			this.zoomInButton = null;
			this.zoomOutButton = null;
			this.zoomAreaButton = null;
			this.zoomHomeButton = null;
			this.flyOutButton = null;
			this.rectSelectButton = null;
			this.radialSelectButton = null;
			this.lassoSelectButton = null;
			this.panButton = null;
			spiff.Widget.prototype.dispose.call(this);
		},
		setZoomHomePossibility: function FloatingZoomToolbar$SetZoomHomePossibility(state) {
			this.canZoomHome = state;
			if (this.toolbarType === 'homeOnlyToolbar') {
				this.setActiveState(this.canZoomHome);
			}
		},
		setActiveState: function FloatingZoomToolbar$SetActiveState(isVisible) {
			if (this.toolbarType === 'homeOnlyToolbar' && !this.canZoomHome) {
				this.element.css({ display: 'none' });
			}
			else {
				this.element.css({ display: (isVisible ? '' : 'none') });
			}
			if (!isVisible) {
				this.updateFlyOutVisibility(false);
			}
		},
		resetPointerToolMode: function FloatingZoomToolbar$ResetPointerToolMode() {
			this.set_currentToolMode(this.api.defaultPointerToolMode());
			this.api.setPointerToolMode(this.get_currentToolMode(), false);
			this.updateFlyOutVisibility(false);
		},
		resetVisualState: function FloatingZoomToolbar$ResetVisualState() {
			this.updateFlyOutVisibility(false);
		},
		enableUserInteraction: function FloatingZoomToolbar$EnableUserInteraction(enable) {
			this.element.css({ 'pointer-events': (enable ? 'auto' : 'none') });
			this.$acceptingInteraction = enable;
		},
		init: function FloatingZoomToolbar$Init() {
			this.createButtons();
			this.resetPointerToolMode();
			this.setActiveState(false);
		},
		createButtons: null,
		setupEventHandling: function FloatingZoomToolbar$SetupEventHandling() {
			if (ss.isValue(this.rectSelectButton)) {
				this.disposables.add$1(this.rectSelectButton.onClick(ss.mkdel(this, function() {
					this.setToolMode('rectangular-selection', true);
					if (tsConfig.is_authoring) {
						tab.FloatingToolbarClientCommands.setDefaultMapToolSelectionCommand('rectangular-selection');
					}
				})));
				this.disposables.add$1(this.rectSelectButton.onShiftClick(ss.mkdel(this, function() {
					this.setToolMode('rectangular-selection', true);
				})));
			}
			if (ss.isValue(this.panButton)) {
				this.disposables.add$1(this.panButton.onClick(ss.mkdel(this, function() {
					this.setToolMode('pan-map', true);
					if (tsConfig.is_authoring) {
						tab.FloatingToolbarClientCommands.setDefaultMapToolSelectionCommand('pan-map');
					}
				})));
				this.disposables.add$1(this.panButton.onShiftClick(ss.mkdel(this, function() {
					this.setToolMode('pan-map', true);
				})));
			}
			if (ss.isValue(this.radialSelectButton)) {
				this.disposables.add$1(this.radialSelectButton.onClick(ss.mkdel(this, function() {
					this.setToolMode('radial-selection', true);
					if (tsConfig.is_authoring) {
						tab.FloatingToolbarClientCommands.setDefaultMapToolSelectionCommand('radial-selection');
					}
				})));
				this.disposables.add$1(this.radialSelectButton.onShiftClick(ss.mkdel(this, function() {
					this.setToolMode('radial-selection', true);
				})));
			}
			if (ss.isValue(this.lassoSelectButton)) {
				this.disposables.add$1(this.lassoSelectButton.onClick(ss.mkdel(this, function() {
					this.setToolMode('lasso-selection', true);
					if (tsConfig.is_authoring) {
						tab.FloatingToolbarClientCommands.setDefaultMapToolSelectionCommand('lasso-selection');
					}
				})));
				this.disposables.add$1(this.lassoSelectButton.onShiftClick(ss.mkdel(this, function() {
					this.setToolMode('lasso-selection', true);
				})));
			}
			if (ss.isValue(this.zoomHomeButton)) {
				this.disposables.add$1(this.zoomHomeButton.onClick(ss.mkdel(this, function() {
					this.clickZoomHome();
				})));
			}
		},
		updateFlyOutVisibility: function FloatingZoomToolbar$UpdateFlyOutVisibility(isVisible) {
			if (ss.isValue(this.flyOutContainer)) {
				this.flyOutContainer.css({ display: (isVisible ? '' : 'none') });
			}
		},
		toggleFlyout: function FloatingZoomToolbar$ToggleFlyout(e) {
			if (!this.$acceptingInteraction) {
				return;
			}
			if (this.flyOutContainer.is(':visible')) {
				this.updateFlyOutVisibility(false);
			}
			else {
				var pos = this.flyOutButton.element.position();
				var width = tab.DoubleUtil.roundToInt(this.flyOutButton.element.width());
				this.flyOutContainer.css({ top: pos.top + 'px', left: width + 'px' });
				this.updateFlyOutVisibility(true);
			}
		},
		addButton: function FloatingZoomToolbar$AddButton(container, klass, tooltipLabel) {
			var $t1 = new spiff.Button($(document.createElement('div')));
			$t1.set_hoverTooltipText(tooltipLabel);
			var btn = $t1;
			this.$appendButton(container, btn, klass);
			return btn;
		},
		addToggleButton: function FloatingZoomToolbar$AddToggleButton(container, klass, tooltipLabel) {
			var $t1 = new spiff.ToggleButton($(document.createElement('span')), null);
			$t1.set_hoverTooltipText(tooltipLabel);
			var btn = $t1;
			this.$appendButton(container, btn, klass);
			return btn;
		},
		addSpacer: function FloatingZoomToolbar$AddSpacer() {
			var div = $(document.createElement('div'));
			div.addClass('fztSpacer');
			this.buttonContainer.append(div);
		},
		$appendButton: function FloatingZoomToolbar$AppendButton(container, btn, klass) {
			btn.element.addClass(klass);
			btn.element.addClass('fztButton');
			container.append(btn.element);
			this.disposables.add$1(btn);
		},
		setToolMode: function FloatingZoomToolbar$SetToolMode(mode, isLocked) {
			if (mode === this.get_currentToolMode()) {
				this.set_currentToolMode(this.api.defaultPointerToolMode());
			}
			else {
				this.set_currentToolMode(mode);
			}
			this.api.setPointerToolMode(this.get_currentToolMode(), isLocked);
		},
		clickZoomHome: function FloatingZoomToolbar$ClickZoomHome() {
			if (this.canZoomHome) {
				this.api.zoomHome();
			}
		},
		createButtonContainer: function FloatingZoomToolbar$CreateButtonContainer() {
			this.buttonContainer = $("<div class='fztButtonContainer'/>");
			this.element.append(this.buttonContainer);
			if (ss.isValue(this.parent)) {
				this.parent.append(this.element);
			}
		},
		createButtonFlyOut: function FloatingZoomToolbar$CreateButtonFlyOut() {
			this.flyOutContainer = $("<div class='fztFlyOutContainer'/>");
			this.updateFlyOutVisibility(false);
			this.element.append(this.flyOutContainer);
			this.flyOutButtons = $("<div class='fztFlyOutButtons'/>");
			this.flyOutContainer.append(this.flyOutButtons);
		},
		updateButtonState: function FloatingZoomToolbar$UpdateButtonState(mode, isSelected) {
			switch (mode) {
				case 'area-zoom':
				case 'zoom-out': {
					this.selectButton(this.zoomAreaButton, isSelected);
					break;
				}
				case 'pan-map': {
					if (ss.isValue(this.panButton)) {
						this.selectButton(this.panButton, isSelected);
					}
					break;
				}
				case 'rectangular-selection': {
					if (ss.isValue(this.rectSelectButton)) {
						this.selectButton(this.rectSelectButton, isSelected);
					}
					break;
				}
				case 'radial-selection': {
					this.selectButton(this.radialSelectButton, isSelected);
					break;
				}
				case 'lasso-selection': {
					this.selectButton(this.lassoSelectButton, isSelected);
					break;
				}
				default: {
					break;
				}
			}
		},
		selectButton: function FloatingZoomToolbar$SelectButton(btn, isSelected) {
			var toggleBtn = ss.safeCast(btn, spiff.ToggleButton);
			if (ss.isValue(toggleBtn)) {
				toggleBtn.set_selected(isSelected);
			}
		},
		toolModeChanged: function FloatingZoomToolbar$ToolModeChanged(oldMode) {
			this.updateButtonState(oldMode, false);
			this.updateButtonState(this.get_currentToolMode(), true);
			this.updateFlyOutVisibility(false);
		}
	}, spiff.Widget, [tab.IWidget, tab.IAppendableView, ss.IDisposable]);
	ss.initClass($tab_FloatingZoomToolbarView, $asm, {
		get_toolBarIsOffOrHome: function FloatingZoomToolbarView$get_ToolBarIsOffOrHome() {
			return ss.isNullOrUndefined(this.zoomToolbar) || this.zoomToolbar.get_floatingToolbarType() === 'homeOnlyToolbar';
		},
		resetPointerToolbarMode: function FloatingZoomToolbarView$ResetPointerToolbarMode() {
			if (ss.isNullOrUndefined(this.zoomToolbar) && this.$zoomToolbarVisibility !== 'hide') {
				this.createZoomToolbar();
			}
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.resetPointerToolMode();
				return true;
			}
			return false;
		},
		updateZoomToolbar: function FloatingZoomToolbarView$UpdateZoomToolbar(toolbarVisibility) {
			var visibilityChanged = this.$zoomToolbarVisibility !== toolbarVisibility;
			this.$zoomToolbarVisibility = toolbarVisibility;
			if (ss.isValue(this.zoomToolbar) && visibilityChanged) {
				this.zoomToolbar.dispose();
				this.zoomToolbar = null;
				if (this.$zoomToolbarVisibility !== 'hide') {
					this.createZoomToolbar();
					this.showFloatingZoomToolbar(true);
				}
			}
			if (this.$zoomToolbarContainer.get_shouldEnableZoomHomeToolbar() && ss.isNullOrUndefined(this.zoomToolbar)) {
				this.createZoomToolbar();
			}
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.setZoomHomePossibility(this.$zoomToolbarContainer.get_shouldEnableZoomHomeToolbar());
			}
		},
		determineToolbarType: function FloatingZoomToolbarView$DetermineToolbarType() {
			var toolbarType = 'fullToolbar';
			if (!this.$zoomToolbarContainer.get_shouldShowTools()) {
				toolbarType = 'homeOnlyToolbar';
			}
			else if (!this.$zoomToolbarContainer.allowPanZoomActions()) {
				toolbarType = 'disablePanZoomToolbar';
			}
			if (tsConfig.is_mobile) {
				if (toolbarType === 'fullToolbar' && this.$zoomToolbarContainer.isVizLargerThanScreen()) {
					return 'disablePanZoomToolbar';
				}
			}
			return toolbarType;
		},
		showFloatingZoomToolbar: function FloatingZoomToolbarView$ShowFloatingZoomToolbar(show) {
			if (show && this.$zoomToolbarVisibility !== 'hide' && ss.isNullOrUndefined(this.zoomToolbar)) {
				this.createZoomToolbar();
			}
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.setZoomHomePossibility(this.$zoomToolbarContainer.get_shouldEnableZoomHomeToolbar());
				this.zoomToolbar.setActiveState(show);
			}
		},
		createZoomToolbar: function FloatingZoomToolbarView$CreateZoomToolbar() {
			if (!tsConfig.allow_filter) {
				return;
			}
			var shouldShowNewFloatingToolbar = tsConfig.is_mobile && tab.GestureModelSettings.get_newModelEnabled();
			if (ss.isNullOrUndefined(this.zoomToolbar) && !shouldShowNewFloatingToolbar) {
				var containerDiv = this.$zoomToolbarContainer.get_zoomToolbarContainerDiv();
				var mapSearchEnabled = this.$zoomToolbarContainer.get_isMapSearchEnabled();
				var api = this.$zoomToolbarContainer.get_zoomToolbarOperations();
				var toolbarType = this.determineToolbarType();
				var topOffset = this.$zoomToolbarContainer.get_zoomToolbarOffset();
				var floatingZoomToolbar = tab.ObjectRegistry.resolve($tab_FloatingZoomToolbar).call(null, [containerDiv, api, toolbarType, topOffset, mapSearchEnabled]);
				floatingZoomToolbar.addClass(tab.Application.suppressVizTooltipsAndOverlays);
				this.zoomToolbar = floatingZoomToolbar;
			}
		},
		enableUserInteraction: function FloatingZoomToolbarView$EnableUserInteraction(enable) {
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.enableUserInteraction(enable);
			}
		},
		resetVisualState: function FloatingZoomToolbarView$ResetVisualState() {
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.resetVisualState();
			}
		},
		setToolMode: function FloatingZoomToolbarView$SetToolMode(mode, isLocked) {
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.setToolMode(mode, isLocked);
				return true;
			}
			return false;
		},
		dispose: function FloatingZoomToolbarView$Dispose() {
			if (ss.isValue(this.zoomToolbar)) {
				this.zoomToolbar.dispose();
			}
		}
	}, null, [ss.IDisposable]);
	ss.initClass($tab_GeometryUtil, $asm, {});
	ss.initClass($tab_GotoMyLocationButton, $asm, {
		get_button: function GotoMyLocationButton$get_Button() {
			return this.$button;
		},
		$handleButtonClick: function GotoMyLocationButton$HandleButtonClick() {
			var options = { timeout: $tab_GotoMyLocationButton.$getCurrentPositionRequestTimeout, enableHighAccuracy: true };
			window.navigator.geolocation.getCurrentPosition(ss.mkdel(this, this.$currentPositionCallback), ss.mkdel(this, this.$errorCallback), options);
			if (tsConfig.is_mobile) {
				$tab_FloatingToolbarTelemetry.trackButtonPress($tab_GotoMyLocationButton.telemetryToolName);
			}
		},
		$currentPositionCallback: function GotoMyLocationButton$CurrentPositionCallback(location) {
			tab.Log.get(this).debug('Current location: (%o, %o)', [location.coords.latitude, location.coords.longitude]);
			var mapRect = {};
			var latitudeDegreesDelta = Math.abs(0.0063306021306998);
			var absLatitude = Math.abs(location.coords.latitude);
			var absBoxRadiusLatitude = 89.9936693978693;
			if (absLatitude > absBoxRadiusLatitude) {
				mapRect.minLatitude = ((location.coords.latitude < 0) ? -90 : (location.coords.latitude - latitudeDegreesDelta));
				mapRect.maxLatitude = ((location.coords.latitude < 0) ? (location.coords.latitude + latitudeDegreesDelta) : 90);
			}
			else {
				mapRect.minLatitude = location.coords.latitude - latitudeDegreesDelta;
				mapRect.maxLatitude = location.coords.latitude + latitudeDegreesDelta;
			}
			var longitudeDelta;
			var latitudeCosine = Math.cos($tab_GeometryUtil.degreeToRad(absLatitude));
			var threshold = 3.49343234718729E-05;
			if (latitudeCosine < threshold) {
				longitudeDelta = 180;
			}
			else {
				longitudeDelta = $tab_GotoMyLocationButton.$centeringBoxRadiusInKm / ($tab_GotoMyLocationButton.$oneDegreeLongitudeAtEquatorInKm * latitudeCosine);
			}
			mapRect.minLongitude = location.coords.longitude - longitudeDelta;
			mapRect.maxLongitude = location.coords.longitude + longitudeDelta;
			tab.MapClientCommands.boundingBoxPan(this.$visualIdPresModel, mapRect);
		},
		$buildErrorMessage: function GotoMyLocationButton$BuildErrorMessage(error) {
			var errorMessage = '';
			if (error.code === error.PERMISSION_DENIED) {
				if ($tab_GotoMyLocationButton.$browserRequiresSSLForLocationRequests()) {
					errorMessage = tab.Strings.GotoMyLocationPermissionDeniedUnsecureConnection;
				}
				else {
					errorMessage = tab.Strings.GotoMyLocationPermissionDeniedError;
				}
			}
			else if (error.code === error.TIMEOUT) {
				errorMessage = tab.Strings.GotoMyLocationTimeoutError;
			}
			else if (error.code === error.POSITION_UNAVAILABLE) {
				if ($tab_GotoMyLocationButton.$browserRequiresSSLForLocationRequests()) {
					errorMessage = tab.Strings.GotoMyLocationPermissionDeniedUnsecureConnection;
				}
				else {
					errorMessage = tab.Strings.GotoMyLocationPositionUnavailableError;
				}
			}
			else {
				errorMessage = tab.Strings.GotoMyLocationPositionUnavailableError;
			}
			return errorMessage;
		},
		$errorCallback: function GotoMyLocationButton$ErrorCallback(error) {
			var errorMessage = this.$buildErrorMessage(error);
			var buttonPos = this.element.offset();
			var notificationPos = { x: tab.DoubleUtil.roundToInt(buttonPos.left) + tab.DoubleUtil.roundToInt(this.element.width()) + $tab_GotoMyLocationButton.$buttonNotificationHorizontalPadding, y: tab.DoubleUtil.roundToInt(buttonPos.top) };
			if (tsConfig.is_mobile) {
				notificationPos.y += ss.Int32.div(tab.DoubleUtil.roundToInt(this.element.height()), 4);
			}
			tab.NotificationViewModel.showGeoLocationNotification(errorMessage, -1, { x: notificationPos.x, y: notificationPos.y });
		}
	}, spiff.Widget, [tab.IWidget, tab.IAppendableView, ss.IDisposable]);
	ss.initClass($tab_GridLinesRenderer, $asm, {
		$renderPath: function GridLinesRenderer$RenderPath(startX, startY, endX, endY) {
			var path = [startX, startY, endX, endY];
			tab.CanvasRenderer.strokePath(this.get_currentContext(), path, false, true);
		},
		$updateContextForGridLine: function GridLinesRenderer$UpdateContextForGridLine(color, linePattern, lineWidth) {
			this.get_currentContext().set_linePattern(linePattern);
			this.get_currentContext().set_lineCap(((linePattern === 'solid') ? 'square' : 'butt'));
			this.get_currentContext().set_strokeStyle(tab.ColorModel.fromArgbInt(color).toString());
			this.get_currentContext().set_lineWidth(lineWidth);
		},
		renderGridLines: function GridLinesRenderer$RenderGridLines(runtimeData, colIndex, rowIndex, paneRect) {
			var gridlines = runtimeData.GridLines;
			var tickPlacement = runtimeData.TickPlacement;
			var paneCount = runtimeData.PaneCount;
			var axisOutput = runtimeData.AxisOutput;
			var yIndex = rowIndex + paneCount.ColumnCount;
			if (!$tab_GridLinesRenderer.$linesToRender(gridlines, tickPlacement, colIndex, yIndex)) {
				return;
			}
			this.get_currentContext().save();
			this.get_currentContext().set_lineJoin(tab.TabRenderContext2D.defaultLineJoin);
			this.get_currentContext().set_shouldAntialias(false);
			this.get_currentContext().setClip(paneRect);
			var xReversed = $tab_GridLinesRenderer.$isReverseX(axisOutput, colIndex);
			var yReversed = $tab_GridLinesRenderer.$isReverseY(axisOutput, rowIndex);
			var xZero = ($tab_GridLinesRenderer.$zeroLineInDataStoreX(gridlines, colIndex) ? $tab_GridLinesRenderer.$calculatePointX(paneRect, gridlines.ZeroPoint[colIndex], xReversed) : Number.NaN);
			var yZero = ($tab_GridLinesRenderer.$zeroLineInDataStoreY(gridlines, yIndex) ? $tab_GridLinesRenderer.$calculatePointY(paneRect, gridlines.ZeroPoint[yIndex], yReversed) : Number.NaN);
			if ($tab_GridLinesRenderer.$tickPlacementInDataStore(tickPlacement)) {
				if ($tab_GridLinesRenderer.$gridLinesInDataStoreX(gridlines)) {
					this.$updateContextForGridLine(gridlines.X.LineColor, tab.EnumConversions.linePatternFromInt(gridlines.X.LineStyle), gridlines.X.LineWidth);
					var tpcX = new tab.TickPlacementConfig(xReversed, true, false);
					var ticks = tab.TickPlacement.getTickPlacement(tickPlacement, paneRect, colIndex, tpcX);
					var startY = paneRect.y;
					var endY = paneRect.y + paneRect.h;
					for (var $t1 = 0; $t1 < ticks.length; $t1++) {
						var x = ticks[$t1];
						if (!(x === xZero)) {
							this.$renderPath(x, startY, x, endY);
						}
					}
				}
				if ($tab_GridLinesRenderer.$gridLinesInDataStoreY(gridlines)) {
					this.$updateContextForGridLine(gridlines.Y.LineColor, tab.EnumConversions.linePatternFromInt(gridlines.Y.LineStyle), gridlines.Y.LineWidth);
					var tpcY = new tab.TickPlacementConfig(yReversed, false, false);
					var ticks1 = tab.TickPlacement.getTickPlacement(tickPlacement, paneRect, yIndex, tpcY);
					var startX = paneRect.x;
					var endX = paneRect.x + paneRect.w;
					for (var $t2 = 0; $t2 < ticks1.length; $t2++) {
						var y = ticks1[$t2];
						if (!(y === yZero)) {
							this.$renderPath(startX, y, endX, y);
						}
					}
				}
			}
			if (!isNaN(xZero)) {
				this.$updateContextForGridLine(gridlines.X.ZeroLineColor, tab.EnumConversions.linePatternFromInt(gridlines.X.ZeroLineStyle), gridlines.X.ZeroLineWidth);
				var x1 = ss.round(xZero);
				if (x1 >= paneRect.x && x1 <= paneRect.x + paneRect.w) {
					this.$renderPath(x1, paneRect.y, x1, paneRect.y + paneRect.h);
				}
			}
			if (!isNaN(yZero)) {
				this.$updateContextForGridLine(gridlines.Y.ZeroLineColor, tab.EnumConversions.linePatternFromInt(gridlines.Y.ZeroLineStyle), gridlines.Y.ZeroLineWidth);
				var y1 = ss.round(yZero);
				if (y1 >= paneRect.y && y1 <= paneRect.y + paneRect.h) {
					this.$renderPath(paneRect.x, y1, paneRect.x + paneRect.w, y1);
				}
			}
			this.get_currentContext().restore();
		}
	}, tab.CanvasRenderer);
	ss.initClass($tab_MarksRenderer, $asm, {
		renderMultipolygonMark: function MarksRenderer$RenderMultipolygonMark(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			this.get_currentContext().save();
			switch (renderPass) {
				case 'normalUnderPass': {
					if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender, offset) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
								for (var markIndex = firstMark; markIndex <= lastMark; markIndex++) {
									if (marksNotToRender.has(markIndex)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex) !== 'markStateNormal') {
										continue;
									}
									this.drawMultipolygonMarkLayer(paneDrawInfo, markIndex, 'normalUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideNone';
							{
								paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender1, offset1) {
									$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
									for (var markIndex1 = firstMark; markIndex1 <= lastMark; markIndex1++) {
										if (marksNotToRender1.has(markIndex1)) {
											continue;
										}
										if (!paneDrawInfo.markNeedsDraw(markIndex1)) {
											continue;
										}
										if (paneDrawInfo.getMarkState(markIndex1) !== 'markStateHighlighted') {
											continue;
										}
										this.drawMultipolygonMarkLayer(paneDrawInfo, markIndex1, 'normalUnder', colorOverrideMode);
									}
									if (!tab.DoubleUtil.isApproximatelyEqual(offset1, 0)) {
										this.get_currentContext().restore();
									}
								}));
							}
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					{
						paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender2, offset2) {
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
							for (var markIndex2 = firstMark; markIndex2 <= lastMark; markIndex2++) {
								if (marksNotToRender2.has(markIndex2)) {
									continue;
								}
								if (!paneDrawInfo.markNeedsDraw(markIndex2)) {
									continue;
								}
								if (paneDrawInfo.getMarkState(markIndex2) !== 'markStateNormal') {
									continue;
								}
								this.drawMultipolygonMarkLayer(paneDrawInfo, markIndex2, 'normalOn', colorOverrideMode);
							}
							if (!tab.DoubleUtil.isApproximatelyEqual(offset2, 0)) {
								this.get_currentContext().restore();
							}
						}));
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender3, offset3) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
								for (var markIndex3 = firstMark; markIndex3 <= lastMark; markIndex3++) {
									if (marksNotToRender3.has(markIndex3)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex3)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex3) !== 'markStateHighlighted') {
										continue;
									}
									this.drawMultipolygonMarkLayer(paneDrawInfo, markIndex3, 'normalOn', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset3, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender4, offset4) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset4);
								for (var markIndex4 = firstMark; markIndex4 <= lastMark; markIndex4++) {
									if (marksNotToRender4.has(markIndex4)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex4)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex4) !== 'markStateSelected') {
										continue;
									}
									this.drawMultipolygonMarkLayer(paneDrawInfo, markIndex4, 'selectedUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset4, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender5, offset5) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset5);
								for (var markIndex5 = firstMark; markIndex5 <= lastMark; markIndex5++) {
									if (marksNotToRender5.has(markIndex5)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex5)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex5) !== 'markStateSelected') {
										continue;
									}
									this.drawMultipolygonMarkLayer(paneDrawInfo, markIndex5, 'normalOn', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset5, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawMultipolygonMarkLayer: function MarksRenderer$DrawMultipolygonMarkLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			var sizeOffset = ((layer !== 'normalOn') ? 0 : $tab_MarksRenderer.get_$multipolyLineSizeOffset());
			var geometryType = 'empty';
			var geometryPM = paneDrawInfo.getMarkGeometry(paneDrawInfo.c.get('geometry').gv(markIndex));
			if (ss.isValue(geometryPM)) {
				geometryType = geometryPM.geometryType;
			}
			switch (geometryType) {
				case 'multiPolygon': {
					if (!paneDrawInfo.hasPixelGeometry) {
						this.get_currentContext().save();
						this.get_currentContext().translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
						this.get_currentContext().scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
					}
					tab.CanvasRenderer.createMultipolygonPath(this.get_currentContext(), geometryPM);
					if (!paneDrawInfo.hasPixelGeometry) {
						this.get_currentContext().restore();
					}
					switch (layer) {
						case 'normalUnder': {
							{
								this.strokeCurrentPath(2 - sizeOffset, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'selectedUnder': {
							{
								this.strokeCurrentPath(2 - sizeOffset, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'normalOn': {
							{
								this.fillCurrentPath(paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
							}
							if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
								this.strokeCurrentPath(1 - sizeOffset, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						default: {
							break;
						}
					}
					break;
				}
				case 'multiLineString': {
					if (!paneDrawInfo.hasPixelGeometry) {
						this.get_currentContext().save();
						this.get_currentContext().translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
						this.get_currentContext().scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
					}
					tab.CanvasRenderer.createMultiLinePath(this.get_currentContext(), geometryPM);
					if (!paneDrawInfo.hasPixelGeometry) {
						this.get_currentContext().restore();
					}
					switch (layer) {
						case 'normalUnder': {
							{
								tab.CanvasRenderer.fillMultiLineStringPath(this.get_currentContext(), paneDrawInfo.c.get('size').gv(markIndex) + 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
							}
							{
								tab.CanvasRenderer.fillMultiLineStringEndCaps(this.get_currentContext(), geometryPM.multiLine, paneDrawInfo.c.get('size').gv(markIndex) + 4, 2, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'selectedUnder': {
							{
								tab.CanvasRenderer.fillMultiLineStringPath(this.get_currentContext(), paneDrawInfo.c.get('size').gv(markIndex) + 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							}
							{
								tab.CanvasRenderer.fillMultiLineStringEndCaps(this.get_currentContext(), geometryPM.multiLine, paneDrawInfo.c.get('size').gv(markIndex) + 4, 2, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'normalOn': {
							{
								tab.CanvasRenderer.fillMultiLineStringPath(this.get_currentContext(), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
							}
							break;
						}
						default: {
							break;
						}
					}
					break;
				}
				case 'multiPoint': {
					if (!paneDrawInfo.hasPixelGeometry) {
						this.get_currentContext().save();
						this.get_currentContext().translate(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex));
						this.get_currentContext().scale(paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex));
					}
					tab.CanvasRenderer.createMultipointPath(this.get_currentContext(), 7, geometryPM);
					if (!paneDrawInfo.hasPixelGeometry) {
						this.get_currentContext().restore();
					}
					switch (layer) {
						case 'normalUnder': {
							{
								this.strokeCurrentPath(2 - sizeOffset, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'selectedUnder': {
							{
								this.strokeCurrentPath(2 - sizeOffset, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'normalOn': {
							{
								this.fillCurrentPath(paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
							}
							if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
								this.strokeCurrentPath(1 - sizeOffset, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						default: {
							break;
						}
					}
					break;
				}
				case 'empty': {
					tab.CanvasRenderer.createPlaceholderPath(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), 7);
					switch (layer) {
						case 'normalUnder': {
							{
								this.strokeCurrentPath(2 - sizeOffset, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'selectedUnder': {
							{
								this.strokeCurrentPath(2 - sizeOffset, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						case 'normalOn': {
							{
								this.fillCurrentPath(paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
							}
							if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
								this.strokeCurrentPath(1 - sizeOffset, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode]);
							}
							break;
						}
						default: {
							break;
						}
					}
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderAreaMark: function MarksRenderer$RenderAreaMark(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			var lineDrawState = paneDrawInfo.get_lineDrawState();
			this.get_currentContext().save();
			switch (renderPass) {
				case 'normalUnderPass': {
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					var $t1 = lineDrawState.get_lineAttributes();
					for (var $t2 = 0; $t2 < $t1.length; $t2++) {
						var currentLine = $t1[$t2];
						if (currentLine.get_lineState() !== 'lineStateNormal') {
							continue;
						}
						var offsets = currentLine.worldOffsets;
						var offsetCount = offsets.length;
						for (var index = 0; index < offsetCount; index++) {
							var offset = offsets[index];
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
							{
								for (var $t3 = 0; $t3 < currentLine.marksNeedingDraw.length; $t3++) {
									var markIndex = currentLine.marksNeedingDraw[$t3];
									this.drawAreaMarkLayer(paneDrawInfo, markIndex, 'edgeOn', colorOverrideMode, currentLine.startIndex);
								}
							}
							if (offset !== 0) {
								this.get_currentContext().restore();
							}
						}
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						var $t4 = lineDrawState.get_lineAttributes();
						for (var $t5 = 0; $t5 < $t4.length; $t5++) {
							var currentLine1 = $t4[$t5];
							if (currentLine1.get_lineState() !== 'lineStateHighlighted') {
								continue;
							}
							var offsets1 = currentLine1.worldOffsets;
							var offsetCount1 = offsets1.length;
							for (var index1 = 0; index1 < offsetCount1; index1++) {
								var offset1 = offsets1[index1];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
								{
									for (var $t6 = 0; $t6 < currentLine1.marksNeedingDraw.length; $t6++) {
										var markIndex1 = currentLine1.marksNeedingDraw[$t6];
										this.drawAreaMarkLayer(paneDrawInfo, markIndex1, 'edgeOn', colorOverrideMode, currentLine1.startIndex);
									}
								}
								if (offset1 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
						var $t7 = lineDrawState.get_lineAttributes();
						for (var $t8 = 0; $t8 < $t7.length; $t8++) {
							var currentLine2 = $t7[$t8];
							if (currentLine2.get_lineState() !== 'lineStateHighlighted') {
								continue;
							}
							var offsets2 = currentLine2.worldOffsets;
							var offsetCount2 = offsets2.length;
							for (var index2 = 0; index2 < offsetCount2; index2++) {
								var offset2 = offsets2[index2];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
								if (!currentLine2.get_allHighlighted()) {
									{
										for (var $t9 = 0; $t9 < currentLine2.marksNeedingDraw.length; $t9++) {
											var markIndex2 = currentLine2.marksNeedingDraw[$t9];
											if (paneDrawInfo.getMarkState(markIndex2) === 'markStateHighlighted') {
												this.drawAreaMarkLayer(paneDrawInfo, markIndex2, 'highlightedUnder1', colorOverrideMode, currentLine2.startIndex);
												this.drawAreaMarkLayer(paneDrawInfo, markIndex2, 'highlightedUnder', colorOverrideMode, currentLine2.startIndex);
											}
										}
									}
									{
										for (var $t10 = 0; $t10 < currentLine2.marksNeedingDraw.length; $t10++) {
											var markIndex3 = currentLine2.marksNeedingDraw[$t10];
											if (paneDrawInfo.getMarkState(markIndex3) === 'markStateHighlighted') {
												this.drawAreaMarkLayer(paneDrawInfo, markIndex3, 'highlightedOn1', colorOverrideMode, currentLine2.startIndex);
												this.drawAreaMarkLayer(paneDrawInfo, markIndex3, 'highlightedOn', colorOverrideMode, currentLine2.startIndex);
											}
										}
									}
								}
								if (offset2 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						var $t11 = lineDrawState.get_lineAttributes();
						for (var $t12 = 0; $t12 < $t11.length; $t12++) {
							var currentLine3 = $t11[$t12];
							if (currentLine3.get_lineState() !== 'lineStateSelected') {
								continue;
							}
							var offsets3 = currentLine3.worldOffsets;
							var offsetCount3 = offsets3.length;
							for (var index3 = 0; index3 < offsetCount3; index3++) {
								var offset3 = offsets3[index3];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
								{
									for (var $t13 = 0; $t13 < currentLine3.marksNeedingDraw.length; $t13++) {
										var markIndex4 = currentLine3.marksNeedingDraw[$t13];
										this.drawAreaMarkLayer(paneDrawInfo, markIndex4, 'edgeOn', colorOverrideMode, currentLine3.startIndex);
									}
								}
								if (offset3 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
						var $t14 = lineDrawState.get_lineAttributes();
						for (var $t15 = 0; $t15 < $t14.length; $t15++) {
							var currentLine4 = $t14[$t15];
							if (currentLine4.get_lineState() !== 'lineStateSelected') {
								continue;
							}
							var offsets4 = currentLine4.worldOffsets;
							var offsetCount4 = offsets4.length;
							for (var index4 = 0; index4 < offsetCount4; index4++) {
								var offset4 = offsets4[index4];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset4);
								if (!currentLine4.get_allHighlighted()) {
									{
										for (var $t16 = 0; $t16 < currentLine4.marksNeedingDraw.length; $t16++) {
											var markIndex5 = currentLine4.marksNeedingDraw[$t16];
											if (paneDrawInfo.getMarkState(markIndex5) === 'markStateHighlighted') {
												this.drawAreaMarkLayer(paneDrawInfo, markIndex5, 'highlightedUnder1', colorOverrideMode, currentLine4.startIndex);
												this.drawAreaMarkLayer(paneDrawInfo, markIndex5, 'highlightedUnder', colorOverrideMode, currentLine4.startIndex);
											}
										}
									}
									{
										for (var $t17 = 0; $t17 < currentLine4.marksNeedingDraw.length; $t17++) {
											var markIndex6 = currentLine4.marksNeedingDraw[$t17];
											if (paneDrawInfo.getMarkState(markIndex6) === 'markStateHighlighted') {
												this.drawAreaMarkLayer(paneDrawInfo, markIndex6, 'highlightedOn1', colorOverrideMode, currentLine4.startIndex);
												this.drawAreaMarkLayer(paneDrawInfo, markIndex6, 'highlightedOn', colorOverrideMode, currentLine4.startIndex);
											}
										}
									}
								}
								if (offset4 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
						var $t18 = lineDrawState.get_lineAttributes();
						for (var $t19 = 0; $t19 < $t18.length; $t19++) {
							var currentLine5 = $t18[$t19];
							if (currentLine5.get_lineState() !== 'lineStateSelected') {
								continue;
							}
							var offsets5 = currentLine5.worldOffsets;
							var offsetCount5 = offsets5.length;
							for (var index5 = 0; index5 < offsetCount5; index5++) {
								var offset5 = offsets5[index5];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset5);
								{
									for (var $t20 = 0; $t20 < currentLine5.marksNeedingDraw.length; $t20++) {
										var markIndex7 = currentLine5.marksNeedingDraw[$t20];
										if (paneDrawInfo.getMarkState(markIndex7) === 'markStateSelected') {
											this.drawAreaMarkLayer(paneDrawInfo, markIndex7, 'selectedUnder1', colorOverrideMode, currentLine5.startIndex);
											this.drawAreaMarkLayer(paneDrawInfo, markIndex7, 'selectedUnder', colorOverrideMode, currentLine5.startIndex);
										}
									}
								}
								{
									for (var $t21 = 0; $t21 < currentLine5.marksNeedingDraw.length; $t21++) {
										var markIndex8 = currentLine5.marksNeedingDraw[$t21];
										if (paneDrawInfo.getMarkState(markIndex8) === 'markStateSelected') {
											this.drawAreaMarkLayer(paneDrawInfo, markIndex8, 'selectedOn1', colorOverrideMode, currentLine5.startIndex);
											this.drawAreaMarkLayer(paneDrawInfo, markIndex8, 'selectedOn', colorOverrideMode, currentLine5.startIndex);
										}
									}
								}
								if (offset5 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawAreaMarkLayer: function MarksRenderer$DrawAreaMarkLayer(paneDrawInfo, markIndex, layer, colorOverrideMode, startIndex) {
			var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
			var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
			var clipCase = paneDrawInfo.clipCase;
			if (clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			var drawBorder = paneDrawInfo.drawBorder;
			switch (layer) {
				case 'edgeOn': {
					if (paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1) {
						var points = [Math.round(paneDrawInfo.c.get('x1').gv(markIndex)), Math.round(paneDrawInfo.c.get('y1').gv(markIndex)), Math.round(paneDrawInfo.c.get('x1').gv(right)), Math.round(paneDrawInfo.c.get('y1').gv(right)), Math.round(paneDrawInfo.c.get('x_prev').gv(right)), Math.round(paneDrawInfo.c.get('y_prev').gv(right)), Math.round(paneDrawInfo.c.get('x_next').gv(markIndex)), Math.round(paneDrawInfo.c.get('y_next').gv(markIndex))];
						this.get_currentContext().set_lineJoin('miter');
						this.$renderFilledPolygon(points, paneDrawInfo.getMarkColors(startIndex)[colorOverrideMode]);
					}
					if (drawBorder && paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1) {
						var points1 = [paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x1').gv(right), paneDrawInfo.c.get('y1').gv(right)];
						this.$renderLine(points1, 1, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], true);
					}
					if (drawBorder && paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1) {
						var points2 = [paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex), paneDrawInfo.c.get('x_prev').gv(right), paneDrawInfo.c.get('y_prev').gv(right)];
						this.$renderLine(points2, 1, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], true);
					}
					if (drawBorder && (paneDrawInfo.c.get('l_neighbor').gv(markIndex) !== -1 && paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1)) {
						var points3 = [paneDrawInfo.c.get('x_prev').gv(markIndex), paneDrawInfo.c.get('y_prev').gv(markIndex), paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex)];
						this.$renderLine(points3, 1, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], true);
					}
					if (drawBorder && paneDrawInfo.c.get('l_neighbor').gv(markIndex) === -1) {
						var points4 = [paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex)];
						this.$renderLine(points4, 1, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], true);
					}
					if (drawBorder && paneDrawInfo.c.get('r_neighbor').gv(markIndex) === -1) {
						var points5 = [paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x_prev').gv(markIndex), paneDrawInfo.c.get('y_prev').gv(markIndex)];
						this.$renderLine(points5, 1, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], true);
					}
					if (!drawBorder && paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1) {
						var points6 = [paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x1').gv(right), paneDrawInfo.c.get('y1').gv(right)];
						this.$renderLine(points6, 1, paneDrawInfo.getMarkColors(startIndex)[colorOverrideMode], true);
					}
					if (!drawBorder && paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1) {
						var points7 = [paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex), paneDrawInfo.c.get('x_prev').gv(right), paneDrawInfo.c.get('y_prev').gv(right)];
						this.$renderLine(points7, 1, paneDrawInfo.getMarkColors(startIndex)[colorOverrideMode], true);
					}
					if (!drawBorder && (paneDrawInfo.c.get('l_neighbor').gv(markIndex) !== -1 && paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1)) {
						var points8 = [paneDrawInfo.c.get('x_prev').gv(markIndex), paneDrawInfo.c.get('y_prev').gv(markIndex), paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex)];
						this.$renderLine(points8, 1, paneDrawInfo.getMarkColors(startIndex)[colorOverrideMode], true);
					}
					if (!drawBorder && paneDrawInfo.c.get('l_neighbor').gv(markIndex) === -1) {
						var points9 = [paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x_next').gv(markIndex), paneDrawInfo.c.get('y_next').gv(markIndex)];
						this.$renderLine(points9, 1, paneDrawInfo.getMarkColors(startIndex)[colorOverrideMode], true);
					}
					if (!drawBorder && paneDrawInfo.c.get('r_neighbor').gv(markIndex) === -1) {
						var points10 = [paneDrawInfo.c.get('x1').gv(markIndex), paneDrawInfo.c.get('y1').gv(markIndex), paneDrawInfo.c.get('x_prev').gv(markIndex), paneDrawInfo.c.get('y_prev').gv(markIndex)];
						this.$renderLine(points10, 1, paneDrawInfo.getMarkColors(startIndex)[colorOverrideMode], true);
					}
					break;
				}
				case 'selectedOn': {
					{
						tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x1').gv(markIndex), 0 + paneDrawInfo.c.get('y1').gv(markIndex), 5, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x1').gv(markIndex), 0 + paneDrawInfo.c.get('y1').gv(markIndex), 5, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'selectedOn1': {
					{
						tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), 5, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
					}
					break;
				}
				case 'selectedUnder1': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), 5, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'highlightedOn': {
					{
						tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x1').gv(markIndex), 0 + paneDrawInfo.c.get('y1').gv(markIndex), 5, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
					}
					break;
				}
				case 'highlightedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x1').gv(markIndex), 0 + paneDrawInfo.c.get('y1').gv(markIndex), 5, paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'highlightedOn1': {
					{
						tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), 5, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
					}
					break;
				}
				case 'highlightedUnder1': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), 5, paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				default: {
					break;
				}
			}
			if (clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderMarkLabels: function MarksRenderer$RenderMarkLabels(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			this.get_currentContext().save();
			var styleSetter = this.$setupContextForTextRendering(paneDrawInfo);
			switch (renderPass) {
				case 'normalUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					{
						var sceneDirtyRect = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
						for (var markIndex = firstMark; markIndex <= lastMark; markIndex++) {
							if (!paneDrawInfo.markHasLabel(markIndex) || !paneDrawInfo.markLabelNeedsDraw(markIndex, sceneDirtyRect)) {
								continue;
							}
							if (paneDrawInfo.getMarkLabelState(markIndex) !== 'markStateNormal') {
								continue;
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().save();
								this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
							}
							var offsets = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex);
							var offsetCount = offsets.length;
							for (var index = 0; index < offsetCount; index++) {
								var offset = offsets[index];
								if (offset !== 0) {
									this.get_currentContext().save();
									this.get_currentContext().translate(offset, 0);
								}
								this.drawMarkLabelLayer(paneDrawInfo, markIndex, 'normalUnder', colorOverrideMode);
								if (offset !== 0) {
									this.get_currentContext().restore();
								}
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().restore();
							}
						}
					}
					colorOverrideMode = 'colorOverrideNone';
					{
						var sceneDirtyRect1 = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
						for (var markIndex1 = firstMark; markIndex1 <= lastMark; markIndex1++) {
							if (!paneDrawInfo.markHasLabel(markIndex1) || !paneDrawInfo.markLabelNeedsDraw(markIndex1, sceneDirtyRect1)) {
								continue;
							}
							if (paneDrawInfo.getMarkLabelState(markIndex1) !== 'markStateHighlighted') {
								continue;
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().save();
								this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex1), paneDrawInfo.c.get('cell_y').gv(markIndex1), paneDrawInfo.c.get('clip_width').gv(markIndex1), paneDrawInfo.c.get('clip_height').gv(markIndex1));
							}
							var offsets1 = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex1);
							var offsetCount1 = offsets1.length;
							for (var index1 = 0; index1 < offsetCount1; index1++) {
								var offset1 = offsets1[index1];
								if (offset1 !== 0) {
									this.get_currentContext().save();
									this.get_currentContext().translate(offset1, 0);
								}
								this.drawMarkLabelLayer(paneDrawInfo, markIndex1, 'normalUnder', colorOverrideMode);
								if (offset1 !== 0) {
									this.get_currentContext().restore();
								}
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().restore();
							}
						}
					}
					colorOverrideMode = 'colorOverrideNone';
					{
						var sceneDirtyRect2 = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
						for (var markIndex2 = firstMark; markIndex2 <= lastMark; markIndex2++) {
							if (!paneDrawInfo.markHasLabel(markIndex2) || !paneDrawInfo.markLabelNeedsDraw(markIndex2, sceneDirtyRect2)) {
								continue;
							}
							if (paneDrawInfo.getMarkLabelState(markIndex2) !== 'markStateSelected') {
								continue;
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().save();
								this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex2), paneDrawInfo.c.get('cell_y').gv(markIndex2), paneDrawInfo.c.get('clip_width').gv(markIndex2), paneDrawInfo.c.get('clip_height').gv(markIndex2));
							}
							var offsets2 = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex2);
							var offsetCount2 = offsets2.length;
							for (var index2 = 0; index2 < offsetCount2; index2++) {
								var offset2 = offsets2[index2];
								if (offset2 !== 0) {
									this.get_currentContext().save();
									this.get_currentContext().translate(offset2, 0);
								}
								this.drawMarkLabelLayer(paneDrawInfo, markIndex2, 'normalUnder', colorOverrideMode);
								if (offset2 !== 0) {
									this.get_currentContext().restore();
								}
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().restore();
							}
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					{
						var sceneDirtyRect3 = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
						for (var markIndex3 = firstMark; markIndex3 <= lastMark; markIndex3++) {
							if (!paneDrawInfo.markHasLabel(markIndex3) || !paneDrawInfo.markLabelNeedsDraw(markIndex3, sceneDirtyRect3)) {
								continue;
							}
							if (paneDrawInfo.getMarkLabelState(markIndex3) !== 'markStateNormal') {
								continue;
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().save();
								this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex3), paneDrawInfo.c.get('cell_y').gv(markIndex3), paneDrawInfo.c.get('clip_width').gv(markIndex3), paneDrawInfo.c.get('clip_height').gv(markIndex3));
							}
							var offsets3 = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex3);
							var offsetCount3 = offsets3.length;
							for (var index3 = 0; index3 < offsetCount3; index3++) {
								var offset3 = offsets3[index3];
								if (offset3 !== 0) {
									this.get_currentContext().save();
									this.get_currentContext().translate(offset3, 0);
								}
								var drawRunsInReverse = false;
								var textRunOffset = paneDrawInfo.getMarkLabelProperty('text_run_offset', markIndex3);
								var numRuns = paneDrawInfo.getMarkLabelProperty('text_run_count', markIndex3);
								var multipleRuns = numRuns > 1;
								for (var runNum = 0; runNum < numRuns; runNum++) {
									var runId = runNum + textRunOffset;
									if (runNum === 0) {
										var styleId = paneDrawInfo.getTextRunProperty('text_style_id', runId);
										styleSetter(styleId);
										drawRunsInReverse = this.get_currentContext().get_textAlign() === 'end';
									}
									if (drawRunsInReverse) {
										runId = textRunOffset + numRuns - runNum - 1;
									}
									this.drawLabelRunLayer(paneDrawInfo, markIndex3, 'normalOn', colorOverrideMode, runId, multipleRuns, styleSetter);
								}
								this.clearPrevTextRunInfo();
								if (offset3 !== 0) {
									this.get_currentContext().restore();
								}
							}
							if (paneDrawInfo.get_clipLabelToCell()) {
								this.get_currentContext().restore();
							}
						}
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						{
							var sceneDirtyRect4 = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
							for (var markIndex4 = firstMark; markIndex4 <= lastMark; markIndex4++) {
								if (!paneDrawInfo.markHasLabel(markIndex4) || !paneDrawInfo.markLabelNeedsDraw(markIndex4, sceneDirtyRect4)) {
									continue;
								}
								if (paneDrawInfo.getMarkLabelState(markIndex4) !== 'markStateHighlighted') {
									continue;
								}
								if (paneDrawInfo.get_clipLabelToCell()) {
									this.get_currentContext().save();
									this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex4), paneDrawInfo.c.get('cell_y').gv(markIndex4), paneDrawInfo.c.get('clip_width').gv(markIndex4), paneDrawInfo.c.get('clip_height').gv(markIndex4));
								}
								var offsets4 = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex4);
								var offsetCount4 = offsets4.length;
								for (var index4 = 0; index4 < offsetCount4; index4++) {
									var offset4 = offsets4[index4];
									if (offset4 !== 0) {
										this.get_currentContext().save();
										this.get_currentContext().translate(offset4, 0);
									}
									var drawRunsInReverse1 = false;
									var textRunOffset1 = paneDrawInfo.getMarkLabelProperty('text_run_offset', markIndex4);
									var numRuns1 = paneDrawInfo.getMarkLabelProperty('text_run_count', markIndex4);
									var multipleRuns1 = numRuns1 > 1;
									for (var runNum1 = 0; runNum1 < numRuns1; runNum1++) {
										var runId1 = runNum1 + textRunOffset1;
										if (runNum1 === 0) {
											var styleId1 = paneDrawInfo.getTextRunProperty('text_style_id', runId1);
											styleSetter(styleId1);
											drawRunsInReverse1 = this.get_currentContext().get_textAlign() === 'end';
										}
										if (drawRunsInReverse1) {
											runId1 = textRunOffset1 + numRuns1 - runNum1 - 1;
										}
										this.drawLabelRunLayer(paneDrawInfo, markIndex4, 'highlightedOn', colorOverrideMode, runId1, multipleRuns1, styleSetter);
									}
									this.clearPrevTextRunInfo();
									if (offset4 !== 0) {
										this.get_currentContext().restore();
									}
								}
								if (paneDrawInfo.get_clipLabelToCell()) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							var sceneDirtyRect5 = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
							for (var markIndex5 = firstMark; markIndex5 <= lastMark; markIndex5++) {
								if (!paneDrawInfo.markHasLabel(markIndex5) || !paneDrawInfo.markLabelNeedsDraw(markIndex5, sceneDirtyRect5)) {
									continue;
								}
								if (paneDrawInfo.getMarkLabelState(markIndex5) !== 'markStateSelected') {
									continue;
								}
								if (paneDrawInfo.get_clipLabelToCell()) {
									this.get_currentContext().save();
									this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex5), paneDrawInfo.c.get('cell_y').gv(markIndex5), paneDrawInfo.c.get('clip_width').gv(markIndex5), paneDrawInfo.c.get('clip_height').gv(markIndex5));
								}
								var offsets5 = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex5);
								var offsetCount5 = offsets5.length;
								for (var index5 = 0; index5 < offsetCount5; index5++) {
									var offset5 = offsets5[index5];
									if (offset5 !== 0) {
										this.get_currentContext().save();
										this.get_currentContext().translate(offset5, 0);
									}
									this.drawMarkLabelLayer(paneDrawInfo, markIndex5, 'selectedUnder', colorOverrideMode);
									if (offset5 !== 0) {
										this.get_currentContext().restore();
									}
								}
								if (paneDrawInfo.get_clipLabelToCell()) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							var sceneDirtyRect6 = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
							for (var markIndex6 = firstMark; markIndex6 <= lastMark; markIndex6++) {
								if (!paneDrawInfo.markHasLabel(markIndex6) || !paneDrawInfo.markLabelNeedsDraw(markIndex6, sceneDirtyRect6)) {
									continue;
								}
								if (paneDrawInfo.getMarkLabelState(markIndex6) !== 'markStateSelected') {
									continue;
								}
								if (paneDrawInfo.get_clipLabelToCell()) {
									this.get_currentContext().save();
									this.clipRect(3, paneDrawInfo.c.get('cell_x').gv(markIndex6), paneDrawInfo.c.get('cell_y').gv(markIndex6), paneDrawInfo.c.get('clip_width').gv(markIndex6), paneDrawInfo.c.get('clip_height').gv(markIndex6));
								}
								var offsets6 = paneDrawInfo.getMarkLabelInstanceOffsets(markIndex6);
								var offsetCount6 = offsets6.length;
								for (var index6 = 0; index6 < offsetCount6; index6++) {
									var offset6 = offsets6[index6];
									if (offset6 !== 0) {
										this.get_currentContext().save();
										this.get_currentContext().translate(offset6, 0);
									}
									var drawRunsInReverse2 = false;
									var textRunOffset2 = paneDrawInfo.getMarkLabelProperty('text_run_offset', markIndex6);
									var numRuns2 = paneDrawInfo.getMarkLabelProperty('text_run_count', markIndex6);
									var multipleRuns2 = numRuns2 > 1;
									for (var runNum2 = 0; runNum2 < numRuns2; runNum2++) {
										var runId2 = runNum2 + textRunOffset2;
										if (runNum2 === 0) {
											var styleId2 = paneDrawInfo.getTextRunProperty('text_style_id', runId2);
											styleSetter(styleId2);
											drawRunsInReverse2 = this.get_currentContext().get_textAlign() === 'end';
										}
										if (drawRunsInReverse2) {
											runId2 = textRunOffset2 + numRuns2 - runNum2 - 1;
										}
										this.drawLabelRunLayer(paneDrawInfo, markIndex6, 'normalOn', colorOverrideMode, runId2, multipleRuns2, styleSetter);
									}
									this.clearPrevTextRunInfo();
									if (offset6 !== 0) {
										this.get_currentContext().restore();
									}
								}
								if (paneDrawInfo.get_clipLabelToCell()) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawMarkLabelLayer: function MarksRenderer$DrawMarkLabelLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			switch (layer) {
				case 'normalUnder': {
					{
						if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
							var markX = paneDrawInfo.getMarkLabelProperty('x', markIndex);
							var markY = paneDrawInfo.getMarkLabelProperty('y', markIndex);
							var width = paneDrawInfo.getMarkLabelProperty('width', markIndex);
							var height = -paneDrawInfo.getMarkLabelProperty('height', markIndex);
							if (height < 0) {
								markY += height;
								height = Math.abs(height);
							}
							var leftOffset = 0;
							var bottomOffset = 0;
							var color;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color = paneDrawInfo.getMarkLabelProperty('halo_color', markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX + leftOffset, markY + bottomOffset, width, height, color, 0, 0, false);
						}
					}
					{
						if (paneDrawInfo.isMarkDebug(markIndex)) {
							var markX1 = paneDrawInfo.getMarkLabelProperty('x', markIndex);
							var markY1 = paneDrawInfo.getMarkLabelProperty('y', markIndex);
							var width1 = paneDrawInfo.getMarkLabelProperty('width', markIndex);
							var height1 = -paneDrawInfo.getMarkLabelProperty('height', markIndex);
							if (height1 < 0) {
								markY1 += height1;
								height1 = Math.abs(height1);
							}
							var leftOffset1 = 0;
							var bottomOffset1 = 0;
							var color1;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color1 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color1 = paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX1 + leftOffset1, markY1 + bottomOffset1, width1, height1, color1, 0, 0, false);
						}
					}
					break;
				}
				case 'normalOn': {
					break;
				}
				case 'highlightedUnder': {
					{
						if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
							var markX2 = paneDrawInfo.getMarkLabelProperty('x', markIndex);
							var markY2 = paneDrawInfo.getMarkLabelProperty('y', markIndex);
							var width2 = paneDrawInfo.getMarkLabelProperty('width', markIndex);
							var height2 = -paneDrawInfo.getMarkLabelProperty('height', markIndex);
							if (height2 < 0) {
								markY2 += height2;
								height2 = Math.abs(height2);
							}
							var leftOffset2 = 0;
							var bottomOffset2 = 0;
							var color2;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color2 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color2 = paneDrawInfo.getMarkLabelProperty('halo_color', markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX2 + leftOffset2, markY2 + bottomOffset2, width2, height2, color2, 0, 0, false);
						}
					}
					{
						if (paneDrawInfo.isMarkDebug(markIndex)) {
							var markX3 = paneDrawInfo.getMarkLabelProperty('x', markIndex);
							var markY3 = paneDrawInfo.getMarkLabelProperty('y', markIndex);
							var width3 = paneDrawInfo.getMarkLabelProperty('width', markIndex);
							var height3 = -paneDrawInfo.getMarkLabelProperty('height', markIndex);
							if (height3 < 0) {
								markY3 += height3;
								height3 = Math.abs(height3);
							}
							var leftOffset3 = 0;
							var bottomOffset3 = 0;
							var color3;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color3 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color3 = paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX3 + leftOffset3, markY3 + bottomOffset3, width3, height3, color3, 0, 0, false);
						}
					}
					break;
				}
				case 'highlightedOn': {
					break;
				}
				case 'selectedUnder': {
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		drawTextRunLayer: function MarksRenderer$DrawTextRunLayer(paneDrawInfo, markIndex, layer, colorOverrideMode, runId, multipleRuns, styleSetter) {
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			switch (layer) {
				case 'normalUnder': {
					break;
				}
				case 'normalOn': {
					var styleId = paneDrawInfo.getTextRunProperty('text_style_id', runId);
					styleSetter(styleId);
					var color = paneDrawInfo.$getTextStyleColor(styleId, markIndex, colorOverrideMode);
					var textRun = paneDrawInfo.getTextRunProperty('text_run', runId);
					var x = paneDrawInfo.getMarkLabelProperty('x', markIndex) + paneDrawInfo.getTextRunProperty('text_run_x', runId);
					var y = paneDrawInfo.getMarkLabelProperty('y', markIndex) + paneDrawInfo.getTextRunProperty('text_run_y', runId);
					var maxSize = (this.get_currentContext().get_isTextAngleHorizontal() ? paneDrawInfo.getMarkLabelProperty('width', markIndex) : paneDrawInfo.getMarkLabelProperty('height', markIndex));
					this.renderText(textRun, x, y, maxSize, color, multipleRuns);
					break;
				}
				case 'highlightedUnder': {
					break;
				}
				case 'highlightedOn': {
					var styleId1 = paneDrawInfo.getTextRunProperty('text_style_id', runId);
					styleSetter(styleId1);
					var color1 = paneDrawInfo.$getTextStyleColor(styleId1, markIndex, colorOverrideMode);
					var textRun1 = paneDrawInfo.getTextRunProperty('text_run', runId);
					var x1 = paneDrawInfo.getMarkLabelProperty('x', markIndex) + paneDrawInfo.getTextRunProperty('text_run_x', runId);
					var y1 = paneDrawInfo.getMarkLabelProperty('y', markIndex) + paneDrawInfo.getTextRunProperty('text_run_y', runId);
					var maxSize1 = (this.get_currentContext().get_isTextAngleHorizontal() ? paneDrawInfo.getMarkLabelProperty('width', markIndex) : paneDrawInfo.getMarkLabelProperty('height', markIndex));
					this.renderText(textRun1, x1, y1, maxSize1, color1, multipleRuns);
					break;
				}
				case 'selectedUnder': {
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		drawLabelRunLayer: function MarksRenderer$DrawLabelRunLayer(paneDrawInfo, markIndex, layer, colorOverrideMode, runId, multipleRuns, styleSetter) {
			if (paneDrawInfo.get_clipLabelToCell() && paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			switch (layer) {
				case 'normalUnder': {
					break;
				}
				case 'normalOn': {
					var styleId = paneDrawInfo.getTextRunProperty('text_style_id', runId);
					styleSetter(styleId);
					var color = paneDrawInfo.$getTextStyleColor(styleId, markIndex, colorOverrideMode);
					var textRun = paneDrawInfo.getTextRunProperty('text_run', runId);
					var x = paneDrawInfo.getMarkLabelProperty('x', markIndex) + paneDrawInfo.getTextRunProperty('text_run_x', runId);
					var y = paneDrawInfo.getMarkLabelProperty('y', markIndex) + paneDrawInfo.getTextRunProperty('text_run_y', runId);
					var maxSize = (this.get_currentContext().get_isTextAngleHorizontal() ? paneDrawInfo.getMarkLabelProperty('width', markIndex) : paneDrawInfo.getMarkLabelProperty('height', markIndex));
					this.renderText(textRun, x, y, maxSize, color, multipleRuns);
					break;
				}
				case 'highlightedUnder': {
					break;
				}
				case 'highlightedOn': {
					var styleId1 = paneDrawInfo.getTextRunProperty('text_style_id', runId);
					styleSetter(styleId1);
					var color1 = paneDrawInfo.$getTextStyleColor(styleId1, markIndex, colorOverrideMode);
					var textRun1 = paneDrawInfo.getTextRunProperty('text_run', runId);
					var x1 = paneDrawInfo.getMarkLabelProperty('x', markIndex) + paneDrawInfo.getTextRunProperty('text_run_x', runId);
					var y1 = paneDrawInfo.getMarkLabelProperty('y', markIndex) + paneDrawInfo.getTextRunProperty('text_run_y', runId);
					var maxSize1 = (this.get_currentContext().get_isTextAngleHorizontal() ? paneDrawInfo.getMarkLabelProperty('width', markIndex) : paneDrawInfo.getMarkLabelProperty('height', markIndex));
					this.renderText(textRun1, x1, y1, maxSize1, color1, multipleRuns);
					break;
				}
				case 'selectedUnder': {
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.get_clipLabelToCell() && paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderPieMark: function MarksRenderer$RenderPieMark(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			var lineDrawState = paneDrawInfo.get_lineDrawState();
			this.get_currentContext().save();
			switch (renderPass) {
				case 'normalUnderPass': {
					if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						var $t1 = lineDrawState.get_lineAttributes();
						for (var $t2 = 0; $t2 < $t1.length; $t2++) {
							var currentLine = $t1[$t2];
							var offsets = currentLine.worldOffsets;
							var offsetCount = offsets.length;
							for (var index = 0; index < offsetCount; index++) {
								var offset = offsets[index];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
								{
									for (var $t3 = 0; $t3 < currentLine.marksNeedingDraw.length; $t3++) {
										var markIndex = currentLine.marksNeedingDraw[$t3];
										this.drawPieMarkLayer(paneDrawInfo, markIndex, 'normalUnder', colorOverrideMode);
									}
								}
								if (offset !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					var $t4 = lineDrawState.get_lineAttributes();
					for (var $t5 = 0; $t5 < $t4.length; $t5++) {
						var currentLine1 = $t4[$t5];
						if (currentLine1.get_lineState() !== 'lineStateNormal') {
							continue;
						}
						var offsets1 = currentLine1.worldOffsets;
						var offsetCount1 = offsets1.length;
						for (var index1 = 0; index1 < offsetCount1; index1++) {
							var offset1 = offsets1[index1];
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
							{
								for (var $t6 = 0; $t6 < currentLine1.marksNeedingDraw.length; $t6++) {
									var markIndex1 = currentLine1.marksNeedingDraw[$t6];
									this.drawPieMarkLayer(paneDrawInfo, markIndex1, 'normalOn', colorOverrideMode);
								}
							}
							if (offset1 !== 0) {
								this.get_currentContext().restore();
							}
						}
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						var $t7 = lineDrawState.get_lineAttributes();
						for (var $t8 = 0; $t8 < $t7.length; $t8++) {
							var currentLine2 = $t7[$t8];
							if (currentLine2.get_lineState() !== 'lineStateHighlighted') {
								continue;
							}
							var offsets2 = currentLine2.worldOffsets;
							var offsetCount2 = offsets2.length;
							for (var index2 = 0; index2 < offsetCount2; index2++) {
								var offset2 = offsets2[index2];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
								colorOverrideMode = 'colorOverrideFog';
								{
									for (var $t9 = 0; $t9 < currentLine2.marksNeedingDraw.length; $t9++) {
										var markIndex2 = currentLine2.marksNeedingDraw[$t9];
										if (paneDrawInfo.getMarkState(markIndex2) !== 'markStateNormal') {
											continue;
										}
										this.drawPieMarkLayer(paneDrawInfo, markIndex2, 'normalOn', colorOverrideMode);
									}
								}
								colorOverrideMode = 'colorOverrideNone';
								{
									for (var $t10 = 0; $t10 < currentLine2.marksNeedingDraw.length; $t10++) {
										var markIndex3 = currentLine2.marksNeedingDraw[$t10];
										if (paneDrawInfo.getMarkState(markIndex3) !== 'markStateHighlighted') {
											continue;
										}
										this.drawPieMarkLayer(paneDrawInfo, markIndex3, 'highlightedOn', colorOverrideMode);
									}
								}
								if (offset2 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						var $t11 = lineDrawState.get_lineAttributes();
						for (var $t12 = 0; $t12 < $t11.length; $t12++) {
							var currentLine3 = $t11[$t12];
							if (currentLine3.get_lineState() !== 'lineStateSelected') {
								continue;
							}
							var offsets3 = currentLine3.worldOffsets;
							var offsetCount3 = offsets3.length;
							for (var index3 = 0; index3 < offsetCount3; index3++) {
								var offset3 = offsets3[index3];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
								colorOverrideMode = 'colorOverrideFog';
								{
									for (var $t13 = 0; $t13 < currentLine3.marksNeedingDraw.length; $t13++) {
										var markIndex4 = currentLine3.marksNeedingDraw[$t13];
										if (paneDrawInfo.getMarkState(markIndex4) !== 'markStateNormal') {
											continue;
										}
										this.drawPieMarkLayer(paneDrawInfo, markIndex4, 'normalOn', colorOverrideMode);
									}
								}
								colorOverrideMode = 'colorOverrideNone';
								{
									for (var $t14 = 0; $t14 < currentLine3.marksNeedingDraw.length; $t14++) {
										var markIndex5 = currentLine3.marksNeedingDraw[$t14];
										if (paneDrawInfo.getMarkState(markIndex5) !== 'markStateHighlighted') {
											continue;
										}
										this.drawPieMarkLayer(paneDrawInfo, markIndex5, 'highlightedOn', colorOverrideMode);
									}
								}
								colorOverrideMode = 'colorOverrideOpaque';
								{
									for (var $t15 = 0; $t15 < currentLine3.marksNeedingDraw.length; $t15++) {
										var markIndex6 = currentLine3.marksNeedingDraw[$t15];
										if (paneDrawInfo.getMarkState(markIndex6) !== 'markStateSelected') {
											continue;
										}
										this.drawPieMarkLayer(paneDrawInfo, markIndex6, 'selectedUnder', colorOverrideMode);
									}
								}
								{
									for (var $t16 = 0; $t16 < currentLine3.marksNeedingDraw.length; $t16++) {
										var markIndex7 = currentLine3.marksNeedingDraw[$t16];
										if (paneDrawInfo.getMarkState(markIndex7) !== 'markStateSelected') {
											continue;
										}
										this.drawPieMarkLayer(paneDrawInfo, markIndex7, 'selectedOn', colorOverrideMode);
									}
								}
								if (offset3 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawPieMarkLayer: function MarksRenderer$DrawPieMarkLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			switch (layer) {
				case 'normalUnder': {
					var radius = paneDrawInfo.c.get('size').gv(markIndex) / 2;
					{
						var theta = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta1 = paneDrawInfo.c.get('theta1').gv(markIndex);
						var anticlockwise = theta > theta1;
						var color = paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
						var conditionallyDrawn = false;
						if (Math.abs(theta - theta1) >= 1) {
							tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius * 2, color, 4);
						}
						else {
							tab.CanvasRenderer.renderWedge(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius, theta, theta1, color, 4, anticlockwise, conditionallyDrawn);
						}
					}
					break;
				}
				case 'normalOn': {
					var radius1 = paneDrawInfo.c.get('size').gv(markIndex) / 2;
					{
						var theta2 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta11 = paneDrawInfo.c.get('theta1').gv(markIndex);
						if (theta2 > theta11) {
							var temp = theta2;
							theta2 = theta11;
							theta11 = temp;
						}
						var xPos = paneDrawInfo.c.get('x').gv(markIndex);
						var yPos = paneDrawInfo.c.get('y').gv(markIndex);
						var color1 = paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode];
						if (paneDrawInfo.c.get('alpha').gv(markIndex) >= 1) {
							var canvasAngle = tab.CanvasRenderer.toCanvasAngle(theta2);
							var canvasAngle2 = tab.CanvasRenderer.toCanvasAngle(theta11);
							if (Math.abs(canvasAngle2 - canvasAngle) >= tab.CanvasRenderer.angleEpsilon) {
								this.get_currentContext().beginPath();
								this.get_currentContext().set_lineCap('butt');
								this.get_currentContext().set_lineWidth(1.5);
								this.get_currentContext().set_strokeStyle(color1);
								this.get_currentContext().moveTo(xPos, yPos);
								this.get_currentContext().lineTo(xPos + Math.cos(canvasAngle) * radius1, yPos + Math.sin(canvasAngle) * radius1);
								this.get_currentContext().stroke();
							}
						}
						if (Math.abs(theta2 - theta11) >= 1) {
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), xPos, yPos, radius1 * 2, color1);
						}
						else {
							this.renderFilledWedge(xPos, yPos, radius1, theta2, theta11, color1);
						}
					}
					if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
						var theta3 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta12 = paneDrawInfo.c.get('theta1').gv(markIndex);
						var anticlockwise1 = theta3 > theta12;
						var color2 = paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode];
						var conditionallyDrawn1 = true;
						if (Math.abs(theta3 - theta12) >= 1) {
							tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius1 * 2, color2, 1);
						}
						else {
							tab.CanvasRenderer.renderWedge(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius1, theta3, theta12, color2, 1, anticlockwise1, conditionallyDrawn1);
						}
					}
					break;
				}
				case 'highlightedUnder': {
					var radius2 = paneDrawInfo.c.get('size').gv(markIndex) / 2;
					{
						var theta4 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta13 = paneDrawInfo.c.get('theta1').gv(markIndex);
						var anticlockwise2 = theta4 > theta13;
						var color3 = paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
						var conditionallyDrawn2 = false;
						if (Math.abs(theta4 - theta13) >= 1) {
							tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius2 * 2, color3, 4);
						}
						else {
							tab.CanvasRenderer.renderWedge(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius2, theta4, theta13, color3, 4, anticlockwise2, conditionallyDrawn2);
						}
					}
					break;
				}
				case 'highlightedOn': {
					var radius3 = paneDrawInfo.c.get('size').gv(markIndex) / 2;
					{
						var theta5 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta14 = paneDrawInfo.c.get('theta1').gv(markIndex);
						if (theta5 > theta14) {
							var temp1 = theta5;
							theta5 = theta14;
							theta14 = temp1;
						}
						var xPos1 = paneDrawInfo.c.get('x').gv(markIndex);
						var yPos1 = paneDrawInfo.c.get('y').gv(markIndex);
						var color4 = paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode];
						if (paneDrawInfo.c.get('alpha').gv(markIndex) >= 1) {
							var canvasAngle1 = tab.CanvasRenderer.toCanvasAngle(theta5);
							var canvasAngle21 = tab.CanvasRenderer.toCanvasAngle(theta14);
							if (Math.abs(canvasAngle21 - canvasAngle1) >= tab.CanvasRenderer.angleEpsilon) {
								this.get_currentContext().beginPath();
								this.get_currentContext().set_lineCap('butt');
								this.get_currentContext().set_lineWidth(1.5);
								this.get_currentContext().set_strokeStyle(color4);
								this.get_currentContext().moveTo(xPos1, yPos1);
								this.get_currentContext().lineTo(xPos1 + Math.cos(canvasAngle1) * radius3, yPos1 + Math.sin(canvasAngle1) * radius3);
								this.get_currentContext().stroke();
							}
						}
						if (Math.abs(theta5 - theta14) >= 1) {
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), xPos1, yPos1, radius3 * 2, color4);
						}
						else {
							this.renderFilledWedge(xPos1, yPos1, radius3, theta5, theta14, color4);
						}
					}
					if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
						var theta6 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta15 = paneDrawInfo.c.get('theta1').gv(markIndex);
						var anticlockwise3 = theta6 > theta15;
						var color5 = paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode];
						var conditionallyDrawn3 = true;
						if (Math.abs(theta6 - theta15) >= 1) {
							tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius3 * 2, color5, 1);
						}
						else {
							tab.CanvasRenderer.renderWedge(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius3, theta6, theta15, color5, 1, anticlockwise3, conditionallyDrawn3);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var radius4 = paneDrawInfo.c.get('size').gv(markIndex) / 2;
					{
						var theta7 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta16 = paneDrawInfo.c.get('theta1').gv(markIndex);
						var anticlockwise4 = theta7 > theta16;
						var color6 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode];
						var conditionallyDrawn4 = false;
						if (Math.abs(theta7 - theta16) >= 1) {
							tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius4 * 2, color6, 4);
						}
						else {
							tab.CanvasRenderer.renderWedge(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius4, theta7, theta16, color6, 4, anticlockwise4, conditionallyDrawn4);
						}
					}
					break;
				}
				case 'selectedOn': {
					var radius5 = paneDrawInfo.c.get('size').gv(markIndex) / 2;
					{
						var theta8 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta17 = paneDrawInfo.c.get('theta1').gv(markIndex);
						if (theta8 > theta17) {
							var temp2 = theta8;
							theta8 = theta17;
							theta17 = temp2;
						}
						var xPos2 = paneDrawInfo.c.get('x').gv(markIndex);
						var yPos2 = paneDrawInfo.c.get('y').gv(markIndex);
						var color7 = paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode];
						if (paneDrawInfo.c.get('alpha').gv(markIndex) >= 1) {
							var canvasAngle3 = tab.CanvasRenderer.toCanvasAngle(theta8);
							var canvasAngle22 = tab.CanvasRenderer.toCanvasAngle(theta17);
							if (Math.abs(canvasAngle22 - canvasAngle3) >= tab.CanvasRenderer.angleEpsilon) {
								this.get_currentContext().beginPath();
								this.get_currentContext().set_lineCap('butt');
								this.get_currentContext().set_lineWidth(1.5);
								this.get_currentContext().set_strokeStyle(color7);
								this.get_currentContext().moveTo(xPos2, yPos2);
								this.get_currentContext().lineTo(xPos2 + Math.cos(canvasAngle3) * radius5, yPos2 + Math.sin(canvasAngle3) * radius5);
								this.get_currentContext().stroke();
							}
						}
						if (Math.abs(theta8 - theta17) >= 1) {
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), xPos2, yPos2, radius5 * 2, color7);
						}
						else {
							this.renderFilledWedge(xPos2, yPos2, radius5, theta8, theta17, color7);
						}
					}
					if (paneDrawInfo.c.get('draw_border').gv(markIndex)) {
						var theta9 = paneDrawInfo.c.get('theta').gv(markIndex);
						var theta18 = paneDrawInfo.c.get('theta1').gv(markIndex);
						var anticlockwise5 = theta9 > theta18;
						var color8 = paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode];
						var conditionallyDrawn5 = true;
						if (Math.abs(theta9 - theta18) >= 1) {
							tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius5 * 2, color8, 1);
						}
						else {
							tab.CanvasRenderer.renderWedge(this.get_currentContext(), paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), radius5, theta9, theta18, color8, 1, anticlockwise5, conditionallyDrawn5);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderTextMarks: function MarksRenderer$RenderTextMarks(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			this.get_currentContext().save();
			var styleSetter = this.$setupContextForTextRendering(paneDrawInfo);
			switch (renderPass) {
				case 'normalUnderPass': {
					if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender, offset) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
								for (var markIndex = firstMark; markIndex <= lastMark; markIndex++) {
									if (marksNotToRender.has(markIndex)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex) !== 'markStateNormal') {
										continue;
									}
									this.drawTextMarkLayer(paneDrawInfo, markIndex, 'normalUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender1, offset1) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
								for (var markIndex1 = firstMark; markIndex1 <= lastMark; markIndex1++) {
									if (marksNotToRender1.has(markIndex1)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex1)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex1) !== 'markStateHighlighted') {
										continue;
									}
									this.drawTextMarkLayer(paneDrawInfo, markIndex1, 'normalUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset1, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					{
						paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender2, offset2) {
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
							for (var markIndex2 = firstMark; markIndex2 <= lastMark; markIndex2++) {
								if (marksNotToRender2.has(markIndex2)) {
									continue;
								}
								if (!paneDrawInfo.markNeedsDraw(markIndex2)) {
									continue;
								}
								if (paneDrawInfo.getMarkState(markIndex2) !== 'markStateNormal') {
									continue;
								}
								var drawRunsInReverse = false;
								var textRunOffset = paneDrawInfo.c.get('text_run_offset').gv(markIndex2);
								var numRuns = paneDrawInfo.c.get('text_run_count').gv(markIndex2);
								var multipleRuns = numRuns > 1;
								for (var runNum = 0; runNum < numRuns; runNum++) {
									var runId = runNum + textRunOffset;
									if (runNum === 0) {
										var styleId = paneDrawInfo.getTextRunProperty('text_style_id', runId);
										styleSetter(styleId);
										drawRunsInReverse = this.get_currentContext().get_textAlign() === 'end';
									}
									if (drawRunsInReverse) {
										runId = textRunOffset + numRuns - runNum - 1;
									}
									this.drawTextRunLayer(paneDrawInfo, markIndex2, 'normalOn', colorOverrideMode, runId, multipleRuns, styleSetter);
								}
								this.clearPrevTextRunInfo();
							}
							if (!tab.DoubleUtil.isApproximatelyEqual(offset2, 0)) {
								this.get_currentContext().restore();
							}
						}));
					}
					break;
				}
				case 'highlightedUnderPass': {
					if (hasSelection || hasBrushing) {
						if (!(paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos())) {
							colorOverrideMode = 'colorOverrideNone';
							{
								paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender3, offset3) {
									$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
									for (var markIndex3 = firstMark; markIndex3 <= lastMark; markIndex3++) {
										if (marksNotToRender3.has(markIndex3)) {
											continue;
										}
										if (!paneDrawInfo.markNeedsDraw(markIndex3)) {
											continue;
										}
										if (paneDrawInfo.getMarkState(markIndex3) !== 'markStateHighlighted') {
											continue;
										}
										this.drawTextMarkLayer(paneDrawInfo, markIndex3, 'highlightedUnder', colorOverrideMode);
									}
									if (!tab.DoubleUtil.isApproximatelyEqual(offset3, 0)) {
										this.get_currentContext().restore();
									}
								}));
							}
						}
					}
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender4, offset4) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset4);
								for (var markIndex4 = firstMark; markIndex4 <= lastMark; markIndex4++) {
									if (marksNotToRender4.has(markIndex4)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex4)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex4) !== 'markStateHighlighted') {
										continue;
									}
									var drawRunsInReverse1 = false;
									var textRunOffset1 = paneDrawInfo.c.get('text_run_offset').gv(markIndex4);
									var numRuns1 = paneDrawInfo.c.get('text_run_count').gv(markIndex4);
									var multipleRuns1 = numRuns1 > 1;
									for (var runNum1 = 0; runNum1 < numRuns1; runNum1++) {
										var runId1 = runNum1 + textRunOffset1;
										if (runNum1 === 0) {
											var styleId1 = paneDrawInfo.getTextRunProperty('text_style_id', runId1);
											styleSetter(styleId1);
											drawRunsInReverse1 = this.get_currentContext().get_textAlign() === 'end';
										}
										if (drawRunsInReverse1) {
											runId1 = textRunOffset1 + numRuns1 - runNum1 - 1;
										}
										this.drawTextRunLayer(paneDrawInfo, markIndex4, 'normalOn', colorOverrideMode, runId1, multipleRuns1, styleSetter);
									}
									this.clearPrevTextRunInfo();
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset4, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender5, offset5) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset5);
								for (var markIndex5 = firstMark; markIndex5 <= lastMark; markIndex5++) {
									if (marksNotToRender5.has(markIndex5)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex5)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex5) !== 'markStateSelected') {
										continue;
									}
									this.drawTextMarkLayer(paneDrawInfo, markIndex5, 'selectedUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset5, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender6, offset6) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset6);
								for (var markIndex6 = firstMark; markIndex6 <= lastMark; markIndex6++) {
									if (marksNotToRender6.has(markIndex6)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex6)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex6) !== 'markStateSelected') {
										continue;
									}
									var drawRunsInReverse2 = false;
									var textRunOffset2 = paneDrawInfo.c.get('text_run_offset').gv(markIndex6);
									var numRuns2 = paneDrawInfo.c.get('text_run_count').gv(markIndex6);
									var multipleRuns2 = numRuns2 > 1;
									for (var runNum2 = 0; runNum2 < numRuns2; runNum2++) {
										var runId2 = runNum2 + textRunOffset2;
										if (runNum2 === 0) {
											var styleId2 = paneDrawInfo.getTextRunProperty('text_style_id', runId2);
											styleSetter(styleId2);
											drawRunsInReverse2 = this.get_currentContext().get_textAlign() === 'end';
										}
										if (drawRunsInReverse2) {
											runId2 = textRunOffset2 + numRuns2 - runNum2 - 1;
										}
										this.drawTextRunLayer(paneDrawInfo, markIndex6, 'normalOn', colorOverrideMode, runId2, multipleRuns2, styleSetter);
									}
									this.clearPrevTextRunInfo();
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset6, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawTextMarkLayer: function MarksRenderer$DrawTextMarkLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			switch (layer) {
				case 'normalUnder': {
					{
						if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
							var markX = paneDrawInfo.c.get('x').gv(markIndex);
							var markY = paneDrawInfo.c.get('y').gv(markIndex);
							var width = paneDrawInfo.c.get('width').gv(markIndex);
							var height = -paneDrawInfo.c.get('height').gv(markIndex);
							if (height < 0) {
								markY += height;
								height = Math.abs(height);
							}
							var leftOffset = -paneDrawInfo.c.get('width').gv(markIndex) / 2;
							var bottomOffset = paneDrawInfo.c.get('height').gv(markIndex) / 2;
							var color;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color = paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX + leftOffset, markY + bottomOffset, width, height, color, 0, 0, false);
						}
					}
					{
						if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
							var markX1 = paneDrawInfo.c.get('x').gv(markIndex);
							var markY1 = paneDrawInfo.c.get('y').gv(markIndex);
							var width1 = paneDrawInfo.c.get('clip_width').gv(markIndex);
							var height1 = -paneDrawInfo.c.get('clip_height').gv(markIndex);
							if (height1 < 0) {
								markY1 += height1;
								height1 = Math.abs(height1);
							}
							var leftOffset1 = -paneDrawInfo.c.get('clip_width').gv(markIndex) / 2;
							var bottomOffset1 = paneDrawInfo.c.get('clip_height').gv(markIndex) / 2;
							var color1;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color1 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color1 = paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX1 + leftOffset1, markY1 + bottomOffset1, width1, height1, color1, 0, 0, false);
						}
					}
					break;
				}
				case 'normalOn': {
					break;
				}
				case 'highlightedUnder': {
					{
						if (paneDrawInfo.get_hasHaloHighlightColor() && !(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
							var markX2 = paneDrawInfo.c.get('x').gv(markIndex);
							var markY2 = paneDrawInfo.c.get('y').gv(markIndex);
							var width2 = paneDrawInfo.c.get('width').gv(markIndex);
							var height2 = -paneDrawInfo.c.get('height').gv(markIndex);
							if (height2 < 0) {
								markY2 += height2;
								height2 = Math.abs(height2);
							}
							var leftOffset2 = -paneDrawInfo.c.get('width').gv(markIndex) / 2;
							var bottomOffset2 = paneDrawInfo.c.get('height').gv(markIndex) / 2;
							var color2;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color2 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color2 = paneDrawInfo.c.get('highlighted_halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX2 + leftOffset2, markY2 + bottomOffset2, width2, height2, color2, 0, 0, false);
						}
					}
					{
						if (paneDrawInfo.get_hasHaloHighlightColor() && (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
							var markX3 = paneDrawInfo.c.get('x').gv(markIndex);
							var markY3 = paneDrawInfo.c.get('y').gv(markIndex);
							var width3 = paneDrawInfo.c.get('clip_width').gv(markIndex);
							var height3 = -paneDrawInfo.c.get('clip_height').gv(markIndex);
							if (height3 < 0) {
								markY3 += height3;
								height3 = Math.abs(height3);
							}
							var leftOffset3 = -paneDrawInfo.c.get('clip_width').gv(markIndex) / 2;
							var bottomOffset3 = paneDrawInfo.c.get('clip_height').gv(markIndex) / 2;
							var color3;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color3 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color3 = paneDrawInfo.c.get('highlighted_halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX3 + leftOffset3, markY3 + bottomOffset3, width3, height3, color3, 0, 0, false);
						}
					}
					break;
				}
				case 'selectedUnder': {
					{
						if (!(paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection)) {
							var markX4 = paneDrawInfo.c.get('x').gv(markIndex);
							var markY4 = paneDrawInfo.c.get('y').gv(markIndex);
							var width4 = paneDrawInfo.c.get('width').gv(markIndex);
							var height4 = -paneDrawInfo.c.get('height').gv(markIndex);
							if (height4 < 0) {
								markY4 += height4;
								height4 = Math.abs(height4);
							}
							var leftOffset4 = -paneDrawInfo.c.get('width').gv(markIndex) / 2;
							var bottomOffset4 = paneDrawInfo.c.get('height').gv(markIndex) / 2;
							var color4;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color4 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color4 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX4 + leftOffset4, markY4 + bottomOffset4, width4, height4, color4, 0, 0, false);
						}
					}
					{
						if (paneDrawInfo.clipCase !== 0 && paneDrawInfo.useCellClipForSelection) {
							var markX5 = paneDrawInfo.c.get('x').gv(markIndex);
							var markY5 = paneDrawInfo.c.get('y').gv(markIndex);
							var width5 = paneDrawInfo.c.get('clip_width').gv(markIndex);
							var height5 = -paneDrawInfo.c.get('clip_height').gv(markIndex);
							if (height5 < 0) {
								markY5 += height5;
								height5 = Math.abs(height5);
							}
							var leftOffset5 = -paneDrawInfo.c.get('clip_width').gv(markIndex) / 2;
							var bottomOffset5 = paneDrawInfo.c.get('clip_height').gv(markIndex) / 2;
							var color5;
							if (paneDrawInfo.isMarkImpliedSelected(markIndex)) {
								color5 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)['colorOverrideOpaque'];
							}
							else {
								color5 = paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode];
							}
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), markX5 + leftOffset5, markY5 + bottomOffset5, width5, height5, color5, 0, 0, false);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderBarMark: function MarksRenderer$RenderBarMark(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			this.get_currentContext().save();
			this.get_currentContext().set_lineJoin('miter');
			switch (renderPass) {
				case 'normalUnderPass': {
					if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender, offset) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
								for (var markIndex = firstMark; markIndex <= lastMark; markIndex++) {
									if (marksNotToRender.has(markIndex)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex) !== 'markStateNormal') {
										continue;
									}
									this.drawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex, 'normalUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
						colorOverrideMode = 'colorOverrideNone';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender1, offset1) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
								for (var markIndex1 = firstMark; markIndex1 <= lastMark; markIndex1++) {
									if (marksNotToRender1.has(markIndex1)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex1)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex1) !== 'markStateHighlighted') {
										continue;
									}
									this.drawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex1, 'normalUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset1, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					{
						paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender2, offset2) {
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
							for (var markIndex2 = firstMark; markIndex2 <= lastMark; markIndex2++) {
								if (marksNotToRender2.has(markIndex2)) {
									continue;
								}
								if (!paneDrawInfo.markNeedsDraw(markIndex2)) {
									continue;
								}
								if (paneDrawInfo.getMarkState(markIndex2) !== 'markStateNormal') {
									continue;
								}
								this.drawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex2, 'normalOn', colorOverrideMode);
							}
							if (!tab.DoubleUtil.isApproximatelyEqual(offset2, 0)) {
								this.get_currentContext().restore();
							}
						}));
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender3, offset3) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
								for (var markIndex3 = firstMark; markIndex3 <= lastMark; markIndex3++) {
									if (marksNotToRender3.has(markIndex3)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex3)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex3) !== 'markStateHighlighted') {
										continue;
									}
									this.drawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex3, 'highlightedOn', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset3, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender4, offset4) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset4);
								for (var markIndex4 = firstMark; markIndex4 <= lastMark; markIndex4++) {
									if (marksNotToRender4.has(markIndex4)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex4)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex4) !== 'markStateSelected') {
										continue;
									}
									this.drawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex4, 'selectedUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset4, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						if (paneDrawInfo.clipCase !== 3) {
							this.get_currentContext().save();
							this.get_currentContext().setClip(paneDrawInfo.getInsetPaneClipRect(userPaneIndex, 2));
						}
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender5, offset5) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset5);
								for (var markIndex5 = firstMark; markIndex5 <= lastMark; markIndex5++) {
									if (marksNotToRender5.has(markIndex5)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex5)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex5) !== 'markStateSelected') {
										continue;
									}
									this.drawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex5, 'selectedOn', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset5, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
						if (paneDrawInfo.clipCase !== 3) {
							this.get_currentContext().restore();
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawBarMarkLayer: function MarksRenderer$DrawBarMarkLayer(paneDrawInfo, userPaneRect, markIndex, layer, colorOverrideMode) {
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			switch (layer) {
				case 'normalUnder': {
					var halfSize = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left = paneDrawInfo.c.get('x').gv(markIndex);
							var right = paneDrawInfo.c.get('x1').gv(markIndex);
							var top = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom = paneDrawInfo.c.get('y1').gv(markIndex);
							var x = Math.min(left, right);
							var y = Math.min(top, bottom);
							var width = Math.abs(right - left) + 0;
							var height = Math.abs(bottom - top) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x, y, width, height, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left1 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize;
							var right1 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize;
							var top1 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom1 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x1 = Math.min(left1, right1);
							var y1 = Math.min(top1, bottom1);
							var width1 = Math.abs(right1 - left1) + 0;
							var height1 = Math.abs(bottom1 - top1) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x1, y1, width1, height1, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left2 = paneDrawInfo.c.get('x').gv(markIndex);
							var right2 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top2 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize;
							var bottom2 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize;
							var x2 = Math.min(left2, right2);
							var y2 = Math.min(top2, bottom2);
							var width2 = Math.abs(right2 - left2) + 0;
							var height2 = Math.abs(bottom2 - top2) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x2, y2, width2, height2, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left3 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize;
							var right3 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize;
							var top3 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize;
							var bottom3 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize;
							var x3 = Math.min(left3, right3);
							var y3 = Math.min(top3, bottom3);
							var width3 = Math.abs(right3 - left3) + 0;
							var height3 = Math.abs(bottom3 - top3) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x3, y3, width3, height3, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left4 = paneDrawInfo.c.get('x').gv(markIndex);
							var right4 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top4 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom4 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x4 = Math.min(left4, right4);
							var y4 = Math.min(top4, bottom4);
							var width4 = Math.abs(right4 - left4) + 0;
							var height4 = Math.abs(bottom4 - top4) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x4 - 0, y4 - 0, width4 + 0, height4 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left5 = paneDrawInfo.c.get('x').gv(markIndex);
							var right5 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top5 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom5 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x5 = Math.min(left5, right5);
							var y5 = Math.min(top5, bottom5);
							var width5 = Math.abs(right5 - left5) + 0;
							var height5 = Math.abs(bottom5 - top5) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x5, y5, width5, height5, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left6 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize1;
							var right6 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize1;
							var top6 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom6 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x6 = Math.min(left6, right6);
							var y6 = Math.min(top6, bottom6);
							var width6 = Math.abs(right6 - left6) + 0;
							var height6 = Math.abs(bottom6 - top6) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x6 - 0, y6 - 0, width6 + 0, height6 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left7 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize1;
							var right7 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize1;
							var top7 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom7 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x7 = Math.min(left7, right7);
							var y7 = Math.min(top7, bottom7);
							var width7 = Math.abs(right7 - left7) + 0;
							var height7 = Math.abs(bottom7 - top7) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x7, y7, width7, height7, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left8 = paneDrawInfo.c.get('x').gv(markIndex);
							var right8 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top8 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize1;
							var bottom8 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize1;
							var x8 = Math.min(left8, right8);
							var y8 = Math.min(top8, bottom8);
							var width8 = Math.abs(right8 - left8) + 0;
							var height8 = Math.abs(bottom8 - top8) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x8 - 0, y8 - 0, width8 + 0, height8 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left9 = paneDrawInfo.c.get('x').gv(markIndex);
							var right9 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top9 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize1;
							var bottom9 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize1;
							var x9 = Math.min(left9, right9);
							var y9 = Math.min(top9, bottom9);
							var width9 = Math.abs(right9 - left9) + 0;
							var height9 = Math.abs(bottom9 - top9) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x9, y9, width9, height9, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left10 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize1;
							var right10 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize1;
							var top10 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize1;
							var bottom10 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize1;
							var x10 = Math.min(left10, right10);
							var y10 = Math.min(top10, bottom10);
							var width10 = Math.abs(right10 - left10) + 0;
							var height10 = Math.abs(bottom10 - top10) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x10 - 0, y10 - 0, width10 + 0, height10 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left11 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize1;
							var right11 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize1;
							var top11 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize1;
							var bottom11 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize1;
							var x11 = Math.min(left11, right11);
							var y11 = Math.min(top11, bottom11);
							var width11 = Math.abs(right11 - left11) + 0;
							var height11 = Math.abs(bottom11 - top11) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x11, y11, width11, height11, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					break;
				}
				case 'highlightedUnder': {
					var halfSize2 = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left12 = paneDrawInfo.c.get('x').gv(markIndex);
							var right12 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top12 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom12 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x12 = Math.min(left12, right12);
							var y12 = Math.min(top12, bottom12);
							var width12 = Math.abs(right12 - left12) + 0;
							var height12 = Math.abs(bottom12 - top12) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x12, y12, width12, height12, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left13 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize2;
							var right13 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize2;
							var top13 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom13 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x13 = Math.min(left13, right13);
							var y13 = Math.min(top13, bottom13);
							var width13 = Math.abs(right13 - left13) + 0;
							var height13 = Math.abs(bottom13 - top13) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x13, y13, width13, height13, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left14 = paneDrawInfo.c.get('x').gv(markIndex);
							var right14 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top14 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize2;
							var bottom14 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize2;
							var x14 = Math.min(left14, right14);
							var y14 = Math.min(top14, bottom14);
							var width14 = Math.abs(right14 - left14) + 0;
							var height14 = Math.abs(bottom14 - top14) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x14, y14, width14, height14, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left15 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize2;
							var right15 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize2;
							var top15 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize2;
							var bottom15 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize2;
							var x15 = Math.min(left15, right15);
							var y15 = Math.min(top15, bottom15);
							var width15 = Math.abs(right15 - left15) + 0;
							var height15 = Math.abs(bottom15 - top15) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x15, y15, width15, height15, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					break;
				}
				case 'highlightedOn': {
					var halfSize3 = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left16 = paneDrawInfo.c.get('x').gv(markIndex);
							var right16 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top16 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom16 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x16 = Math.min(left16, right16);
							var y16 = Math.min(top16, bottom16);
							var width16 = Math.abs(right16 - left16) + 0;
							var height16 = Math.abs(bottom16 - top16) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x16 - 0, y16 - 0, width16 + 0, height16 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left17 = paneDrawInfo.c.get('x').gv(markIndex);
							var right17 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top17 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom17 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x17 = Math.min(left17, right17);
							var y17 = Math.min(top17, bottom17);
							var width17 = Math.abs(right17 - left17) + 0;
							var height17 = Math.abs(bottom17 - top17) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x17, y17, width17, height17, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left18 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize3;
							var right18 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize3;
							var top18 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom18 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x18 = Math.min(left18, right18);
							var y18 = Math.min(top18, bottom18);
							var width18 = Math.abs(right18 - left18) + 0;
							var height18 = Math.abs(bottom18 - top18) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x18 - 0, y18 - 0, width18 + 0, height18 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left19 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize3;
							var right19 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize3;
							var top19 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom19 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x19 = Math.min(left19, right19);
							var y19 = Math.min(top19, bottom19);
							var width19 = Math.abs(right19 - left19) + 0;
							var height19 = Math.abs(bottom19 - top19) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x19, y19, width19, height19, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left20 = paneDrawInfo.c.get('x').gv(markIndex);
							var right20 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top20 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize3;
							var bottom20 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize3;
							var x20 = Math.min(left20, right20);
							var y20 = Math.min(top20, bottom20);
							var width20 = Math.abs(right20 - left20) + 0;
							var height20 = Math.abs(bottom20 - top20) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x20 - 0, y20 - 0, width20 + 0, height20 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left21 = paneDrawInfo.c.get('x').gv(markIndex);
							var right21 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top21 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize3;
							var bottom21 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize3;
							var x21 = Math.min(left21, right21);
							var y21 = Math.min(top21, bottom21);
							var width21 = Math.abs(right21 - left21) + 0;
							var height21 = Math.abs(bottom21 - top21) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x21, y21, width21, height21, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left22 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize3;
							var right22 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize3;
							var top22 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize3;
							var bottom22 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize3;
							var x22 = Math.min(left22, right22);
							var y22 = Math.min(top22, bottom22);
							var width22 = Math.abs(right22 - left22) + 0;
							var height22 = Math.abs(bottom22 - top22) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x22 - 0, y22 - 0, width22 + 0, height22 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left23 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize3;
							var right23 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize3;
							var top23 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize3;
							var bottom23 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize3;
							var x23 = Math.min(left23, right23);
							var y23 = Math.min(top23, bottom23);
							var width23 = Math.abs(right23 - left23) + 0;
							var height23 = Math.abs(bottom23 - top23) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x23, y23, width23, height23, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize4 = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
					var borderWidth = 1;
					{
						var left24 = paneDrawInfo.c.get('x').gv(markIndex);
						var right24 = paneDrawInfo.c.get('x1').gv(markIndex);
						var top24 = paneDrawInfo.c.get('y').gv(markIndex);
						var bottom24 = paneDrawInfo.c.get('y1').gv(markIndex);
						var x24 = Math.min(left24, right24);
						var y24 = Math.min(top24, bottom24);
						var width24 = Math.abs(right24 - left24) + 0;
						var height24 = Math.abs(bottom24 - top24) + 0;
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && !this.$clippedByUserPane(userPaneRect, x24, y24, width24, height24)) {
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x24, y24, width24, height24, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						var left25 = paneDrawInfo.c.get('x').gv(markIndex);
						var right25 = paneDrawInfo.c.get('x1').gv(markIndex);
						var top25 = paneDrawInfo.c.get('y').gv(markIndex);
						var bottom25 = paneDrawInfo.c.get('y1').gv(markIndex);
						var x25 = Math.min(left25, right25);
						var y25 = Math.min(top25, bottom25);
						var width25 = Math.abs(right25 - left25) + 0;
						var height25 = Math.abs(bottom25 - top25) + 0;
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && this.$clippedByUserPane(userPaneRect, x25, y25, width25, height25)) {
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x25 - 2, y25 - 2, width25 + 4, height25 + 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left26 = paneDrawInfo.c.get('x').gv(markIndex);
							var right26 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top26 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom26 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x26 = Math.min(left26, right26);
							var y26 = Math.min(top26, bottom26);
							var width26 = Math.abs(right26 - left26) + borderWidth;
							var height26 = Math.abs(bottom26 - top26) + borderWidth;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x26, y26, width26, height26, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						var left27 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize4;
						var right27 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize4;
						var top27 = paneDrawInfo.c.get('y').gv(markIndex);
						var bottom27 = paneDrawInfo.c.get('y1').gv(markIndex);
						var x27 = Math.min(left27, right27);
						var y27 = Math.min(top27, bottom27);
						var width27 = Math.abs(right27 - left27) + 0;
						var height27 = Math.abs(bottom27 - top27) + 0;
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && !this.$clippedByUserPane(userPaneRect, x27, y27, width27, height27)) {
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x27, y27, width27, height27, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						var left28 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize4;
						var right28 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize4;
						var top28 = paneDrawInfo.c.get('y').gv(markIndex);
						var bottom28 = paneDrawInfo.c.get('y1').gv(markIndex);
						var x28 = Math.min(left28, right28);
						var y28 = Math.min(top28, bottom28);
						var width28 = Math.abs(right28 - left28) + 0;
						var height28 = Math.abs(bottom28 - top28) + 0;
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && this.$clippedByUserPane(userPaneRect, x28, y28, width28, height28)) {
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x28 - 2, y28 - 2, width28 + 4, height28 + 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left29 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize4;
							var right29 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize4;
							var top29 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom29 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x29 = Math.min(left29, right29);
							var y29 = Math.min(top29, bottom29);
							var width29 = Math.abs(right29 - left29) + borderWidth;
							var height29 = Math.abs(bottom29 - top29) + borderWidth;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x29, y29, width29, height29, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						var left30 = paneDrawInfo.c.get('x').gv(markIndex);
						var right30 = paneDrawInfo.c.get('x1').gv(markIndex);
						var top30 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize4;
						var bottom30 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize4;
						var x30 = Math.min(left30, right30);
						var y30 = Math.min(top30, bottom30);
						var width30 = Math.abs(right30 - left30) + 0;
						var height30 = Math.abs(bottom30 - top30) + 0;
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !this.$clippedByUserPane(userPaneRect, x30, y30, width30, height30)) {
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x30, y30, width30, height30, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						var left31 = paneDrawInfo.c.get('x').gv(markIndex);
						var right31 = paneDrawInfo.c.get('x1').gv(markIndex);
						var top31 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize4;
						var bottom31 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize4;
						var x31 = Math.min(left31, right31);
						var y31 = Math.min(top31, bottom31);
						var width31 = Math.abs(right31 - left31) + 0;
						var height31 = Math.abs(bottom31 - top31) + 0;
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && this.$clippedByUserPane(userPaneRect, x31, y31, width31, height31)) {
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x31 - 2, y31 - 2, width31 + 4, height31 + 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left32 = paneDrawInfo.c.get('x').gv(markIndex);
							var right32 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top32 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize4;
							var bottom32 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize4;
							var x32 = Math.min(left32, right32);
							var y32 = Math.min(top32, bottom32);
							var width32 = Math.abs(right32 - left32) + borderWidth;
							var height32 = Math.abs(bottom32 - top32) + borderWidth;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x32, y32, width32, height32, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						var left33 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize4;
						var right33 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize4;
						var top33 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize4;
						var bottom33 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize4;
						var x33 = Math.min(left33, right33);
						var y33 = Math.min(top33, bottom33);
						var width33 = Math.abs(right33 - left33) + 0;
						var height33 = Math.abs(bottom33 - top33) + 0;
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && !this.$clippedByUserPane(userPaneRect, x33, y33, width33, height33)) {
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x33, y33, width33, height33, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					{
						var left34 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize4;
						var right34 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize4;
						var top34 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize4;
						var bottom34 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize4;
						var x34 = Math.min(left34, right34);
						var y34 = Math.min(top34, bottom34);
						var width34 = Math.abs(right34 - left34) + 0;
						var height34 = Math.abs(bottom34 - top34) + 0;
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && this.$clippedByUserPane(userPaneRect, x34, y34, width34, height34)) {
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x34 - 2, y34 - 2, width34 + 4, height34 + 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left35 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize4;
							var right35 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize4;
							var top35 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize4;
							var bottom35 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize4;
							var x35 = Math.min(left35, right35);
							var y35 = Math.min(top35, bottom35);
							var width35 = Math.abs(right35 - left35) + borderWidth;
							var height35 = Math.abs(bottom35 - top35) + borderWidth;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x35, y35, width35, height35, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 4, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					break;
				}
				case 'selectedOn': {
					var halfSize5 = ss.Int32.trunc(paneDrawInfo.c.get('size').gv(markIndex) + 0.5) / 2;
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left36 = paneDrawInfo.c.get('x').gv(markIndex);
							var right36 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top36 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom36 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x36 = Math.min(left36, right36);
							var y36 = Math.min(top36, bottom36);
							var width36 = Math.abs(right36 - left36) + 0;
							var height36 = Math.abs(bottom36 - top36) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x36 - 0, y36 - 0, width36 + 0, height36 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left37 = paneDrawInfo.c.get('x').gv(markIndex);
							var right37 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top37 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom37 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x37 = Math.min(left37, right37);
							var y37 = Math.min(top37, bottom37);
							var width37 = Math.abs(right37 - left37) + 0;
							var height37 = Math.abs(bottom37 - top37) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x37, y37, width37, height37, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY) {
							var left38 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize5;
							var right38 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize5;
							var top38 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom38 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x38 = Math.min(left38, right38);
							var y38 = Math.min(top38, bottom38);
							var width38 = Math.abs(right38 - left38) + 0;
							var height38 = Math.abs(bottom38 - top38) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x38 - 0, y38 - 0, width38 + 0, height38 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left39 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize5;
							var right39 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize5;
							var top39 = paneDrawInfo.c.get('y').gv(markIndex);
							var bottom39 = paneDrawInfo.c.get('y1').gv(markIndex);
							var x39 = Math.min(left39, right39);
							var y39 = Math.min(top39, bottom39);
							var width39 = Math.abs(right39 - left39) + 0;
							var height39 = Math.abs(bottom39 - top39) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x39, y39, width39, height39, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left40 = paneDrawInfo.c.get('x').gv(markIndex);
							var right40 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top40 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize5;
							var bottom40 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize5;
							var x40 = Math.min(left40, right40);
							var y40 = Math.min(top40, bottom40);
							var width40 = Math.abs(right40 - left40) + 0;
							var height40 = Math.abs(bottom40 - top40) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x40 - 0, y40 - 0, width40 + 0, height40 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left41 = paneDrawInfo.c.get('x').gv(markIndex);
							var right41 = paneDrawInfo.c.get('x1').gv(markIndex);
							var top41 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize5;
							var bottom41 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize5;
							var x41 = Math.min(left41, right41);
							var y41 = Math.min(top41, bottom41);
							var width41 = Math.abs(right41 - left41) + 0;
							var height41 = Math.abs(bottom41 - top41) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x41, y41, width41, height41, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, false);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY) {
							var left42 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize5;
							var right42 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize5;
							var top42 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize5;
							var bottom42 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize5;
							var x42 = Math.min(left42, right42);
							var y42 = Math.min(top42, bottom42);
							var width42 = Math.abs(right42 - left42) + 0;
							var height42 = Math.abs(bottom42 - top42) + 0;
							$tab_MarksRenderer.$renderFilledBar(this.get_currentContext(), x42 - 0, y42 - 0, width42 + 0, height42 + 0, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					{
						if (!paneDrawInfo.scaleMarksInX && !paneDrawInfo.scaleMarksInY && paneDrawInfo.drawBorder) {
							var left43 = paneDrawInfo.c.get('x').gv(markIndex) - halfSize5;
							var right43 = paneDrawInfo.c.get('x').gv(markIndex) + halfSize5;
							var top43 = paneDrawInfo.c.get('y').gv(markIndex) - halfSize5;
							var bottom43 = paneDrawInfo.c.get('y').gv(markIndex) + halfSize5;
							var x43 = Math.min(left43, right43);
							var y43 = Math.min(top43, bottom43);
							var width43 = Math.abs(right43 - left43) + 0;
							var height43 = Math.abs(bottom43 - top43) + 0;
							$tab_MarksRenderer.$renderBarOutline(this.get_currentContext(), x43, y43, width43, height43, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1, paneDrawInfo.minBarWidth, paneDrawInfo.minBarHeight, true);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderLineMark: function MarksRenderer$RenderLineMark(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			var lineDrawState = paneDrawInfo.get_lineDrawState();
			this.get_currentContext().save();
			switch (renderPass) {
				case 'normalUnderPass': {
					if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						var $t1 = lineDrawState.get_lineAttributes();
						for (var $t2 = 0; $t2 < $t1.length; $t2++) {
							var currentLine = $t1[$t2];
							if (currentLine.get_lineState() !== 'lineStateNormal') {
								continue;
							}
							var offsets = currentLine.worldOffsets;
							var offsetCount = offsets.length;
							for (var index = 0; index < offsetCount; index++) {
								var offset = offsets[index];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
								{
									for (var $t3 = 0; $t3 < currentLine.marksNeedingDraw.length; $t3++) {
										var markIndex = currentLine.marksNeedingDraw[$t3];
										if (paneDrawInfo.c.get('l_neighbor').gv(markIndex) !== -1 || paneDrawInfo.c.get('r_neighbor').gv(markIndex) !== -1) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex, 'normalUnder', colorOverrideMode);
										}
									}
								}
								{
									for (var $t4 = 0; $t4 < currentLine.marksNeedingDraw.length; $t4++) {
										var markIndex1 = currentLine.marksNeedingDraw[$t4];
										this.drawLineMarkLayer(paneDrawInfo, markIndex1, 'edgeUnder', colorOverrideMode);
										if (paneDrawInfo.c.get('l_neighbor').gv(markIndex1) === -1 && paneDrawInfo.c.get('r_neighbor').gv(markIndex1) === -1 || paneDrawInfo.shouldShowMarker(markIndex1)) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex1, 'blobUnder', colorOverrideMode);
										}
									}
								}
								if (offset !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
						var $t5 = lineDrawState.get_lineAttributes();
						for (var $t6 = 0; $t6 < $t5.length; $t6++) {
							var currentLine1 = $t5[$t6];
							if (currentLine1.get_lineState() !== 'lineStateHighlighted') {
								continue;
							}
							var offsets1 = currentLine1.worldOffsets;
							var offsetCount1 = offsets1.length;
							for (var index1 = 0; index1 < offsetCount1; index1++) {
								var offset1 = offsets1[index1];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
								{
									for (var $t7 = 0; $t7 < currentLine1.marksNeedingDraw.length; $t7++) {
										var markIndex2 = currentLine1.marksNeedingDraw[$t7];
										if (paneDrawInfo.c.get('l_neighbor').gv(markIndex2) !== -1 || paneDrawInfo.c.get('r_neighbor').gv(markIndex2) !== -1) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex2, 'normalUnder', colorOverrideMode);
										}
									}
								}
								{
									for (var $t8 = 0; $t8 < currentLine1.marksNeedingDraw.length; $t8++) {
										var markIndex3 = currentLine1.marksNeedingDraw[$t8];
										this.drawLineMarkLayer(paneDrawInfo, markIndex3, 'edgeUnder', colorOverrideMode);
										if (paneDrawInfo.c.get('l_neighbor').gv(markIndex3) === -1 && paneDrawInfo.c.get('r_neighbor').gv(markIndex3) === -1 || paneDrawInfo.shouldShowMarker(markIndex3)) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex3, 'blobUnder', colorOverrideMode);
										}
									}
								}
								if (offset1 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					var $t9 = lineDrawState.get_lineAttributes();
					for (var $t10 = 0; $t10 < $t9.length; $t10++) {
						var currentLine2 = $t9[$t10];
						if (currentLine2.get_lineState() !== 'lineStateNormal') {
							continue;
						}
						var offsets2 = currentLine2.worldOffsets;
						var offsetCount2 = offsets2.length;
						for (var index2 = 0; index2 < offsetCount2; index2++) {
							var offset2 = offsets2[index2];
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
							var drawOffscreen = true;
							if (paneDrawInfo.get_hasGlobalTransparency()) {
								if (paneDrawInfo.markType === 'line') {
									drawOffscreen = currentLine2.endIndex - currentLine2.startIndex > 1;
								}
								if (drawOffscreen) {
									var limitBounds = ((!paneDrawInfo.isWrappedDomain && paneDrawInfo.markType === 'line') ? currentLine2.sloppyBoundingBox : null);
									this.beginOffScreenRender(limitBounds);
									paneDrawInfo.forceOpaqueColors = true;
								}
							}
							{
								for (var $t11 = 0; $t11 < currentLine2.marksNeedingDraw.length; $t11++) {
									var markIndex4 = currentLine2.marksNeedingDraw[$t11];
									if (paneDrawInfo.c.get('l_neighbor').gv(markIndex4) !== -1 || paneDrawInfo.c.get('r_neighbor').gv(markIndex4) !== -1) {
										this.drawLineMarkLayer(paneDrawInfo, markIndex4, 'normalOn', colorOverrideMode);
									}
									else {
										this.drawLineMarkLayer(paneDrawInfo, markIndex4, 'blobOn', colorOverrideMode);
									}
								}
							}
							{
								for (var $t12 = 0; $t12 < currentLine2.marksNeedingDraw.length; $t12++) {
									var markIndex5 = currentLine2.marksNeedingDraw[$t12];
									this.drawLineMarkLayer(paneDrawInfo, markIndex5, 'edgeOn', colorOverrideMode);
								}
							}
							if (paneDrawInfo.get_hasGlobalTransparency()) {
								if (drawOffscreen) {
									paneDrawInfo.forceOpaqueColors = false;
									this.endOffScreenRender(paneDrawInfo.globalAlpha);
								}
							}
							{
								for (var $t13 = 0; $t13 < currentLine2.marksNeedingDraw.length; $t13++) {
									var markIndex6 = currentLine2.marksNeedingDraw[$t13];
									if (paneDrawInfo.shouldShowMarker(markIndex6)) {
										this.drawLineMarkLayer(paneDrawInfo, markIndex6, 'blobOn', colorOverrideMode);
									}
								}
							}
							if (offset2 !== 0) {
								this.get_currentContext().restore();
							}
						}
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						var $t14 = lineDrawState.get_lineAttributes();
						for (var $t15 = 0; $t15 < $t14.length; $t15++) {
							var currentLine3 = $t14[$t15];
							if (currentLine3.get_lineState() !== 'lineStateHighlighted') {
								continue;
							}
							var offsets3 = currentLine3.worldOffsets;
							var offsetCount3 = offsets3.length;
							for (var index3 = 0; index3 < offsetCount3; index3++) {
								var offset3 = offsets3[index3];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
								var drawOffscreen1 = true;
								if (paneDrawInfo.get_hasGlobalTransparency()) {
									if (paneDrawInfo.markType === 'line') {
										drawOffscreen1 = currentLine3.endIndex - currentLine3.startIndex > 1;
									}
									if (drawOffscreen1) {
										var limitBounds1 = ((!paneDrawInfo.isWrappedDomain && paneDrawInfo.markType === 'line') ? currentLine3.sloppyBoundingBox : null);
										this.beginOffScreenRender(limitBounds1);
										paneDrawInfo.forceOpaqueColors = true;
									}
								}
								{
									for (var $t16 = 0; $t16 < currentLine3.marksNeedingDraw.length; $t16++) {
										var markIndex7 = currentLine3.marksNeedingDraw[$t16];
										if (!(paneDrawInfo.getMarkState(markIndex7) === 'markStateHighlighted')) {
											colorOverrideMode = 'colorOverrideFog';
										}
										if (!(paneDrawInfo.getMarkState(markIndex7) === 'markStateHighlighted' && !currentLine3.get_allHighlighted())) {
											if (paneDrawInfo.c.get('l_neighbor').gv(markIndex7) !== -1 || paneDrawInfo.c.get('r_neighbor').gv(markIndex7) !== -1) {
												this.drawLineMarkLayer(paneDrawInfo, markIndex7, 'normalOn', colorOverrideMode);
											}
											else {
												this.drawLineMarkLayer(paneDrawInfo, markIndex7, 'blobOn', colorOverrideMode);
											}
										}
										colorOverrideMode = 'colorOverrideNone';
									}
								}
								{
									for (var $t17 = 0; $t17 < currentLine3.marksNeedingDraw.length; $t17++) {
										var markIndex8 = currentLine3.marksNeedingDraw[$t17];
										if (paneDrawInfo.getMarkState(markIndex8) !== 'markStateHighlighted' || paneDrawInfo.c.get('r_neighbor').gv(markIndex8) !== -1 && paneDrawInfo.getMarkState(paneDrawInfo.c.get('r_neighbor').gv(markIndex8)) !== 'markStateHighlighted') {
											colorOverrideMode = 'colorOverrideFog';
										}
										this.drawLineMarkLayer(paneDrawInfo, markIndex8, 'edgeOn', colorOverrideMode);
										colorOverrideMode = 'colorOverrideNone';
									}
								}
								if (paneDrawInfo.get_hasGlobalTransparency()) {
									if (drawOffscreen1) {
										paneDrawInfo.forceOpaqueColors = false;
										this.endOffScreenRender(paneDrawInfo.globalAlpha);
									}
								}
								{
									for (var $t18 = 0; $t18 < currentLine3.marksNeedingDraw.length; $t18++) {
										var markIndex9 = currentLine3.marksNeedingDraw[$t18];
										if (!(paneDrawInfo.getMarkState(markIndex9) === 'markStateHighlighted')) {
											colorOverrideMode = 'colorOverrideFog';
										}
										if (!(paneDrawInfo.getMarkState(markIndex9) === 'markStateHighlighted' && !currentLine3.get_allHighlighted())) {
											if (paneDrawInfo.shouldShowMarker(markIndex9)) {
												this.drawLineMarkLayer(paneDrawInfo, markIndex9, 'blobOn', colorOverrideMode);
											}
										}
										colorOverrideMode = 'colorOverrideNone';
									}
								}
								{
									for (var $t19 = 0; $t19 < currentLine3.marksNeedingDraw.length; $t19++) {
										var markIndex10 = currentLine3.marksNeedingDraw[$t19];
										if (paneDrawInfo.getMarkState(markIndex10) === 'markStateHighlighted' && !currentLine3.get_allHighlighted()) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex10, 'highlightedUnder', colorOverrideMode);
										}
									}
								}
								{
									for (var $t20 = 0; $t20 < currentLine3.marksNeedingDraw.length; $t20++) {
										var markIndex11 = currentLine3.marksNeedingDraw[$t20];
										if (paneDrawInfo.getMarkState(markIndex11) === 'markStateHighlighted' && !currentLine3.get_allHighlighted()) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex11, 'highlightedOn', colorOverrideMode);
										}
									}
								}
								if (offset3 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						var $t21 = lineDrawState.get_lineAttributes();
						for (var $t22 = 0; $t22 < $t21.length; $t22++) {
							var currentLine4 = $t21[$t22];
							if (currentLine4.get_lineState() !== 'lineStateSelected') {
								continue;
							}
							var offsets4 = currentLine4.worldOffsets;
							var offsetCount4 = offsets4.length;
							for (var index4 = 0; index4 < offsetCount4; index4++) {
								var offset4 = offsets4[index4];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset4);
								{
									for (var $t23 = 0; $t23 < currentLine4.marksNeedingDraw.length; $t23++) {
										var markIndex12 = currentLine4.marksNeedingDraw[$t23];
										this.drawLineMarkLayer(paneDrawInfo, markIndex12, 'selectedUnder1', colorOverrideMode);
										this.drawLineMarkLayer(paneDrawInfo, markIndex12, 'selectedEdgeUnder', colorOverrideMode);
									}
								}
								if (offset4 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						var $t24 = lineDrawState.get_lineAttributes();
						for (var $t25 = 0; $t25 < $t24.length; $t25++) {
							var currentLine5 = $t24[$t25];
							if (currentLine5.get_lineState() !== 'lineStateSelected') {
								continue;
							}
							var offsets5 = currentLine5.worldOffsets;
							var offsetCount5 = offsets5.length;
							for (var index5 = 0; index5 < offsetCount5; index5++) {
								var offset5 = offsets5[index5];
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset5);
								{
									for (var $t26 = 0; $t26 < currentLine5.marksNeedingDraw.length; $t26++) {
										var markIndex13 = currentLine5.marksNeedingDraw[$t26];
										if (paneDrawInfo.c.get('l_neighbor').gv(markIndex13) !== -1 || paneDrawInfo.c.get('r_neighbor').gv(markIndex13) !== -1) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex13, 'normalOn', colorOverrideMode);
										}
										else {
											this.drawLineMarkLayer(paneDrawInfo, markIndex13, 'blobOn', colorOverrideMode);
										}
									}
								}
								{
									for (var $t27 = 0; $t27 < currentLine5.marksNeedingDraw.length; $t27++) {
										var markIndex14 = currentLine5.marksNeedingDraw[$t27];
										this.drawLineMarkLayer(paneDrawInfo, markIndex14, 'edgeOn', colorOverrideMode);
									}
								}
								{
									for (var $t28 = 0; $t28 < currentLine5.marksNeedingDraw.length; $t28++) {
										var markIndex15 = currentLine5.marksNeedingDraw[$t28];
										if (paneDrawInfo.shouldShowMarker(markIndex15)) {
											this.drawLineMarkLayer(paneDrawInfo, markIndex15, 'blobOn', colorOverrideMode);
										}
									}
								}
								if (!currentLine5.get_allHighlighted()) {
									{
										for (var $t29 = 0; $t29 < currentLine5.marksNeedingDraw.length; $t29++) {
											var markIndex16 = currentLine5.marksNeedingDraw[$t29];
											if (paneDrawInfo.getMarkState(markIndex16) === 'markStateHighlighted') {
												this.drawLineMarkLayer(paneDrawInfo, markIndex16, 'highlightedUnder', colorOverrideMode);
											}
										}
									}
									{
										for (var $t30 = 0; $t30 < currentLine5.marksNeedingDraw.length; $t30++) {
											var markIndex17 = currentLine5.marksNeedingDraw[$t30];
											if (paneDrawInfo.getMarkState(markIndex17) === 'markStateHighlighted') {
												this.drawLineMarkLayer(paneDrawInfo, markIndex17, 'highlightedOn', colorOverrideMode);
											}
										}
									}
								}
								{
									for (var $t31 = 0; $t31 < currentLine5.marksNeedingDraw.length; $t31++) {
										var markIndex18 = currentLine5.marksNeedingDraw[$t31];
										if (paneDrawInfo.getMarkState(markIndex18) === 'markStateSelected') {
											this.drawLineMarkLayer(paneDrawInfo, markIndex18, 'selectedUnder', colorOverrideMode);
										}
									}
								}
								{
									for (var $t32 = 0; $t32 < currentLine5.marksNeedingDraw.length; $t32++) {
										var markIndex19 = currentLine5.marksNeedingDraw[$t32];
										if (paneDrawInfo.getMarkState(markIndex19) === 'markStateSelected') {
											this.drawLineMarkLayer(paneDrawInfo, markIndex19, 'highlightedOn', colorOverrideMode);
										}
									}
								}
								if (offset5 !== 0) {
									this.get_currentContext().restore();
								}
							}
						}
					}
					break;
				}
			}
			this.get_currentContext().restore();
		},
		drawLineMarkLayer: function MarksRenderer$DrawLineMarkLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
			var left = paneDrawInfo.c.get('l_neighbor').gv(markIndex);
			var right = paneDrawInfo.c.get('r_neighbor').gv(markIndex);
			switch (layer) {
				case 'normalUnder': {
					var hasRight = right !== -1;
					var mode = paneDrawInfo.lineInterpolation;
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight && (mode === 'lim-step' || mode === 'lim-jump')) {
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(right) - paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'normalOn': {
					{
						{
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'blobUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 3, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'blobOn': {
					{
						{
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 3, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'highlightedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 4, paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'highlightedOn': {
					{
						{
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 4, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex) + 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'selectedUnder1': {
					var hasRight1 = right !== -1;
					var mode1 = paneDrawInfo.lineInterpolation;
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight1 && (mode1 === 'lim-step' || mode1 === 'lim-jump')) {
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(right) - paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'edgeUnder': {
					var hasRight2 = right !== -1;
					var mode2 = paneDrawInfo.lineInterpolation;
					if (hasRight2 && mode2 === 'lim-linear') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(right), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(right), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight2 && mode2 === 'lim-step') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight2 && mode2 === 'lim-step') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(right), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(right), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight2 && mode2 === 'lim-jump') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'selectedEdgeUnder': {
					var hasRight3 = right !== -1;
					var mode3 = paneDrawInfo.lineInterpolation;
					if (hasRight3 && mode3 === 'lim-linear') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(right), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(right), paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight3 && mode3 === 'lim-step') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight3 && mode3 === 'lim-step') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(right), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(right), paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					if (hasRight3 && mode3 === 'lim-jump') {
						this.$renderLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_multi_prim_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'edgeOn': {
					var hasRight4 = right !== -1;
					var mode4 = paneDrawInfo.lineInterpolation;
					if (hasRight4 && mode4 === 'lim-linear') {
						if (paneDrawInfo.isLineSegmentVisible(markIndex, right)) {
							var overrideColor = colorOverrideMode;
							if (paneDrawInfo.isLineSegmentFiltered(markIndex, right)) {
								colorOverrideMode = 'colorOverrideFog';
							}
							this.$renderFilledLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(right), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(right), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.getMarkColors(right)[colorOverrideMode]);
						}
					}
					if (hasRight4 && (mode4 === 'lim-step' || mode4 === 'lim-jump')) {
						if (paneDrawInfo.isLineSegmentVisible(markIndex, right)) {
							var overrideColor1 = colorOverrideMode;
							if (paneDrawInfo.isLineSegmentFiltered(markIndex, right)) {
								colorOverrideMode = 'colorOverrideFog';
							}
							this.$renderFilledLineEdge(paneDrawInfo.c.get('x').gv(markIndex), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					if (hasRight4 && (mode4 === 'lim-step' || mode4 === 'lim-jump')) {
						tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), paneDrawInfo.c.get('x').gv(right) - paneDrawInfo.c.get('x').gv(markIndex) + paneDrawInfo.c.get('x').gv(markIndex), 0 + paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
					}
					if (hasRight4 && mode4 === 'lim-step') {
						if (paneDrawInfo.isLineSegmentVisible(markIndex, right)) {
							var overrideColor2 = colorOverrideMode;
							if (paneDrawInfo.isLineSegmentFiltered(markIndex, right)) {
								colorOverrideMode = 'colorOverrideFog';
							}
							this.$renderFilledLineEdge(paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('x').gv(right), paneDrawInfo.c.get('y').gv(markIndex), paneDrawInfo.c.get('y').gv(right), paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('size').gv(right), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], paneDrawInfo.getMarkColors(right)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
			if (paneDrawInfo.clipCase !== 0) {
				this.get_currentContext().restore();
			}
		},
		renderShapeMark: function MarksRenderer$RenderShapeMark(paneDrawInfo, userPaneIndex, renderPass) {
			var hasSelection = paneDrawInfo.get_hasSelection();
			var hasBrushing = paneDrawInfo.get_hasBrushing();
			var colorOverrideMode = 'colorOverrideNone';
			var range = paneDrawInfo.getUserPaneMarkRange(userPaneIndex);
			var firstMark = range.firstMark;
			var lastMark = range.lastMark;
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			switch (renderPass) {
				case 'normalUnderPass': {
					if (paneDrawInfo.get_hasBackground() && paneDrawInfo.get_hasHalos()) {
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender, offset) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset);
								for (var markIndex = firstMark; markIndex <= lastMark; markIndex++) {
									if (marksNotToRender.has(markIndex)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex) !== 'markStateNormal') {
										continue;
									}
									this.drawShapeMarkLayer(paneDrawInfo, markIndex, 'normalUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
						if (hasSelection || hasBrushing) {
							colorOverrideMode = 'colorOverrideNone';
							{
								paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender1, offset1) {
									$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset1);
									for (var markIndex1 = firstMark; markIndex1 <= lastMark; markIndex1++) {
										if (marksNotToRender1.has(markIndex1)) {
											continue;
										}
										if (!paneDrawInfo.markNeedsDraw(markIndex1)) {
											continue;
										}
										if (paneDrawInfo.getMarkState(markIndex1) !== 'markStateHighlighted') {
											continue;
										}
										this.drawShapeMarkLayer(paneDrawInfo, markIndex1, 'normalUnder', colorOverrideMode);
									}
									if (!tab.DoubleUtil.isApproximatelyEqual(offset1, 0)) {
										this.get_currentContext().restore();
									}
								}));
							}
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideFog';
					}
					else {
						colorOverrideMode = 'colorOverrideNone';
					}
					{
						paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender2, offset2) {
							$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset2);
							for (var markIndex2 = firstMark; markIndex2 <= lastMark; markIndex2++) {
								if (marksNotToRender2.has(markIndex2)) {
									continue;
								}
								if (!paneDrawInfo.markNeedsDraw(markIndex2)) {
									continue;
								}
								if (paneDrawInfo.getMarkState(markIndex2) !== 'markStateNormal') {
									continue;
								}
								this.drawShapeMarkLayer(paneDrawInfo, markIndex2, 'normalOn', colorOverrideMode);
								if (paneDrawInfo.drawBorder) {
									this.drawShapeMarkLayer(paneDrawInfo, markIndex2, 'border', colorOverrideMode);
								}
							}
							if (!tab.DoubleUtil.isApproximatelyEqual(offset2, 0)) {
								this.get_currentContext().restore();
							}
						}));
					}
					break;
				}
				case 'highlightedUnderPass': {
					break;
				}
				case 'highlightedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideNone';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender3, offset3) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset3);
								for (var markIndex3 = firstMark; markIndex3 <= lastMark; markIndex3++) {
									if (marksNotToRender3.has(markIndex3)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex3)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex3) !== 'markStateHighlighted') {
										continue;
									}
									this.drawShapeMarkLayer(paneDrawInfo, markIndex3, 'normalOn', colorOverrideMode);
									if (paneDrawInfo.drawBorder) {
										this.drawShapeMarkLayer(paneDrawInfo, markIndex3, 'border', colorOverrideMode);
									}
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset3, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender4, offset4) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset4);
								for (var markIndex4 = firstMark; markIndex4 <= lastMark; markIndex4++) {
									if (marksNotToRender4.has(markIndex4)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex4)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex4) !== 'markStateSelected') {
										continue;
									}
									this.drawShapeMarkLayer(paneDrawInfo, markIndex4, 'selectedUnder', colorOverrideMode);
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset4, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (hasSelection || hasBrushing) {
						colorOverrideMode = 'colorOverrideOpaque';
						{
							paneDrawInfo.markWorldOffsets.forEach(ss.mkdel(this, function(marksNotToRender5, offset5) {
								$tab_MarksRenderer.$saveAndTranslateIfOffset(this.get_currentContext(), offset5);
								for (var markIndex5 = firstMark; markIndex5 <= lastMark; markIndex5++) {
									if (marksNotToRender5.has(markIndex5)) {
										continue;
									}
									if (!paneDrawInfo.markNeedsDraw(markIndex5)) {
										continue;
									}
									if (paneDrawInfo.getMarkState(markIndex5) !== 'markStateSelected') {
										continue;
									}
									this.drawShapeMarkLayer(paneDrawInfo, markIndex5, 'normalOn', colorOverrideMode);
									if (paneDrawInfo.drawBorder) {
										this.drawShapeMarkLayer(paneDrawInfo, markIndex5, 'border', colorOverrideMode);
									}
								}
								if (!tab.DoubleUtil.isApproximatelyEqual(offset5, 0)) {
									this.get_currentContext().restore();
								}
							}));
						}
					}
					break;
				}
			}
		},
		drawShapeMarkLayer: function MarksRenderer$DrawShapeMarkLayer(paneDrawInfo, markIndex, layer, colorOverrideMode) {
			var shapeId = paneDrawInfo.c.get('shape_id').gv(markIndex);
			if (!$tab_MarksRenderer.shapeHasLayerContent(shapeId, layer)) {
				return;
			}
			var markX = paneDrawInfo.c.get('x').gv(markIndex);
			var markY = paneDrawInfo.c.get('y').gv(markIndex);
			var canStamp = paneDrawInfo.shouldStampThisShapeMark(markIndex);
			if (!canStamp) {
				this.renderShapeMarkLayer(paneDrawInfo, markX, markY, markIndex, layer, colorOverrideMode, false);
				return;
			}
			var size = paneDrawInfo.c.get('size').gv(markIndex);
			var color = $tab_MarksRenderer.$getShapeColorForLayer(paneDrawInfo, markIndex, layer, colorOverrideMode);
			var canvasWidth = $tab_MarksRenderer.getShapeMarkSpriteSize(shapeId, layer, size) + 2;
			var canvasCenter = canvasWidth / 2;
			var top = markY - canvasCenter;
			var left = markX - canvasCenter;
			var tabContext = this.get_currentContext();
			var cacheKey = tab.ShapeManager.getCacheKey(shapeId, layer, colorOverrideMode, color, size);
			var cachedCanvas = tab.ApplicationModel.get_instance().get_shapeManager().getCachedStampCanvas(cacheKey);
			if (ss.isNullOrUndefined(cachedCanvas)) {
				var cacheableCanvasGenerator = function() {
					var offCanvas = document.createElement('canvas');
					var offContext = new tab.TabRenderContext2D(offCanvas.getContext('2d'));
					tab.CanvasUtil.sizeCanvasWithHighDPISupport(offCanvas, offContext, { w: canvasWidth, h: canvasWidth });
					if (tab.FeatureParamsLookup.getBool(38)) {
						offContext.set_shapeFillStyle('rgba(255, 0, 0, 0.12)');
						offContext.fillRect(0, 0, canvasWidth, canvasWidth);
					}
					var offRenderer = new $tab_MarksRenderer(offCanvas, offContext);
					offRenderer.renderShapeMarkLayer(paneDrawInfo, canvasCenter, canvasCenter, markIndex, layer, colorOverrideMode, true);
					return offCanvas;
				};
				cachedCanvas = tab.ApplicationModel.get_instance().get_shapeManager().generateCachedStampCanvas(cacheKey, cacheableCanvasGenerator);
			}
			if (ss.isValue(cachedCanvas)) {
				tabContext.drawImage3(cachedCanvas, left + 0.5 << 0, top + 0.5 << 0, canvasWidth, canvasWidth);
			}
			else {
				ss.Debug.assert(ss.isValue(cachedCanvas), 'All shapes should have a canvas generated for them. If we fail, just draw directly.');
				this.renderShapeMarkLayer(paneDrawInfo, markX, markY, markIndex, layer, colorOverrideMode, false);
			}
		},
		renderShapeMarkLayer: function MarksRenderer$RenderShapeMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode, skipClipping) {
			var shouldClip = paneDrawInfo.clipCase !== 0 && !skipClipping;
			if (shouldClip) {
				this.get_currentContext().save();
				this.clipRect(paneDrawInfo.clipCase, paneDrawInfo.c.get('cell_x').gv(markIndex), paneDrawInfo.c.get('cell_y').gv(markIndex), paneDrawInfo.c.get('clip_width').gv(markIndex), paneDrawInfo.c.get('clip_height').gv(markIndex));
			}
			var shape = paneDrawInfo.c.get('shape_id').gv(markIndex);
			switch (shape) {
				case 'shapeIDCircle': {
					this.$renderShapeIDCircleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledCircle': {
					this.$renderShapeIDFilledCircleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDUnscaledFilledCircle': {
					this.$renderShapeIDUnscaledFilledCircleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDSquare': {
					this.$renderShapeIDSquareMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledSquare': {
					this.$renderShapeIDFilledSquareMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDAsterisk': {
					this.$renderShapeIDAsteriskMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDPlus': {
					this.$renderShapeIDPlusMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledPlus': {
					this.$renderShapeIDFilledPlusMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDTimes': {
					this.$renderShapeIDTimesMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledTimes': {
					this.$renderShapeIDFilledTimesMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDDiamond': {
					this.$renderShapeIDDiamondMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledDiamond': {
					this.$renderShapeIDFilledDiamondMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDTriangle': {
					this.$renderShapeIDTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledTriangle': {
					this.$renderShapeIDFilledTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDDownTriangle': {
					this.$renderShapeIDDownTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledDownTriangle': {
					this.$renderShapeIDFilledDownTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDLeftTriangle': {
					this.$renderShapeIDLeftTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledLeftTriangle': {
					this.$renderShapeIDFilledLeftTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDRightTriangle': {
					this.$renderShapeIDRightTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledRightTriangle': {
					this.$renderShapeIDFilledRightTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				case 'shapeIDFilledStar': {
					this.$renderShapeIDFilledStarMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode);
					break;
				}
				default: {
					$tab_MarksRenderer.$renderCustomShape(this.get_currentContext(), paneDrawInfo, markIndex, layer, colorOverrideMode);
					break;
				}
			}
			if (shouldClip) {
				this.get_currentContext().restore();
			}
		},
		$renderShapeIDCircleMarkLayer: function MarksRenderer$RenderShapeIDCircleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'normalOn': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], 2);
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledCircleMarkLayer: function MarksRenderer$RenderShapeIDFilledCircleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'normalOn': {
					{
						{
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'border': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex) * 0.979166666666667, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1);
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDUnscaledFilledCircleMarkLayer: function MarksRenderer$RenderShapeIDUnscaledFilledCircleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'normalOn': {
					{
						{
							tab.CanvasRenderer.renderFilledCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'border': {
					{
						tab.CanvasRenderer.renderCircle(this.get_currentContext(), 0 + xPos, 0 + yPos, paneDrawInfo.c.get('size').gv(markIndex), paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1);
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDSquareMarkLayer: function MarksRenderer$RenderShapeIDSquareMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					{
						tab.CanvasRenderer.renderRectangle(this.get_currentContext(), xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'normalOn': {
					{
						tab.CanvasRenderer.renderRectangle(this.get_currentContext(), xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], 2);
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderRectangle(this.get_currentContext(), xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledSquareMarkLayer: function MarksRenderer$RenderShapeIDFilledSquareMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					{
						tab.CanvasRenderer.renderRectangle(this.get_currentContext(), xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'normalOn': {
					{
						this.renderFilledRectangle(xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
					}
					break;
				}
				case 'selectedUnder': {
					{
						tab.CanvasRenderer.renderRectangle(this.get_currentContext(), xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], 4);
					}
					break;
				}
				case 'border': {
					{
						tab.CanvasRenderer.renderRectangle(this.get_currentContext(), xPos + 0, yPos + 0, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('size').gv(markIndex) * 0.9375, paneDrawInfo.c.get('border_color').gv(markIndex)[colorOverrideMode], 1);
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDAsteriskMarkLayer: function MarksRenderer$RenderShapeIDAsteriskMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2;
					var scaledHalfSize = 0.899999976158142 * halfSize;
					var quarterSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 4;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset = xPos;
							var yOffset = yPos;
							var points = new Array(4);
							points[0] = xOffset + 0;
							points[1] = yOffset + -halfSize;
							points[2] = xOffset + 0;
							points[3] = yOffset + halfSize;
							this.$renderLine(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset1 = xPos;
							var yOffset1 = yPos;
							var points1 = new Array(4);
							points1[0] = xOffset1 + -scaledHalfSize;
							points1[1] = yOffset1 + -quarterSize;
							points1[2] = xOffset1 + scaledHalfSize;
							points1[3] = yOffset1 + quarterSize;
							this.$renderLine(points1, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset2 = xPos;
							var yOffset2 = yPos;
							var points2 = new Array(4);
							points2[0] = xOffset2 + scaledHalfSize;
							points2[1] = yOffset2 + -quarterSize;
							points2[2] = xOffset2 + -scaledHalfSize;
							points2[3] = yOffset2 + quarterSize;
							this.$renderLine(points2, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2;
					var scaledHalfSize1 = 0.899999976158142 * halfSize1;
					var quarterSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 4;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset3 = xPos;
							var yOffset3 = yPos;
							var points3 = new Array(4);
							points3[0] = xOffset3 + 0;
							points3[1] = yOffset3 + -halfSize1;
							points3[2] = xOffset3 + 0;
							points3[3] = yOffset3 + halfSize1;
							this.$renderLine(points3, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset4 = xPos;
							var yOffset4 = yPos;
							var points4 = new Array(4);
							points4[0] = xOffset4 + -scaledHalfSize1;
							points4[1] = yOffset4 + -quarterSize1;
							points4[2] = xOffset4 + scaledHalfSize1;
							points4[3] = yOffset4 + quarterSize1;
							this.$renderLine(points4, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset5 = xPos;
							var yOffset5 = yPos;
							var points5 = new Array(4);
							points5[0] = xOffset5 + scaledHalfSize1;
							points5[1] = yOffset5 + -quarterSize1;
							points5[2] = xOffset5 + -scaledHalfSize1;
							points5[3] = yOffset5 + quarterSize1;
							this.$renderLine(points5, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 2;
					var scaledHalfSize2 = 0.899999976158142 * halfSize2;
					var quarterSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.958333333333333 / 4;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset6 = xPos;
							var yOffset6 = yPos;
							var points6 = new Array(4);
							points6[0] = xOffset6 + 0;
							points6[1] = yOffset6 + -halfSize2;
							points6[2] = xOffset6 + 0;
							points6[3] = yOffset6 + halfSize2;
							this.$renderLine(points6, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset7 = xPos;
							var yOffset7 = yPos;
							var points7 = new Array(4);
							points7[0] = xOffset7 + -scaledHalfSize2;
							points7[1] = yOffset7 + -quarterSize2;
							points7[2] = xOffset7 + scaledHalfSize2;
							points7[3] = yOffset7 + quarterSize2;
							this.$renderLine(points7, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset8 = xPos;
							var yOffset8 = yPos;
							var points8 = new Array(4);
							points8[0] = xOffset8 + scaledHalfSize2;
							points8[1] = yOffset8 + -quarterSize2;
							points8[2] = xOffset8 + -scaledHalfSize2;
							points8[3] = yOffset8 + quarterSize2;
							this.$renderLine(points8, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDPlusMarkLayer: function MarksRenderer$RenderShapeIDPlusMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset = xPos;
							var yOffset = yPos;
							var points = new Array(4);
							points[0] = xOffset + 0;
							points[1] = yOffset + -halfSize;
							points[2] = xOffset + 0;
							points[3] = yOffset + halfSize;
							this.$renderLine(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset1 = xPos;
							var yOffset1 = yPos;
							var points1 = new Array(4);
							points1[0] = xOffset1 + -halfSize;
							points1[1] = yOffset1 + 0;
							points1[2] = xOffset1 + halfSize;
							points1[3] = yOffset1 + 0;
							this.$renderLine(points1, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset2 = xPos;
							var yOffset2 = yPos;
							var points2 = new Array(4);
							points2[0] = xOffset2 + 0;
							points2[1] = yOffset2 + -halfSize1;
							points2[2] = xOffset2 + 0;
							points2[3] = yOffset2 + halfSize1;
							this.$renderLine(points2, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset3 = xPos;
							var yOffset3 = yPos;
							var points3 = new Array(4);
							points3[0] = xOffset3 + -halfSize1;
							points3[1] = yOffset3 + 0;
							points3[2] = xOffset3 + halfSize1;
							points3[3] = yOffset3 + 0;
							this.$renderLine(points3, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset4 = xPos;
							var yOffset4 = yPos;
							var points4 = new Array(4);
							points4[0] = xOffset4 + 0;
							points4[1] = yOffset4 + -halfSize2;
							points4[2] = xOffset4 + 0;
							points4[3] = yOffset4 + halfSize2;
							this.$renderLine(points4, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset5 = xPos;
							var yOffset5 = yPos;
							var points5 = new Array(4);
							points5[0] = xOffset5 + -halfSize2;
							points5[1] = yOffset5 + 0;
							points5[2] = xOffset5 + halfSize2;
							points5[3] = yOffset5 + 0;
							this.$renderLine(points5, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledPlusMarkLayer: function MarksRenderer$RenderShapeIDFilledPlusMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var sixSize = halfSize / 3;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(24);
							points[0] = offsetX + -sixSize;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -sixSize;
							points[3] = offsetY + -sixSize;
							points[4] = offsetX + -halfSize;
							points[5] = offsetY + -sixSize;
							points[6] = offsetX + -halfSize;
							points[7] = offsetY + sixSize;
							points[8] = offsetX + -sixSize;
							points[9] = offsetY + sixSize;
							points[10] = offsetX + -sixSize;
							points[11] = offsetY + halfSize;
							points[12] = offsetX + sixSize;
							points[13] = offsetY + halfSize;
							points[14] = offsetX + sixSize;
							points[15] = offsetY + sixSize;
							points[16] = offsetX + halfSize;
							points[17] = offsetY + sixSize;
							points[18] = offsetX + halfSize;
							points[19] = offsetY + -sixSize;
							points[20] = offsetX + sixSize;
							points[21] = offsetY + -sixSize;
							points[22] = offsetX + sixSize;
							points[23] = offsetY + -halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var sixSize1 = halfSize1 / 3;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(24);
							points1[0] = offsetX1 + -sixSize1;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -sixSize1;
							points1[3] = offsetY1 + -sixSize1;
							points1[4] = offsetX1 + -halfSize1;
							points1[5] = offsetY1 + -sixSize1;
							points1[6] = offsetX1 + -halfSize1;
							points1[7] = offsetY1 + sixSize1;
							points1[8] = offsetX1 + -sixSize1;
							points1[9] = offsetY1 + sixSize1;
							points1[10] = offsetX1 + -sixSize1;
							points1[11] = offsetY1 + halfSize1;
							points1[12] = offsetX1 + sixSize1;
							points1[13] = offsetY1 + halfSize1;
							points1[14] = offsetX1 + sixSize1;
							points1[15] = offsetY1 + sixSize1;
							points1[16] = offsetX1 + halfSize1;
							points1[17] = offsetY1 + sixSize1;
							points1[18] = offsetX1 + halfSize1;
							points1[19] = offsetY1 + -sixSize1;
							points1[20] = offsetX1 + sixSize1;
							points1[21] = offsetY1 + -sixSize1;
							points1[22] = offsetX1 + sixSize1;
							points1[23] = offsetY1 + -halfSize1;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var sixSize2 = halfSize2 / 3;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(24);
							points2[0] = offsetX2 + -sixSize2;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -sixSize2;
							points2[3] = offsetY2 + -sixSize2;
							points2[4] = offsetX2 + -halfSize2;
							points2[5] = offsetY2 + -sixSize2;
							points2[6] = offsetX2 + -halfSize2;
							points2[7] = offsetY2 + sixSize2;
							points2[8] = offsetX2 + -sixSize2;
							points2[9] = offsetY2 + sixSize2;
							points2[10] = offsetX2 + -sixSize2;
							points2[11] = offsetY2 + halfSize2;
							points2[12] = offsetX2 + sixSize2;
							points2[13] = offsetY2 + halfSize2;
							points2[14] = offsetX2 + sixSize2;
							points2[15] = offsetY2 + sixSize2;
							points2[16] = offsetX2 + halfSize2;
							points2[17] = offsetY2 + sixSize2;
							points2[18] = offsetX2 + halfSize2;
							points2[19] = offsetY2 + -sixSize2;
							points2[20] = offsetX2 + sixSize2;
							points2[21] = offsetY2 + -sixSize2;
							points2[22] = offsetX2 + sixSize2;
							points2[23] = offsetY2 + -halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDTimesMarkLayer: function MarksRenderer$RenderShapeIDTimesMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset = xPos;
							var yOffset = yPos;
							var points = new Array(4);
							points[0] = xOffset + -halfSize;
							points[1] = yOffset + -halfSize;
							points[2] = xOffset + halfSize;
							points[3] = yOffset + halfSize;
							this.$renderLine(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset1 = xPos;
							var yOffset1 = yPos;
							var points1 = new Array(4);
							points1[0] = xOffset1 + -halfSize;
							points1[1] = yOffset1 + halfSize;
							points1[2] = xOffset1 + halfSize;
							points1[3] = yOffset1 + -halfSize;
							this.$renderLine(points1, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset2 = xPos;
							var yOffset2 = yPos;
							var points2 = new Array(4);
							points2[0] = xOffset2 + -halfSize1;
							points2[1] = yOffset2 + -halfSize1;
							points2[2] = xOffset2 + halfSize1;
							points2[3] = yOffset2 + halfSize1;
							this.$renderLine(points2, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset3 = xPos;
							var yOffset3 = yPos;
							var points3 = new Array(4);
							points3[0] = xOffset3 + -halfSize1;
							points3[1] = yOffset3 + halfSize1;
							points3[2] = xOffset3 + halfSize1;
							points3[3] = yOffset3 + -halfSize1;
							this.$renderLine(points3, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.875 / 2;
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset4 = xPos;
							var yOffset4 = yPos;
							var points4 = new Array(4);
							points4[0] = xOffset4 + -halfSize2;
							points4[1] = yOffset4 + -halfSize2;
							points4[2] = xOffset4 + halfSize2;
							points4[3] = yOffset4 + halfSize2;
							this.$renderLine(points4, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					{
						{
							this.get_currentContext().set_lineCap('square');
							var xOffset5 = xPos;
							var yOffset5 = yPos;
							var points5 = new Array(4);
							points5[0] = xOffset5 + -halfSize2;
							points5[1] = yOffset5 + halfSize2;
							points5[2] = xOffset5 + halfSize2;
							points5[3] = yOffset5 + -halfSize2;
							this.$renderLine(points5, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode], true);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledTimesMarkLayer: function MarksRenderer$RenderShapeIDFilledTimesMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var quarterSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 4;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(24);
							points[0] = offsetX + -quarterSize;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + -quarterSize;
							points[4] = offsetX + -quarterSize;
							points[5] = offsetY + 0;
							points[6] = offsetX + -halfSize;
							points[7] = offsetY + quarterSize;
							points[8] = offsetX + -quarterSize;
							points[9] = offsetY + halfSize;
							points[10] = offsetX + 0;
							points[11] = offsetY + quarterSize;
							points[12] = offsetX + quarterSize;
							points[13] = offsetY + halfSize;
							points[14] = offsetX + halfSize;
							points[15] = offsetY + quarterSize;
							points[16] = offsetX + quarterSize;
							points[17] = offsetY + 0;
							points[18] = offsetX + halfSize;
							points[19] = offsetY + -quarterSize;
							points[20] = offsetX + quarterSize;
							points[21] = offsetY + -halfSize;
							points[22] = offsetX + 0;
							points[23] = offsetY + -quarterSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var quarterSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 4;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(24);
							points1[0] = offsetX1 + -quarterSize1;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + -quarterSize1;
							points1[4] = offsetX1 + -quarterSize1;
							points1[5] = offsetY1 + 0;
							points1[6] = offsetX1 + -halfSize1;
							points1[7] = offsetY1 + quarterSize1;
							points1[8] = offsetX1 + -quarterSize1;
							points1[9] = offsetY1 + halfSize1;
							points1[10] = offsetX1 + 0;
							points1[11] = offsetY1 + quarterSize1;
							points1[12] = offsetX1 + quarterSize1;
							points1[13] = offsetY1 + halfSize1;
							points1[14] = offsetX1 + halfSize1;
							points1[15] = offsetY1 + quarterSize1;
							points1[16] = offsetX1 + quarterSize1;
							points1[17] = offsetY1 + 0;
							points1[18] = offsetX1 + halfSize1;
							points1[19] = offsetY1 + -quarterSize1;
							points1[20] = offsetX1 + quarterSize1;
							points1[21] = offsetY1 + -halfSize1;
							points1[22] = offsetX1 + 0;
							points1[23] = offsetY1 + -quarterSize1;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 2;
					var quarterSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.9375 / 4;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(24);
							points2[0] = offsetX2 + -quarterSize2;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + -quarterSize2;
							points2[4] = offsetX2 + -quarterSize2;
							points2[5] = offsetY2 + 0;
							points2[6] = offsetX2 + -halfSize2;
							points2[7] = offsetY2 + quarterSize2;
							points2[8] = offsetX2 + -quarterSize2;
							points2[9] = offsetY2 + halfSize2;
							points2[10] = offsetX2 + 0;
							points2[11] = offsetY2 + quarterSize2;
							points2[12] = offsetX2 + quarterSize2;
							points2[13] = offsetY2 + halfSize2;
							points2[14] = offsetX2 + halfSize2;
							points2[15] = offsetY2 + quarterSize2;
							points2[16] = offsetX2 + quarterSize2;
							points2[17] = offsetY2 + 0;
							points2[18] = offsetX2 + halfSize2;
							points2[19] = offsetY2 + -quarterSize2;
							points2[20] = offsetX2 + quarterSize2;
							points2[21] = offsetY2 + -halfSize2;
							points2[22] = offsetX2 + 0;
							points2[23] = offsetY2 + -quarterSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDDiamondMarkLayer: function MarksRenderer$RenderShapeIDDiamondMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(8);
							points[0] = offsetX + 0;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + 0;
							points[4] = offsetX + 0;
							points[5] = offsetY + halfSize;
							points[6] = offsetX + halfSize;
							points[7] = offsetY + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(8);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + 0;
							points1[4] = offsetX1 + 0;
							points1[5] = offsetY1 + halfSize1;
							points1[6] = offsetX1 + halfSize1;
							points1[7] = offsetY1 + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points1, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(8);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + 0;
							points2[4] = offsetX2 + 0;
							points2[5] = offsetY2 + halfSize2;
							points2[6] = offsetX2 + halfSize2;
							points2[7] = offsetY2 + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledDiamondMarkLayer: function MarksRenderer$RenderShapeIDFilledDiamondMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(8);
							points[0] = offsetX + 0;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + 0;
							points[4] = offsetX + 0;
							points[5] = offsetY + halfSize;
							points[6] = offsetX + halfSize;
							points[7] = offsetY + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(8);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + 0;
							points1[4] = offsetX1 + 0;
							points1[5] = offsetY1 + halfSize1;
							points1[6] = offsetX1 + halfSize1;
							points1[7] = offsetY1 + 0;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 1.04166666666667 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(8);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + 0;
							points2[4] = offsetX2 + 0;
							points2[5] = offsetY2 + halfSize2;
							points2[6] = offsetX2 + halfSize2;
							points2[7] = offsetY2 + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDTriangleMarkLayer: function MarksRenderer$RenderShapeIDTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + 0;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + halfSize1;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points1, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledTriangleMarkLayer: function MarksRenderer$RenderShapeIDFilledTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + 0;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + halfSize1;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDDownTriangleMarkLayer: function MarksRenderer$RenderShapeIDDownTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + 0;
							points[1] = offsetY + halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + -halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + -halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + -halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + -halfSize1;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points1, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + -halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + -halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledDownTriangleMarkLayer: function MarksRenderer$RenderShapeIDFilledDownTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + 0;
							points[1] = offsetY + halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + -halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + -halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + -halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + -halfSize1;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + -halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + -halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDLeftTriangleMarkLayer: function MarksRenderer$RenderShapeIDLeftTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + -halfSize;
							points[1] = offsetY + 0;
							points[2] = offsetX + halfSize;
							points[3] = offsetY + -halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + -halfSize1;
							points1[1] = offsetY1 + 0;
							points1[2] = offsetX1 + halfSize1;
							points1[3] = offsetY1 + -halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + halfSize1;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points1, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + -halfSize2;
							points2[1] = offsetY2 + 0;
							points2[2] = offsetX2 + halfSize2;
							points2[3] = offsetY2 + -halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledLeftTriangleMarkLayer: function MarksRenderer$RenderShapeIDFilledLeftTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + -halfSize;
							points[1] = offsetY + 0;
							points[2] = offsetX + halfSize;
							points[3] = offsetY + -halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + halfSize;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + -halfSize1;
							points1[1] = offsetY1 + 0;
							points1[2] = offsetX1 + halfSize1;
							points1[3] = offsetY1 + -halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + halfSize1;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + -halfSize2;
							points2[1] = offsetY2 + 0;
							points2[2] = offsetX2 + halfSize2;
							points2[3] = offsetY2 + -halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + halfSize2;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDRightTriangleMarkLayer: function MarksRenderer$RenderShapeIDRightTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + -halfSize;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + -halfSize1;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points1, 2, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.895833333333333 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + -halfSize2;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledRightTriangleMarkLayer: function MarksRenderer$RenderShapeIDFilledRightTriangleMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var halfSize = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(6);
							points[0] = offsetX + -halfSize;
							points[1] = offsetY + -halfSize;
							points[2] = offsetX + -halfSize;
							points[3] = offsetY + halfSize;
							points[4] = offsetX + halfSize;
							points[5] = offsetY + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var halfSize1 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(6);
							points1[0] = offsetX1 + -halfSize1;
							points1[1] = offsetY1 + -halfSize1;
							points1[2] = offsetX1 + -halfSize1;
							points1[3] = offsetY1 + halfSize1;
							points1[4] = offsetX1 + halfSize1;
							points1[5] = offsetY1 + 0;
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var halfSize2 = paneDrawInfo.c.get('size').gv(markIndex) * 0.916666666666667 / 2;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(6);
							points2[0] = offsetX2 + -halfSize2;
							points2[1] = offsetY2 + -halfSize2;
							points2[2] = offsetX2 + -halfSize2;
							points2[3] = offsetY2 + halfSize2;
							points2[4] = offsetX2 + halfSize2;
							points2[5] = offsetY2 + 0;
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		$renderShapeIDFilledStarMarkLayer: function MarksRenderer$RenderShapeIDFilledStarMarkLayer(paneDrawInfo, xPos, yPos, markIndex, layer, colorOverrideMode) {
			switch (layer) {
				case 'normalUnder': {
					var size = paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667;
					var halfSize = size / 2;
					var computedVal = size * 0.3877;
					{
						{
							var offsetX = xPos;
							var offsetY = yPos;
							var points = new Array(20);
							points[0] = offsetX + 0;
							points[1] = offsetY + (-halfSize + size * 0.0246);
							points[2] = offsetX + (-halfSize + size * 0.3817);
							points[3] = offsetY + (-halfSize + computedVal);
							points[4] = offsetX + -halfSize;
							points[5] = offsetY + (-halfSize + computedVal);
							points[6] = offsetX + (-halfSize + size * 0.3088);
							points[7] = offsetY + (-halfSize + size * 0.612);
							points[8] = offsetX + (-halfSize + size * 0.1909);
							points[9] = offsetY + (-halfSize + size * 0.9751);
							points[10] = offsetX + 0;
							points[11] = offsetY + (-halfSize + size * 0.7507);
							points[12] = offsetX + (-halfSize + size * 0.8085);
							points[13] = offsetY + (-halfSize + size * 0.9751);
							points[14] = offsetX + (-halfSize + size * 0.6905);
							points[15] = offsetY + (-halfSize + size * 0.612);
							points[16] = offsetX + halfSize;
							points[17] = offsetY + (-halfSize + computedVal);
							points[18] = offsetX + (-halfSize + size * 0.6176);
							points[19] = offsetY + (-halfSize + computedVal);
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points, 4, paneDrawInfo.c.get('halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'normalOn': {
					var size1 = paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667;
					var halfSize1 = size1 / 2;
					var computedVal1 = size1 * 0.3877;
					{
						{
							var offsetX1 = xPos;
							var offsetY1 = yPos;
							var points1 = new Array(20);
							points1[0] = offsetX1 + 0;
							points1[1] = offsetY1 + (-halfSize1 + size1 * 0.0246);
							points1[2] = offsetX1 + (-halfSize1 + size1 * 0.3817);
							points1[3] = offsetY1 + (-halfSize1 + computedVal1);
							points1[4] = offsetX1 + -halfSize1;
							points1[5] = offsetY1 + (-halfSize1 + computedVal1);
							points1[6] = offsetX1 + (-halfSize1 + size1 * 0.3088);
							points1[7] = offsetY1 + (-halfSize1 + size1 * 0.612);
							points1[8] = offsetX1 + (-halfSize1 + size1 * 0.1909);
							points1[9] = offsetY1 + (-halfSize1 + size1 * 0.9751);
							points1[10] = offsetX1 + 0;
							points1[11] = offsetY1 + (-halfSize1 + size1 * 0.7507);
							points1[12] = offsetX1 + (-halfSize1 + size1 * 0.8085);
							points1[13] = offsetY1 + (-halfSize1 + size1 * 0.9751);
							points1[14] = offsetX1 + (-halfSize1 + size1 * 0.6905);
							points1[15] = offsetY1 + (-halfSize1 + size1 * 0.612);
							points1[16] = offsetX1 + halfSize1;
							points1[17] = offsetY1 + (-halfSize1 + computedVal1);
							points1[18] = offsetX1 + (-halfSize1 + size1 * 0.6176);
							points1[19] = offsetY1 + (-halfSize1 + computedVal1);
							this.$renderFilledPolygon(points1, paneDrawInfo.getMarkColors(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				case 'selectedUnder': {
					var size2 = paneDrawInfo.c.get('size').gv(markIndex) * 1.09166666666667;
					var halfSize2 = size2 / 2;
					var computedVal2 = size2 * 0.3877;
					{
						{
							var offsetX2 = xPos;
							var offsetY2 = yPos;
							var points2 = new Array(20);
							points2[0] = offsetX2 + 0;
							points2[1] = offsetY2 + (-halfSize2 + size2 * 0.0246);
							points2[2] = offsetX2 + (-halfSize2 + size2 * 0.3817);
							points2[3] = offsetY2 + (-halfSize2 + computedVal2);
							points2[4] = offsetX2 + -halfSize2;
							points2[5] = offsetY2 + (-halfSize2 + computedVal2);
							points2[6] = offsetX2 + (-halfSize2 + size2 * 0.3088);
							points2[7] = offsetY2 + (-halfSize2 + size2 * 0.612);
							points2[8] = offsetX2 + (-halfSize2 + size2 * 0.1909);
							points2[9] = offsetY2 + (-halfSize2 + size2 * 0.9751);
							points2[10] = offsetX2 + 0;
							points2[11] = offsetY2 + (-halfSize2 + size2 * 0.7507);
							points2[12] = offsetX2 + (-halfSize2 + size2 * 0.8085);
							points2[13] = offsetY2 + (-halfSize2 + size2 * 0.9751);
							points2[14] = offsetX2 + (-halfSize2 + size2 * 0.6905);
							points2[15] = offsetY2 + (-halfSize2 + size2 * 0.612);
							points2[16] = offsetX2 + halfSize2;
							points2[17] = offsetY2 + (-halfSize2 + computedVal2);
							points2[18] = offsetX2 + (-halfSize2 + size2 * 0.6176);
							points2[19] = offsetY2 + (-halfSize2 + computedVal2);
							this.get_currentContext().set_lineJoin('miter');
							this.$renderPolygon(points2, 4, paneDrawInfo.c.get('selected_halo_color').gv(markIndex)[colorOverrideMode]);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		},
		drawPredictionBandLayer: function MarksRenderer$DrawPredictionBandLayer(paneDrawInfo, i, layer, colorOverrideMode, pm, colorOverrideAlpha) {
			switch (layer) {
				case 'normalUnder': {
					var color = pm.qrgbColor;
					if (paneDrawInfo.isTupleVisible(pm.tupleIds[i])) {
						if ((i === 0 || !paneDrawInfo.isTupleVisible(pm.tupleIds[i - 1])) && (i + 1 >= pm.upperEnd.length || !paneDrawInfo.isTupleVisible(pm.tupleIds[i + 1]))) {
							var halfWidth = ss.Int32.div(pm.widths[i], 2) + 2.5;
							if (pm.useYAxis) {
								var y0 = paneDrawInfo.thisDomainToPixelY(pm.upperEnd[i]);
								var y1 = paneDrawInfo.thisDomainToPixelY(pm.lowerEnd[i]);
								var x = paneDrawInfo.thisDomainToPixelX(pm.oppositeAxis[i]);
								{
									var pts = [x - halfWidth, y0, x - halfWidth, y1, x + halfWidth, y1, x + halfWidth, y0];
									this.$renderFilledPolygon(pts, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha));
								}
							}
							else {
								var x0 = paneDrawInfo.thisDomainToPixelX(pm.upperEnd[i]);
								var x1 = paneDrawInfo.thisDomainToPixelX(pm.lowerEnd[i]);
								var y = paneDrawInfo.thisDomainToPixelY(pm.oppositeAxis[i]);
								{
									var pts1 = [x0, y - halfWidth, x1, y - halfWidth, x1, y + halfWidth, x0, y + halfWidth];
									this.$renderFilledPolygon(pts1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha));
								}
							}
						}
						else if (i + 1 < pm.tupleIds.length && paneDrawInfo.isTupleVisible(pm.tupleIds[i + 1])) {
							var mode = paneDrawInfo.lineInterpolation;
							if (pm.useYAxis) {
								var y0_upper = paneDrawInfo.thisDomainToPixelY(pm.upperEnd[i]);
								var y0_lower = paneDrawInfo.thisDomainToPixelY(pm.lowerEnd[i]);
								var x01 = paneDrawInfo.thisDomainToPixelX(pm.oppositeAxis[i]);
								var x11 = paneDrawInfo.thisDomainToPixelX(pm.oppositeAxis[i + 1]);
								if (mode === 'lim-step' || mode === 'lim-jump') {
									{
										var pts2 = [x01, y0_lower, x11, y0_lower, x11, y0_upper, x01, y0_upper];
										this.$renderFilledPolygon(pts2, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha));
									}
								}
								else {
									var y1_upper = paneDrawInfo.thisDomainToPixelY(pm.upperEnd[i + 1]);
									var y1_lower = paneDrawInfo.thisDomainToPixelY(pm.lowerEnd[i + 1]);
									{
										var pts3 = [x01, y0_lower, x11, y1_lower, x11, y1_upper, x01, y0_upper];
										this.$renderFilledPolygon(pts3, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha));
									}
								}
							}
							else {
								var x0_upper = paneDrawInfo.thisDomainToPixelX(pm.upperEnd[i]);
								var x0_lower = paneDrawInfo.thisDomainToPixelX(pm.lowerEnd[i]);
								var x1_upper = paneDrawInfo.thisDomainToPixelX(pm.upperEnd[i + 1]);
								var x1_lower = paneDrawInfo.thisDomainToPixelX(pm.lowerEnd[i + 1]);
								var y01 = paneDrawInfo.thisDomainToPixelY(pm.oppositeAxis[i]);
								var y11 = paneDrawInfo.thisDomainToPixelY(pm.oppositeAxis[i + 1]);
								if (mode === 'lim-step' || mode === 'lim-jump') {
									{
										var pts4 = [x0_lower, y01, x0_lower, y11, x0_upper, y11, x0_upper, y01];
										this.$renderFilledPolygon(pts4, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha));
									}
								}
								else {
									{
										var pts5 = [x0_lower, y01, x1_lower, y11, x1_upper, y11, x0_upper, y01];
										this.$renderFilledPolygon(pts5, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha));
									}
								}
							}
						}
					}
					break;
				}
			}
		},
		renderPredictionBand: function MarksRenderer$RenderPredictionBand(paneDrawInfo, renderPass, rnpm, role) {
			var colorOverrideMode = 'colorOverrideNone';
			var colorOverrideAlpha = 255;
			var pm = rnpm;
			var SelectionStateNormal = 0;
			var SelectionStateHighlighted = 1;
			var SelectionStateSelected = 2;
			var selectionState = SelectionStateNormal;
			for (var $t1 = 0; $t1 < pm.lineTupleIds.length; $t1++) {
				var tuple = pm.lineTupleIds[$t1];
				if (paneDrawInfo.isTupleSelected(tuple)) {
					selectionState = SelectionStateSelected;
					break;
				}
				if (selectionState !== SelectionStateHighlighted && paneDrawInfo.isTupleHighlighted(tuple)) {
					selectionState = SelectionStateHighlighted;
				}
			}
			if (selectionState !== SelectionStateSelected) {
				for (var $t2 = 0; $t2 < pm.tupleIds.length; $t2++) {
					var tuple1 = pm.tupleIds[$t2];
					if (paneDrawInfo.isTupleSelected(tuple1)) {
						selectionState = SelectionStateSelected;
						break;
					}
					if (selectionState !== SelectionStateHighlighted && paneDrawInfo.isTupleHighlighted(tuple1)) {
						selectionState = SelectionStateHighlighted;
					}
				}
			}
			switch (renderPass) {
				case 'normalUnderPass': {
					if (selectionState === SelectionStateNormal && role === 'underMark') {
						if (paneDrawInfo.get_hasSelection() || paneDrawInfo.get_hasBrushing()) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						var imax = pm.tupleIds.length;
						for (var i = 0; i < imax; i++) {
							this.drawPredictionBandLayer(paneDrawInfo, i, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
						}
					}
					break;
				}
				case 'highlightedUnderPass': {
					if (selectionState === SelectionStateHighlighted && role === 'underMark') {
						var imax1 = pm.tupleIds.length;
						for (var i1 = 0; i1 < imax1; i1++) {
							if (paneDrawInfo.isTupleHighlighted(pm.tupleIds[i1]) && ((i1 === 0 || !paneDrawInfo.isTupleVisible(pm.tupleIds[i1 - 1])) && (i1 + 1 >= pm.upperEnd.length || !paneDrawInfo.isTupleVisible(pm.tupleIds[i1 + 1])) || i1 + 1 < pm.tupleIds.length && paneDrawInfo.isTupleVisible(pm.tupleIds[i1 + 1]) && paneDrawInfo.isTupleHighlighted(pm.tupleIds[i1 + 1]))) {
								colorOverrideMode = 'colorOverrideNone';
							}
							else {
								colorOverrideMode = 'colorOverrideFog';
							}
							this.drawPredictionBandLayer(paneDrawInfo, i1, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (selectionState === SelectionStateSelected && role === 'underMark') {
						colorOverrideMode = 'colorOverrideReplaceAlpha';
						colorOverrideAlpha = 76.5;
						var imax2 = pm.tupleIds.length;
						for (var i2 = 0; i2 < imax2; i2++) {
							this.drawPredictionBandLayer(paneDrawInfo, i2, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
						}
					}
					break;
				}
			}
		},
		drawPredictionWhiskerLayer: function MarksRenderer$DrawPredictionWhiskerLayer(paneDrawInfo, i, layer, colorOverrideMode, pm, colorOverrideAlpha) {
			switch (layer) {
				case 'border': {
					if (paneDrawInfo.isTupleVisible(pm.tupleIds[i])) {
						var halfWidth = ss.Int32.div(pm.widths[i] - 1, 2);
						if (pm.useYAxis) {
							var x = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelX(pm.oppositeAxis[i]));
							var y0 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelY(pm.upperEnd[i]));
							var y1 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelY(pm.lowerEnd[i]));
							var crossbarTop = y0 - 0.5;
							var crossbarBottom = y1 + 1.5;
							var crossbarLeft = x - 0.5 - halfWidth;
							var crossbarRight = x + 1.5 + halfWidth;
							var mastTop = y0 + 1.5;
							var mastBottom = y1 - 0.5;
							var mastLeft = x - 0.5;
							var mastRight = x + 1.5;
							{
								var pts = [crossbarLeft, crossbarTop, crossbarRight, crossbarTop, crossbarRight, mastTop, mastRight, mastTop, mastRight, mastBottom, crossbarRight, mastBottom, crossbarRight, crossbarBottom, crossbarLeft, crossbarBottom, crossbarLeft, mastBottom, mastLeft, mastBottom, mastLeft, mastTop, crossbarLeft, mastTop];
								this.renderLineLoop(pts, 1, paneDrawInfo.getOneColorAlpha(pm.qrgbColor, colorOverrideMode, colorOverrideAlpha));
							}
						}
						else {
							var y = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelY(pm.oppositeAxis[i]));
							var x0 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelX(pm.lowerEnd[i]));
							var x1 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelX(pm.upperEnd[i]));
							var crossbarTop1 = y - 0.5 - halfWidth;
							var crossbarBottom1 = y + 1.5 + halfWidth;
							var crossbarLeft1 = x0 - 0.5;
							var crossbarRight1 = x1 + 1.5;
							var mastTop1 = y - 0.5;
							var mastBottom1 = y + 1.5;
							var mastLeft1 = x0 + 1.5;
							var mastRight1 = x1 - 0.5;
							{
								var pts1 = [crossbarLeft1, crossbarTop1, mastLeft1, crossbarTop1, mastLeft1, mastTop1, mastRight1, mastTop1, mastRight1, crossbarTop1, crossbarRight1, crossbarTop1, crossbarRight1, crossbarBottom1, mastRight1, crossbarBottom1, mastRight1, mastBottom1, mastLeft1, mastBottom1, mastLeft1, crossbarBottom1, crossbarLeft1, crossbarBottom1];
								this.renderLineLoop(pts1, 1, paneDrawInfo.getOneColorAlpha(pm.qrgbColor, colorOverrideMode, colorOverrideAlpha));
							}
						}
					}
					break;
				}
				case 'normalUnder': {
					if (paneDrawInfo.isTupleVisible(pm.tupleIds[i])) {
						var halfWidth1 = ss.Int32.div(pm.widths[i] - 1, 2);
						var color = pm.qrgbColors[i];
						if (pm.useYAxis) {
							var x2 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelX(pm.oppositeAxis[i]));
							var y01 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelY(pm.upperEnd[i]));
							var y11 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelY(pm.lowerEnd[i]));
							{
								var pts2 = [x2 - halfWidth1, y01 + 0.5, x2 + halfWidth1 + 1, y01 + 0.5];
								this.$renderLine(pts2, 1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha), false);
							}
							{
								var pts3 = [x2 - halfWidth1, y11 + 0.5, x2 + halfWidth1 + 1, y11 + 0.5];
								this.$renderLine(pts3, 1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha), false);
							}
							{
								var pts4 = [x2 + 0.5, y01 + 1, x2 + 0.5, y11];
								this.$renderLine(pts4, 1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha), false);
							}
						}
						else {
							var y2 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelY(pm.oppositeAxis[i]));
							var x01 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelX(pm.lowerEnd[i]));
							var x11 = ss.Int32.trunc(paneDrawInfo.thisDomainToPixelX(pm.upperEnd[i]));
							{
								var pts5 = [x01 + 0.5, y2 - halfWidth1, x01 + 0.5, y2 + halfWidth1 + 1];
								this.$renderLine(pts5, 1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha), false);
							}
							{
								var pts6 = [x11 + 0.5, y2 - halfWidth1, x11 + 0.5, y2 + halfWidth1 + 1];
								this.$renderLine(pts6, 1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha), false);
							}
							{
								var pts7 = [x01 + 1, y2 + 0.5, x11, y2 + 0.5];
								this.$renderLine(pts7, 1, paneDrawInfo.getOneColorAlpha(color, colorOverrideMode, colorOverrideAlpha), false);
							}
						}
					}
					break;
				}
			}
		},
		renderPredictionWhisker: function MarksRenderer$RenderPredictionWhisker(paneDrawInfo, renderPass, rnpm, role) {
			var colorOverrideMode = 'colorOverrideNone';
			var colorOverrideAlpha = 255;
			var pm = rnpm;
			switch (renderPass) {
				case 'normalUnderPass': {
					if (!pm.renderOnTop && role === 'underMark') {
						if (paneDrawInfo.get_hasSelection() || paneDrawInfo.get_hasBrushing()) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						var imax = pm.tupleIds.length;
						for (var i = 0; i < imax; i++) {
							if (!paneDrawInfo.isTupleHighlighted(pm.tupleIds[i]) && !paneDrawInfo.isTupleSelected(pm.tupleIds[i])) {
								this.drawPredictionWhiskerLayer(paneDrawInfo, i, 'border', colorOverrideMode, pm, colorOverrideAlpha);
								this.drawPredictionWhiskerLayer(paneDrawInfo, i, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
							}
						}
					}
					break;
				}
				case 'normalOnPass': {
					if (pm.renderOnTop && role === 'underLabel') {
						if (paneDrawInfo.get_hasSelection() || paneDrawInfo.get_hasBrushing()) {
							colorOverrideMode = 'colorOverrideFog';
						}
						else {
							colorOverrideMode = 'colorOverrideNone';
						}
						var imax1 = pm.tupleIds.length;
						for (var i1 = 0; i1 < imax1; i1++) {
							if (!paneDrawInfo.isTupleHighlighted(pm.tupleIds[i1]) && !paneDrawInfo.isTupleSelected(pm.tupleIds[i1])) {
								this.drawPredictionWhiskerLayer(paneDrawInfo, i1, 'border', colorOverrideMode, pm, colorOverrideAlpha);
								this.drawPredictionWhiskerLayer(paneDrawInfo, i1, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
							}
						}
					}
					break;
				}
				case 'selectedUnderPass': {
					if (!pm.renderOnTop && role === 'underMark') {
						var imax2 = pm.tupleIds.length;
						for (var i2 = 0; i2 < imax2; i2++) {
							if (paneDrawInfo.isTupleSelected(pm.tupleIds[i2])) {
								colorOverrideMode = 'colorOverrideReplaceAlpha';
								colorOverrideAlpha = 63.75;
								this.drawPredictionWhiskerLayer(paneDrawInfo, i2, 'border', colorOverrideMode, pm, colorOverrideAlpha);
								colorOverrideMode = 'colorOverrideReplaceAlpha';
								colorOverrideAlpha = pm.maxAlpha / 255 * 255;
								this.drawPredictionWhiskerLayer(paneDrawInfo, i2, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
							}
						}
					}
					break;
				}
				case 'selectedOnPass': {
					if (pm.renderOnTop && role === 'underLabel') {
						var imax3 = pm.tupleIds.length;
						for (var i3 = 0; i3 < imax3; i3++) {
							if (paneDrawInfo.isTupleSelected(pm.tupleIds[i3])) {
								colorOverrideMode = 'colorOverrideReplaceAlpha';
								colorOverrideAlpha = 63.75;
								this.drawPredictionWhiskerLayer(paneDrawInfo, i3, 'border', colorOverrideMode, pm, colorOverrideAlpha);
								colorOverrideMode = 'colorOverrideReplaceAlpha';
								colorOverrideAlpha = pm.maxAlpha / 255 * 255;
								this.drawPredictionWhiskerLayer(paneDrawInfo, i3, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
							}
						}
					}
					break;
				}
				case 'highlightedUnderPass': {
					if (!pm.renderOnTop && role === 'underMark') {
						colorOverrideMode = 'colorOverrideNone';
						var imax4 = pm.tupleIds.length;
						for (var i4 = 0; i4 < imax4; i4++) {
							if (paneDrawInfo.isTupleHighlighted(pm.tupleIds[i4])) {
								this.drawPredictionWhiskerLayer(paneDrawInfo, i4, 'border', colorOverrideMode, pm, colorOverrideAlpha);
								this.drawPredictionWhiskerLayer(paneDrawInfo, i4, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
							}
						}
					}
					break;
				}
				case 'highlightedOnPass': {
					if (pm.renderOnTop && role === 'underLabel') {
						colorOverrideMode = 'colorOverrideNone';
						var imax5 = pm.tupleIds.length;
						for (var i5 = 0; i5 < imax5; i5++) {
							if (paneDrawInfo.isTupleHighlighted(pm.tupleIds[i5])) {
								this.drawPredictionWhiskerLayer(paneDrawInfo, i5, 'border', colorOverrideMode, pm, colorOverrideAlpha);
								this.drawPredictionWhiskerLayer(paneDrawInfo, i5, 'normalUnder', colorOverrideMode, pm, colorOverrideAlpha);
							}
						}
					}
					break;
				}
			}
		},
		$clippedByUserPane: function MarksRenderer$ClippedByUserPane(userPaneRect, x, y, width, height) {
			var margin = 1;
			var twoMargin = 2 * margin;
			return !tab.RectXYUtil.completelyContains$1(userPaneRect, ss.Int32.trunc(x) - margin, ss.Int32.trunc(y) - margin, ss.Int32.trunc(width) + twoMargin, ss.Int32.trunc(height) + twoMargin);
		},
		clipRect: function MarksRenderer$ClipRect(cellClipCase, x, y, width, height) {
			if (cellClipCase === 0) {
				return;
			}
			this.get_currentContext().setClip($tab_MarksRenderer.$getClipRect(cellClipCase, x, y, width, height));
		},
		$renderLine: function MarksRenderer$RenderLine(points, strokeWidth, color, adjust) {
			var context = this.get_currentContext();
			context.set_linePattern('solid');
			context.set_lineWidth(strokeWidth);
			context.set_strokeStyle(color);
			tab.CanvasRenderer.strokePath(context, points, false, adjust);
		},
		renderLineLoop: function MarksRenderer$RenderLineLoop(points, strokeWidth, color) {
			var context = this.get_currentContext();
			context.set_linePattern('solid');
			context.set_lineWidth(strokeWidth);
			context.set_strokeStyle(color);
			tab.CanvasRenderer.strokePath(context, points, true, false);
		},
		$renderLineEdge: function MarksRenderer$RenderLineEdge(x0, x1, y0, y1, width0, width1, haloColor, strokeWidth) {
			var context = this.get_currentContext();
			context.set_linePattern('solid');
			context.set_lineWidth(strokeWidth);
			context.set_strokeStyle(haloColor);
			var angle = Math.atan2(y1 - y0, x1 - x0);
			var cosAngle = Math.cos(angle);
			var sinAngle = Math.sin(angle);
			width0 /= 2;
			width1 /= 2;
			var width0SinAngle = width0 * sinAngle;
			var width1SinAngle = width1 * sinAngle;
			var width0CosAngle = width0 * cosAngle;
			var width1CosAngle = width1 * cosAngle;
			context.beginPath();
			context.moveTo(x0 + width0SinAngle, y0 - width0CosAngle);
			context.lineTo(x1 + width1SinAngle, y1 - width1CosAngle);
			context.lineTo(x1 - width1SinAngle, y1 + width1CosAngle);
			context.lineTo(x0 - width0SinAngle, y0 + width0CosAngle);
			context.closePath();
			context.stroke();
		},
		$renderFilledLineEdge: function MarksRenderer$RenderFilledLineEdge(x0, x1, y0, y1, width0, width1, color0, color1) {
			var finalColor;
			var context = this.get_currentContext();
			if (ss.referenceEquals(color0, color1)) {
				finalColor = color0;
			}
			else {
				var colorGrad = context.createLinearGradient(x0, y0, x1, y1);
				colorGrad.addColorStop(0, color0);
				colorGrad.addColorStop(1, color1);
				finalColor = colorGrad;
			}
			if (width0 === width1) {
				context.set_lineWidth(width0);
				context.set_linePattern('solid');
				context.set_strokeStyle(finalColor);
				context.beginPath();
				context.moveTo(x0, y0);
				context.lineTo(x1, y1);
				context.closePath();
				context.stroke();
			}
			else {
				var angle = Math.atan2(y1 - y0, x1 - x0);
				var cosAngle = Math.cos(angle);
				var sinAngle = Math.sin(angle);
				width0 /= 2;
				width1 /= 2;
				var width0SinAngle = width0 * sinAngle;
				var width1SinAngle = width1 * sinAngle;
				var width0CosAngle = width0 * cosAngle;
				var width1CosAngle = width1 * cosAngle;
				context.beginPath();
				context.moveTo(x0 + width0SinAngle, y0 - width0CosAngle);
				context.lineTo(x1 + width1SinAngle, y1 - width1CosAngle);
				context.lineTo(x1 - width1SinAngle, y1 + width1CosAngle);
				context.lineTo(x0 - width0SinAngle, y0 + width0CosAngle);
				context.closePath();
				context.set_shapeFillStyle(finalColor);
				context.fill();
			}
		},
		$renderPolygon: function MarksRenderer$RenderPolygon(points, strokeWidth, color) {
			var context = this.get_currentContext();
			context.set_lineWidth(strokeWidth);
			context.set_strokeStyle(color);
			tab.CanvasRenderer.strokePath(context, points, true, true);
		},
		$renderFilledPolygon: function MarksRenderer$RenderFilledPolygon(points, color) {
			var context = this.get_currentContext();
			context.set_shapeFillStyle(color);
			tab.CanvasRenderer.fillPath(context, points, true);
		},
		$setupContextForTextRendering: function MarksRenderer$SetupContextForTextRendering(paneDrawInfo) {
			this.get_currentContext().set_shapeFillStyle(paneDrawInfo.$getTextStyleColor(0, -1, 'colorOverrideNone'));
			var styleSetter = this.createStyleSettersAndSetDominantStyle(paneDrawInfo.get_textStyleColumns());
			return styleSetter;
		}
	}, tab.CanvasRenderer);
	ss.initClass($tab_HackyShapeSwatchRenderer, $asm, {
		get_currentContext: function HackyShapeSwatchRenderer$get_CurrentContext() {
			if (ss.isValue(this.$context)) {
				return this.$context;
			}
			return tab.CanvasRenderer.prototype.get_currentContext.call(this);
		},
		$createBlankDataColumnPresModel: function HackyShapeSwatchRenderer$CreateBlankDataColumnPresModel(arraySize) {
			var columnModel = { dataValues: new Array(arraySize) };
			return columnModel;
		},
		containsShape: function HackyShapeSwatchRenderer$ContainsShape(shapeId) {
			return ss.isValue(this.$shapeToMarkMap[shapeId.toString()]);
		},
		renderSwatch: function HackyShapeSwatchRenderer$RenderSwatch(ctx, shapeId, shouldFog) {
			this.$context = ctx;
			var colorMode = (shouldFog ? 'colorOverrideFog' : 'colorOverrideOpaque');
			this.drawShapeMarkLayer(this.$fakePaneDrawInfo, this.$shapeToMarkMap[shapeId.toString()], 'normalOn', colorMode);
		}
	}, $tab_MarksRenderer);
	ss.initEnum($tab_HitResultHitType, $asm, { noHit: 0, areaHit: 1, nearHit: 2, exactHit: 3 });
	ss.initClass($tab_HitTargetNode, $asm, {
		get_objectId: function HitTargetNode$get_ObjectId() {
			return this.$objectId;
		},
		get_worldOffset: function HitTargetNode$get_WorldOffset() {
			return this.$worldOffset;
		},
		get_nodeType: function HitTargetNode$get_NodeType() {
			return this.$nodeType;
		},
		get_boundingBox: function HitTargetNode$get_BoundingBox() {
			return this.$boundingBox;
		},
		get_labelBox: function HitTargetNode$get_LabelBox() {
			return this.$labelBoundingBox;
		},
		get_children: function HitTargetNode$get_Children() {
			return this.$children;
		},
		get_parent: function HitTargetNode$get_Parent() {
			return this.$parent;
		},
		set_parent: function HitTargetNode$set_Parent(value) {
			this.$parent = value;
		},
		get_paneKey: function HitTargetNode$get_PaneKey() {
			return this.$paneKey;
		},
		set_paneKey: function HitTargetNode$set_PaneKey(value) {
			this.$paneKey = value;
		},
		get_paneIndex: function HitTargetNode$get_PaneIndex() {
			return this.$paneIndex;
		},
		set_paneIndex: function HitTargetNode$set_PaneIndex(value) {
			this.$paneIndex = value;
		},
		get_paneOrderIndex: function HitTargetNode$get_PaneOrderIndex() {
			return this.$paneOrderIndex;
		},
		set_paneOrderIndex: function HitTargetNode$set_PaneOrderIndex(value) {
			this.$paneOrderIndex = value;
		},
		addNode: function HitTargetNode$AddNode(node) {
			this.$children.push(node);
			node.set_parent(this);
		},
		addNodes: function HitTargetNode$AddNodes(nodes) {
			ss.arrayAddRange(this.$children, nodes);
			for (var $t1 = 0; $t1 < nodes.length; $t1++) {
				var childNode = nodes[$t1];
				childNode.set_parent(this);
			}
		},
		resetChildren: function HitTargetNode$ResetChildren() {
			ss.clear(this.$children);
		}
	});
	ss.initClass($tab_HitTestChain, $asm, {
		$hitTest: function HitTestChain$HitTest(order, p, isSingleSelect) {
			var toRet = [];
			if (order.length === 0) {
				return toRet;
			}
			var results = new Array();
			for (var $t1 = 0; $t1 < order.length; $t1++) {
				var type = order[$t1];
				var link = this.$hitTestLinkDictionary[type];
				if (ss.isValue(link)) {
					results.push(link.hitTest(p, isSingleSelect));
				}
			}
			do {
				toRet = [$tab_HitTestResult.tieBreakHits(results.pop(), toRet)];
			} while (results.length > 0);
			return toRet;
		},
		getHitTestLink: function HitTestChain$GetHitTestLink(type) {
			return this.$hitTestLinkDictionary[type];
		},
		onTapHitTest: function HitTestChain$OnTapHitTest(p, isSingleSelect) {
			return this.$hitTest(this.$tapHitTestOrder, p, isSingleSelect);
		},
		onHoverHitTest: function HitTestChain$OnHoverHitTest(p, isSingleSelect) {
			return this.$hitTest(this.$hoverHitTestOrder, p, isSingleSelect);
		},
		clearCache: function HitTestChain$ClearCache() {
			var $t1 = ss.getEnumerator(Object.keys(this.$hitTestLinkDictionary));
			try {
				while ($t1.moveNext()) {
					var type = $t1.current();
					this.$hitTestLinkDictionary[type].clearCache();
				}
			}
			finally {
				$t1.dispose();
			}
		}
	});
	ss.initClass($tab_HitTestDebugger, $asm, {
		get_context2D: function HitTestDebugger$get_Context2D() {
			return ss.cast(this.$debugCanvasEl.getContext('2d'), CanvasRenderingContext2D);
		},
		debugDrawBoundingBoxesHierarchy: function HitTestDebugger$DebugDrawBoundingBoxesHierarchy(root) {
			this.clear();
			this.$debugDrawBoundingBoxesImpl(root);
		},
		debugDrawBoundingBoxesHierarchies: function HitTestDebugger$DebugDrawBoundingBoxesHierarchies(roots) {
			this.clear();
			for (var $t1 = 0; $t1 < roots.length; $t1++) {
				var root = roots[$t1];
				this.$debugDrawBoundingBoxesImpl(root);
			}
		},
		clear: function HitTestDebugger$Clear() {
			this.get_context2D().clearRect(0, 0, this.$debugCanvasEl.width, this.$debugCanvasEl.height);
		},
		done: function HitTestDebugger$Done() {
			this.$vizCanvasEl.style.position = this.$oldPosSetting;
			this.$canvasParentContainer.removeChild(this.$debugCanvasEl);
		},
		$debugDrawBoundingBoxesImpl: function HitTestDebugger$DebugDrawBoundingBoxesImpl(root) {
			var queue = new Array();
			queue.push(root);
			while (queue.length > 0) {
				var node = queue.shift();
				if (node.get_nodeType() === 2) {
					var bb = node.get_boundingBox();
					this.get_context2D().save();
					if ($tab_HitTestDebugger.$binAlternation % 2 === 0) {
						this.get_context2D().fillStyle = 'rgba(120, 255, 20, 0.1)';
					}
					else {
						this.get_context2D().fillStyle = 'rgba(20, 255, 120, 0.1)';
					}
					this.get_context2D().fillRect(bb.x, bb.y, bb.w, bb.h);
					this.get_context2D().restore();
					++$tab_HitTestDebugger.$binAlternation;
				}
				if (node.get_nodeType() === 3 || node.get_nodeType() === 5) {
					var bb1 = node.get_boundingBox();
					this.get_context2D().save();
					this.get_context2D().fillStyle = 'rgba(255, 0, 0, 0.2)';
					this.get_context2D().fillRect(bb1.x, bb1.y, bb1.w, bb1.h);
					this.get_context2D().restore();
				}
				if (node.get_nodeType() === 4) {
					var bb2 = node.get_boundingBox();
					this.get_context2D().save();
					this.get_context2D().fillStyle = 'rgba(0, 0, 255, 0.2)';
					this.get_context2D().fillRect(bb2.x, bb2.y, bb2.w, bb2.h);
					this.get_context2D().restore();
				}
				var children = node.get_children();
				children.forEach(function(child) {
					queue.push(child);
				});
			}
		}
	});
	ss.initClass($tab_HitTester, $asm, {
		hitTestPanes: function HitTester$HitTestPanes(selectionRect) {
			var paneKeys = [];
			var stack = new Array();
			stack.push(this.$root);
			while (stack.length > 0) {
				var node = stack.pop();
				var hit = tab.RectXYUtil.intersectsWith(node.get_boundingBox(), selectionRect);
				if (hit) {
					if (node.get_nodeType() === 1) {
						paneKeys.push(node.get_paneKey());
					}
					else {
						var children = node.get_children();
						children.forEach(function(child) {
							stack.push(child);
						});
					}
				}
			}
			return paneKeys;
		},
		hitTest: function HitTester$HitTest(selectionRect, isSingleSelect, sceneInfo) {
			tab.Log.get(this).debug('isSingleSelect: %s', [isSingleSelect]);
			if (tab.RectXYUtil.isEmpty(selectionRect)) {
				return [];
			}
			var intersectedBBoxes = this.hitTestBoundingBoxes(selectionRect, isSingleSelect, sceneInfo);
			return (isSingleSelect ? this.hitTestSingle(selectionRect, sceneInfo, intersectedBBoxes) : this.$hitTestArea(selectionRect, sceneInfo, intersectedBBoxes));
		},
		hitTestSingle: function HitTester$HitTestSingle(selectionRect, sceneInfo, intersectedBBoxes) {
			var selCtrX = selectionRect.x + ss.Int32.div(selectionRect.w, 2);
			var selCtrY = selectionRect.y + ss.Int32.div(selectionRect.h, 2);
			var paneToMarkNodes = {};
			var paneNodes = [];
			for (var i = intersectedBBoxes.length - 1; i >= 0; i--) {
				var nn = intersectedBBoxes[i];
				if (nn.get_objectId() < 0) {
					tab.Log.get(this).warn('Mark Node has invalid mark index: ' + nn.get_objectId(), []);
					continue;
				}
				var paneNode = $tab_HitTargetNode.findPaneNode(nn);
				if (ss.isNullOrUndefined(paneNode)) {
					tab.Log.get(this).warn("Couldn't find idx #" + nn.get_objectId() + "'s pane node.", []);
					continue;
				}
				if (ss.isNullOrUndefined(paneToMarkNodes[paneNode.get_paneIndex()])) {
					paneToMarkNodes[paneNode.get_paneIndex()] = [];
					paneNodes.push(paneNode);
				}
				paneToMarkNodes[paneNode.get_paneIndex()].push(nn);
			}
			var exactHits = [];
			var nearHits = [];
			var markPaneAndStateMap = {};
			for (var $t1 = 0; $t1 < paneNodes.length; $t1++) {
				var paneNode1 = paneNodes[$t1];
				var paneDrawInfo = sceneInfo.getPaneDrawInfoFromKey(paneNode1.get_paneKey());
				var offsetSelectionRectangle = tab.RectXYUtil.offsetRect(selectionRect, { x: -paneDrawInfo.paneRect.x, y: -paneDrawInfo.paneRect.y });
				var $t2 = paneToMarkNodes[paneNode1.get_paneIndex()];
				for (var $t3 = 0; $t3 < $t2.length; $t3++) {
					var nn1 = $t2[$t3];
					var currentNodeMarkState = paneDrawInfo.getMarkState(nn1.get_objectId());
					var pixelWorldOffset = nn1.get_worldOffset();
					var tupleId = paneDrawInfo.c.get('tuple_id').gv(nn1.get_objectId());
					var exactLabelHit = false;
					if (ss.isValue(nn1.get_labelBox())) {
						exactLabelHit = tab.RectXYUtil.intersectsWithMoreThanSharedEdge(nn1.get_labelBox(), selectionRect);
					}
					if (exactLabelHit) {
						exactHits.push(new $tab_HitTestResult.$ctor1(tupleId, 8, 3));
						markPaneAndStateMap[tupleId] = { item1: paneNode1.get_paneOrderIndex(), item2: currentNodeMarkState };
						tab.Log.get(this).debug('Exact Label Hit: idx#%d, Tuple Id: %s, MarkState: %s', [nn1.get_objectId(), tupleId, currentNodeMarkState]);
					}
					var exactHit = $tab_HitTester.$exactHit(paneDrawInfo, offsetSelectionRectangle, nn1.get_objectId(), pixelWorldOffset, paneDrawInfo.markType);
					if (exactHit) {
						exactHits.push(new $tab_HitTestResult.$ctor1(tupleId, 7, 3));
						markPaneAndStateMap[tupleId] = { item1: paneNode1.get_paneOrderIndex(), item2: currentNodeMarkState };
						tab.Log.get(this).debug('Exact Hit: idx#%d, Tuple Id: %s, MarkState: %s', [nn1.get_objectId(), tupleId, currentNodeMarkState]);
					}
					else if (exactHits.length === 0) {
						var nearHit = $tab_HitTester.$nearHit(paneDrawInfo, offsetSelectionRectangle, nn1.get_objectId(), pixelWorldOffset, paneDrawInfo.markType);
						if (nearHit) {
							var dist;
							switch (paneDrawInfo.markType) {
								case 'line': {
									dist = $tab_MarksRenderer.lineMarkGetDistanceToMark(paneDrawInfo, selCtrX, selCtrY, nn1.get_objectId());
									break;
								}
								case 'bar':
								case 'square': {
									dist = $tab_MarksRenderer.barMarkGetDistanceToMark(paneDrawInfo, selCtrX, selCtrY, nn1.get_objectId());
									break;
								}
								case 'shape': {
									dist = $tab_MarksRenderer.shapeMarkGetDistanceToMark(paneDrawInfo, selCtrX, selCtrY, nn1.get_objectId());
									break;
								}
								case 'text': {
									dist = $tab_MarksRenderer.textMarkGetDistanceToMark(paneDrawInfo, selCtrX, selCtrY, nn1.get_objectId());
									break;
								}
								case 'area': {
									dist = $tab_MarksRenderer.areaMarkGetDistanceToMark(paneDrawInfo, selCtrX, selCtrY, nn1.get_objectId());
									break;
								}
								default: {
									dist = $tab_GeometryUtil.getSquaredDistanceToCenter(nn1.get_boundingBox(), { x: selCtrX, y: selCtrY });
									break;
								}
							}
							var nearHitResult = new $tab_HitTestResult.$ctor1(tupleId, 7, 2);
							nearHits.push({ item1: nearHitResult, item2: dist });
							markPaneAndStateMap[tupleId] = { item1: paneNode1.get_paneOrderIndex(), item2: currentNodeMarkState };
							tab.Log.get(this).debug('Near Hit: idx#%d, Tuple Id: %s, MarkState: %s', [nn1.get_objectId(), tupleId, currentNodeMarkState]);
						}
						else {
							tab.Log.get(this).debug('No hit', []);
						}
					}
				}
			}
			if (exactHits.length > 0) {
				var htr = this.$selectHighestZIndexMark(exactHits, markPaneAndStateMap);
				if (htr.get_hitType() === 3) {
					return [htr];
				}
			}
			if (nearHits.length > 0) {
				var htr1 = this.$selectClosestMark(nearHits, markPaneAndStateMap);
				if (htr1.get_hitType() === 2) {
					return [htr1];
				}
			}
			return [];
		},
		$hitTestArea: function HitTester$HitTestArea(selectionRect, sceneInfo, intersectedBBoxes) {
			var selectedIds = [];
			for (var i = intersectedBBoxes.length - 1; i >= 0; i--) {
				var nn = intersectedBBoxes[i];
				var markIndex = nn.get_objectId();
				if (markIndex < 0) {
					tab.Log.get(this).warn('Mark Node has invalid mark index: ' + markIndex, []);
					continue;
				}
				var paneNode = $tab_HitTargetNode.findPaneNode(nn);
				if (ss.isNullOrUndefined(paneNode)) {
					tab.Log.get(this).warn("Couldn't find idx #" + markIndex + "'s pane node.", []);
					continue;
				}
				var paneDrawInfo = sceneInfo.getPaneDrawInfoFromKey(paneNode.get_paneKey());
				var transform = $tab_HitTester.getTransformInfo(paneDrawInfo, nn);
				var areaHit = $tab_HitTester.rectangleAreaHit(paneDrawInfo, nn.get_boundingBox(), selectionRect, markIndex, transform, paneDrawInfo.markType);
				if (areaHit) {
					selectedIds.push(new $tab_HitTestResult.$ctor1(paneDrawInfo.c.get('tuple_id').gv(markIndex), 7, 1));
				}
			}
			return selectedIds;
		},
		hitTestBoundingBoxes: function HitTester$HitTestBoundingBoxes(selectionRect, isSingleSelect, sceneInfo) {
			if (tab.RectXYUtil.isEmpty(selectionRect)) {
				return [];
			}
			var intersectedBBoxes = [];
			var stack = new Array();
			var trueSelectionRectangles = {};
			stack.push(this.$root);
			while (stack.length > 0) {
				var node = stack.pop();
				var trueSelectionRectangle = selectionRect;
				if (isSingleSelect && ss.isValue(sceneInfo) && node.get_nodeType() === 3) {
					var paneNode = $tab_HitTargetNode.findPaneNode(node);
					if (ss.isValue(paneNode)) {
						var paneKey = paneNode.get_paneKey();
						if (ss.keyExists(trueSelectionRectangles, paneKey)) {
							trueSelectionRectangle = trueSelectionRectangles[paneKey];
						}
						else {
							var paneDrawInfo = sceneInfo.getPaneDrawInfoFromKey(paneNode.get_paneKey());
							if (ss.isValue(paneDrawInfo)) {
								var delta;
								switch (paneDrawInfo.markType) {
									case 'multipolygon': {
										delta = $tab_MarksRenderer.multipolygonMarkGetHitTestExpansion(paneDrawInfo, node.get_objectId());
										break;
									}
									case 'bar':
									case 'square': {
										delta = $tab_MarksRenderer.barMarkGetHitTestExpansion(paneDrawInfo, node.get_objectId());
										break;
									}
									case 'shape': {
										delta = $tab_MarksRenderer.shapeMarkGetHitTestExpansion(paneDrawInfo, node.get_objectId());
										break;
									}
									case 'text': {
										delta = $tab_MarksRenderer.textMarkGetHitTestExpansion(paneDrawInfo, node.get_objectId());
										break;
									}
									case 'area': {
										delta = $tab_MarksRenderer.areaMarkGetHitTestExpansion(paneDrawInfo, node.get_objectId());
										break;
									}
									default: {
										delta = null;
										break;
									}
								}
								if (ss.isValue(delta) && !tab.SizeUtil.isEmpty(delta)) {
									trueSelectionRectangle = tab.RectXYUtil.outsetRectSizeF(trueSelectionRectangle, delta);
								}
							}
							trueSelectionRectangles[paneKey] = trueSelectionRectangle;
						}
					}
				}
				var hit = tab.RectXYUtil.intersectsWithMoreThanSharedEdge(node.get_boundingBox(), trueSelectionRectangle);
				if (!hit && isSingleSelect && ss.isValue(node.get_labelBox())) {
					hit = tab.RectXYUtil.intersectsWithMoreThanSharedEdge(node.get_labelBox(), selectionRect);
				}
				if (hit) {
					if (node.get_nodeType() === 3) {
						intersectedBBoxes.push(node);
					}
					else {
						var children = node.get_children();
						children.forEach(function(child) {
							stack.push(child);
						});
					}
				}
			}
			tab.Log.get(this).debug('Hit %d bounding boxes', [intersectedBBoxes.length]);
			return intersectedBBoxes;
		},
		$selectHighestZIndexMark: function HitTester$SelectHighestZIndexMark(selectedMarks, markPaneAndStateMap) {
			if (selectedMarks.length === 0) {
				tab.Log.get(this).warn('Exact hit on marks/marklabels is empty when doing tie-breaking', []);
				return $tab_HitTestResult.createEmptyHitTestResult();
			}
			var topHtr = $tab_HitTestResult.createEmptyHitTestResult();
			selectedMarks.sort(function(htr1, htr2) {
				return ((htr1.get_id() > htr2.get_id()) ? -1 : 1);
			});
			for (var $t1 = 0; $t1 < selectedMarks.length; $t1++) {
				var htr = selectedMarks[$t1];
				if (!ss.keyExists(markPaneAndStateMap, htr.get_id())) {
					tab.Log.get(this).warn('Mark Node with tuple id:%s has no entry in markStateMap', [htr.get_id()]);
					continue;
				}
				if (markPaneAndStateMap[htr.get_id()].item2 === 'markStateInvisible') {
					continue;
				}
				if (topHtr.get_hitType() === 0) {
					topHtr = htr;
				}
				else {
					var paneAndMarkStateCompare = this.$compareMarkStateAndPaneOrder(htr.get_id(), topHtr.get_id(), markPaneAndStateMap);
					if (paneAndMarkStateCompare > 0) {
						topHtr = htr;
					}
					else if (paneAndMarkStateCompare === 0) {
						if (htr.get_hitObjectType() > topHtr.get_hitObjectType()) {
							topHtr = htr;
						}
					}
				}
			}
			return topHtr;
		},
		$selectClosestMark: function HitTester$SelectClosestMark(htrsAndDistances, markPaneAndStateMap) {
			if (htrsAndDistances.length === 0) {
				tab.Log.get(this).warn('Near hit on marks is empty when doing tie-breaking', []);
				return $tab_HitTestResult.createEmptyHitTestResult();
			}
			var nearestHtr = $tab_HitTestResult.createEmptyHitTestResult();
			var closestDistance = null;
			htrsAndDistances.sort(function(htr1, htr2) {
				return ((htr1.item1.get_id() > htr2.item1.get_id()) ? -1 : 1);
			});
			for (var $t1 = 0; $t1 < htrsAndDistances.length; $t1++) {
				var t = htrsAndDistances[$t1];
				var htr = t.item1;
				var distance = t.item2;
				if (!ss.keyExists(markPaneAndStateMap, htr.get_id())) {
					tab.Log.get(this).warn('Mark Node with tuple id:%s has no entry in markStateMap', [htr.get_id()]);
					continue;
				}
				if (markPaneAndStateMap[htr.get_id()].item2 === 'markStateInvisible') {
					continue;
				}
				if (nearestHtr.get_hitType() === 0) {
					nearestHtr = htr;
					closestDistance = distance;
				}
				else if (ss.Nullable$1.lt(distance, closestDistance)) {
					nearestHtr = htr;
					closestDistance = distance;
				}
				else if (distance === closestDistance && this.$compareMarkStateAndPaneOrder(htr.get_id(), nearestHtr.get_id(), markPaneAndStateMap) > 0) {
					nearestHtr = htr;
				}
			}
			return nearestHtr;
		},
		$compareMarkStateAndPaneOrder: function HitTester$CompareMarkStateAndPaneOrder(currentId, currentBestId, markPaneAndStateMap) {
			var currentMarkTuple = markPaneAndStateMap[currentId];
			var currentBestMarkTuple = markPaneAndStateMap[currentBestId];
			var currentMarkState = this.$markStateToInt(currentMarkTuple.item2);
			var currentBestMarkState = this.$markStateToInt(currentBestMarkTuple.item2);
			if (currentMarkState > currentBestMarkState) {
				return 1;
			}
			if (currentMarkState === currentBestMarkState) {
				var currentMarkPaneOrderIndex = currentMarkTuple.item1;
				var currentBestMarkPaneOrderIndex = currentBestMarkTuple.item1;
				if (currentMarkPaneOrderIndex > currentBestMarkPaneOrderIndex) {
					return 1;
				}
				if (currentMarkPaneOrderIndex === currentBestMarkPaneOrderIndex) {
					return 0;
				}
			}
			return -1;
		},
		$markStateToInt: function HitTester$MarkStateToInt(markState) {
			switch (markState) {
				case 'markStateInvisible': {
					return 0;
				}
				case 'markStateNormal': {
					return 1;
				}
				case 'markStateHighlighted': {
					return 2;
				}
				case 'markStateSelected': {
					return 3;
				}
				default: {
					tab.Log.get(this).warn('Unknown MarkState: %s. Time to update MarkStateToInt.', [markState]);
					return -1;
				}
			}
		}
	});
	ss.initEnum($tab_HitTestLinkType, $asm, { annotation: 0, refLine: 1, trendLine: 2, marks: 3 });
	ss.initClass($tab_HitTestResult, $asm, {
		get_id: function HitTestResult$get_Id() {
			return this.$id;
		},
		get_hitObjectType: function HitTestResult$get_HitObjectType() {
			return this.$hitObjectType;
		},
		get_hitType: function HitTestResult$get_HitType() {
			return this.$hitType;
		},
		get_shouldRenderOverlay: function HitTestResult$get_ShouldRenderOverlay() {
			return this.$shouldRenderOverlay;
		},
		get_overlayTargetType: function HitTestResult$get_OverlayTargetType() {
			switch (this.$hitObjectType) {
				case 6: {
					return 'semantic-ref-line';
				}
				case 4:
				case 5: {
					return 'ref-line';
				}
				case 3: {
					return 'trend-line';
				}
				case 7:
				case 8: {
					return 'mark';
				}
				default: {
					return 'unspecified';
				}
			}
		},
		get_tooltipTargetType: function HitTestResult$get_TooltipTargetType() {
			switch (this.$hitObjectType) {
				case 6: {
					return 'refline';
				}
				case 4:
				case 5:
				case 3: {
					return 'visualparts';
				}
				case 7:
				case 8: {
					return 'mark';
				}
				default: {
					return 'unspecified';
				}
			}
		},
		doNotRenderOverlay: function HitTestResult$DoNotRenderOverlay() {
			this.$shouldRenderOverlay = false;
		}
	}, null, [tab.IHitTestResult]);
	$tab_HitTestResult.$ctor1.prototype = $tab_HitTestResult.prototype;
	ss.initClass($tab_HitTestStructureBuilder, $asm, {});
	ss.initClass($tab_ImageDownloaderImageData, $asm, {
		get_imageNode: function ImageDownloaderImageData$get_ImageNode() {
			return this.$imgNode;
		},
		set_imageNode: function ImageDownloaderImageData$set_ImageNode(value) {
			this.$imgNode = value;
		},
		get_index: function ImageDownloaderImageData$get_Index() {
			return this.$idx;
		},
		get_src: function ImageDownloaderImageData$get_Src() {
			return this.$src;
		},
		get_bounds: function ImageDownloaderImageData$get_Bounds() {
			return this.$bounds;
		},
		get_version: function ImageDownloaderImageData$get_Version() {
			return this.$version;
		}
	});
	ss.initClass($tab_ImageLoadedEventArgs, $asm, {
		get_image: function ImageLoadedEventArgs$get_Image() {
			return this.$image;
		}
	}, ss.EventArgs);
	ss.initInterface($tab_IMapControl, $asm, { get_enabled: null, zoomOnPoint: null, anchorZoom: null, zoomRect: null, moveToBounds: null, panTo: null, updateLocalCenter: null, updateLocalMapDataForZoomAround: null, touchMove: null, touchEnd: null, pinchScale: null, splatOverlayToMapForTransition: null, createMap: null, destroyMap: null, resize: null, setScrollX: null, setScrollY: null, removeMarkOverlay: null }, [ss.IDisposable]);
	ss.initClass($tab_InteractionColorModel, $asm, {});
	ss.initInterface($tab_IRuntimeUIModule, $asm, { createNonMarksRenderer: null, renderGridLines: null, createPaneDrawInfo: null });
	ss.initInterface($tab_IZoomToolbarContainer, $asm, { get_zoomToolbarContainerDiv: null, get_isMapSearchEnabled: null, get_shouldEnableZoomHomeToolbar: null, get_zoomToolbarOffset: null, get_zoomToolbarOperations: null, get_shouldShowTools: null, allowPanZoomActions: null, isVizLargerThanScreen: null });
	ss.initClass($tab_LeafletMapControl, $asm, {
		get_enabled: function LeafletMapControl$get_Enabled() {
			return ss.isValue(this.$deferredMap) && this.$mapData.get_useFastMaps();
		},
		get_$centerFromModel: function LeafletMapControl$get_CenterFromModel() {
			if (!tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL') && this.$mapData.get_allowLocalPanAndZoom() && ss.isValue(this.$localMapData)) {
				return this.$localMapData.get_$center();
			}
			else {
				return new L.LatLng(this.$mapData.get_centerLatitude(), this.$mapData.get_centerLongitude());
			}
		},
		get_$zoomLevelFromModel: function LeafletMapControl$get_ZoomLevelFromModel() {
			if (!tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL') && this.$mapData.get_allowLocalPanAndZoom() && ss.isValue(this.$localMapData)) {
				return this.$localMapData.get_$zoomLevel();
			}
			else {
				return this.$mapData.get_zoom();
			}
		},
		zoomOnPoint: function LeafletMapControl$ZoomOnPoint(zoomCenter, zoomDir) {
			var result = $.Deferred();
			if (!this.get_enabled()) {
				return result.resolve(false);
			}
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var zoomLevel = $tab_ZoomComputer.incrementZoom(this.get_$zoomLevelFromModel(), zoomDir);
				var destLatLong;
				if (ss.isNullOrUndefined(zoomCenter)) {
					destLatLong = map.getCenter();
				}
				else {
					destLatLong = map.containerPointToLatLng(new L.Point(zoomCenter.x, zoomCenter.y));
				}
				_.defer(ss.mkdel(this, function() {
					this.$setView(destLatLong, zoomLevel, true).done(function() {
						result.resolve(true);
					});
				}));
			}));
			return result;
		},
		anchorZoom: function LeafletMapControl$AnchorZoom(newZoomLevel, anchorPoint, animate) {
			var result = $.Deferred();
			if (!this.get_enabled()) {
				return result.resolve(false);
			}
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var destLatLong = map.containerPointToLatLng(new L.Point(anchorPoint.x, anchorPoint.y));
				_.defer(ss.mkdel(this, function() {
					this.$setZoomAround(destLatLong, newZoomLevel, animate).done(function() {
						result.resolve(true);
					});
				}));
			}));
			return result;
		},
		zoomRect: function LeafletMapControl$ZoomRect(rect) {
			var result = $.Deferred();
			if (!this.get_enabled()) {
				return result.resolve(false);
			}
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var southWest = map.containerPointToLatLng(new L.Point(rect.x, rect.y + rect.h));
				var northEast = map.containerPointToLatLng(new L.Point(rect.x + rect.w, rect.y));
				var leafBounds = new L.LatLngBounds(southWest, northEast);
				var rectCenter = new L.Point(rect.x + ss.Int32.div(rect.w, 2), rect.y + ss.Int32.div(rect.h, 2));
				var destLatLong = map.containerPointToLatLng(rectCenter);
				var newZoomLevel = this.$getBoundsZoom(map, leafBounds);
				var animate = this.$shouldAnimateZoom(map, newZoomLevel);
				this.$setView(destLatLong, newZoomLevel, animate).done(function() {
					result.resolve(animate);
				});
			}));
			return result;
		},
		moveToBounds: function LeafletMapControl$MoveToBounds(bounds) {
			var result = $.Deferred();
			if (!this.get_enabled()) {
				return result.resolve(false);
			}
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var southWest = new L.LatLng(bounds.minLatitude, bounds.minLongitude);
				var northEast = new L.LatLng(bounds.maxLatitude, bounds.maxLongitude);
				var leafBounds = new L.LatLngBounds(southWest, northEast);
				var destLatLong = new L.LatLng((bounds.maxLatitude + bounds.minLatitude) * 0.5, (bounds.maxLongitude + bounds.minLongitude) * 0.5);
				var newZoomLevel = this.$getBoundsZoom(map, leafBounds);
				var animate = this.$shouldAnimateZoom(map, newZoomLevel);
				this.$setView(destLatLong, newZoomLevel, animate).done(ss.mkdel(this, function() {
					if (!animate) {
						this.removeMarkOverlay();
					}
					result.resolve(animate);
				}));
			}));
			return result;
		},
		$getBoundsZoom: function LeafletMapControl$GetBoundsZoom(map, bounds) {
			var desiredZoomLevel = map.getBoundsZoom(bounds, true);
			return $tab_ZoomComputer.resolveDesiredZoom(this.$mapData.get_rasterMapSourceModel(), desiredZoomLevel);
		},
		$shouldAnimateZoom: function LeafletMapControl$ShouldAnimateZoom(map, newZoomLevel) {
			return Math.abs(map.getZoom() - newZoomLevel) <= 2;
		},
		panTo: function LeafletMapControl$PanTo(panXCenter, panYCenter) {
			var result = $.Deferred();
			if (!this.get_enabled()) {
				return result.resolve(false);
			}
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var currentCenter = map.latLngToContainerPoint(this.get_$centerFromModel());
				var newCenter = new L.Point(currentCenter.x - panXCenter, currentCenter.y - panYCenter);
				var destLatLong = map.containerPointToLatLng(newCenter);
				var $t1 = new Object();
				$t1.animate = false;
				var panOps = $t1;
				map.panTo(destLatLong, panOps);
				result.resolve(true);
			}));
			return result;
		},
		updateLocalCenter: function LeafletMapControl$UpdateLocalCenter(panXCenter, panYCenter) {
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var currentCenter = map.latLngToContainerPoint(this.get_$centerFromModel());
				var newCenter = new L.Point(currentCenter.x - panXCenter, currentCenter.y - panYCenter);
				var center = map.containerPointToLatLng(newCenter);
				var zoom = this.get_$zoomLevelFromModel();
				this.$localMapData = new $tab_$LeafletMapControl$LocalMapData(center, zoom);
			}));
		},
		updateLocalMapDataForZoomAround: function LeafletMapControl$UpdateLocalMapDataForZoomAround(anchor, zoom) {
			if (tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL')) {
				return;
			}
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				var scale = Math.pow(2, zoom - this.get_$zoomLevelFromModel());
				var viewHalf = map.getSize().divideBy(2);
				var latLngAnchor = map.containerPointToLatLng(new L.Point(anchor.x, anchor.y));
				var centerOffset = (new L.Point(latLngAnchor.lat, latLngAnchor.lng)).subtract(viewHalf).multiplyBy(1 - 1 / scale);
				var newCenter = map.containerPointToLatLng(viewHalf.add(centerOffset));
				this.$localMapData = new $tab_$LeafletMapControl$LocalMapData(newCenter, zoom);
			}));
		},
		touchMove: function LeafletMapControl$TouchMove(deltaX, deltaY, scale) {
			if (isNaN(scale) || isNaN(deltaY) || isNaN(deltaX)) {
				return;
			}
			if (tab.DoubleUtil.isApproximatelyEqual(scale, 1) && !this.$pinching) {
				this.panTo(deltaX, deltaY);
				return;
			}
			this.$deferredMap.done(ss.mkdel(this, function(map) {
				if (!this.$pinching) {
					var panes = map.getPanes();
					$(panes.mapPane).addClass($tab_LeafletMapControl.$leafletTouchingClass);
					$(panes.overlayPane).addClass($tab_LeafletMapControl.$leafletTouchingClass);
					this.$deltaAlreadyAccoundtedFor = new L.Point(deltaX, deltaY);
				}
				this.$pinching = true;
				tab.WindowHelper.cancelAnimationFrame(this.$touchAnimationFrame);
				this.$touchAnimationFrame = tab.WindowHelper.requestAnimationFrame(ss.mkdel(this, function() {
					var zoom = $tab_ZoomComputer.combineTileZoomAndStretch(this.get_$zoomLevelFromModel(), scale);
					this.$animateZoom(map, zoom, scale, deltaX, deltaY);
				}));
			}));
		},
		pinchScale: function LeafletMapControl$PinchScale(pinchX, pinchY, scale) {
		},
		touchEnd: function LeafletMapControl$TouchEnd(deltaX, deltaY, scale) {
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				this.$resumeTileFetchingFromMobilePinch(map);
				if (this.$pinching) {
					var desiredZoom = $tab_ZoomComputer.combineTileZoomAndStretch(this.get_$zoomLevelFromModel(), scale);
					var zoom = $tab_ZoomComputer.resolveDesiredZoom(this.$mapData.get_rasterMapSourceModel(), desiredZoom);
					scale = Math.pow(2, zoom - this.get_$zoomLevelFromModel());
					this.$animateZoom(map, zoom, scale, deltaX, deltaY);
				}
				this.$pinching = false;
			}));
		},
		splatOverlayToMapForTransition: function LeafletMapControl$SplatOverlayToMapForTransition(canvas) {
			if (ss.isNullOrUndefined(this.$deferredMap)) {
				return;
			}
			var mc = tabBootstrap.MetricsController.createContext('Leaflet Marks Splat', 32, null);
			this.$deferredMap.done(ss.mkdel(this, function(m) {
				if (ss.isValue(this.$marksOverlay)) {
					return;
				}
				var pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
				if (!tab.CanvasUtil.canvasDensified(canvas)) {
					pixelRatio = 1;
				}
				tab.Log.get(this).debug('Splat canvas pixel ratio: %d', [pixelRatio]);
				var borderSize = Math.floor(2 * pixelRatio);
				var copyArea = { x: borderSize, y: borderSize, w: canvas.width - 2 * borderSize, h: canvas.height - 2 * borderSize };
				var topPointY = Math.floor(m.latLngToContainerPoint($tab_LeafletMapControl.$latLngFromTuple($tab_LeafletMapControl.$northPole)).y * pixelRatio);
				var bottomPointY = Math.floor(m.latLngToContainerPoint($tab_LeafletMapControl.$latLngFromTuple($tab_LeafletMapControl.$southPole)).y * pixelRatio);
				if (bottomPointY < canvas.height) {
					copyArea.h = bottomPointY;
				}
				if (topPointY > 0) {
					copyArea.y += topPointY;
					copyArea.h -= topPointY;
				}
				var $t1 = new Object();
				$t1.pixelRatio = pixelRatio;
				var coo = $t1;
				this.$marksOverlay = new L.CanvasOverlay(m.getBounds(), coo);
				m.addLayer(this.$marksOverlay);
				var overlayCanvas = this.$marksOverlay.getCanvas();
				var overlayContext = tab.CanvasRenderer.getRenderContext(overlayCanvas, 'transparent');
				var pasteArea = { x: borderSize, y: borderSize, w: copyArea.w, h: copyArea.h };
				overlayContext.drawImage5(canvas, copyArea.x, copyArea.y, copyArea.w, copyArea.h, pasteArea.x, pasteArea.y, pasteArea.w, pasteArea.h);
				canvas.width = canvas.width;
				mc.dispose();
			}));
		},
		createMap: function LeafletMapControl$CreateMap(mapDiv, ms) {
			ss.Debug.assert(!this.get_enabled(), 'There should not already be a deferredMap if we are creating one');
			tab.ModuleManager.loadCss(tsConfig.external_static_asset_prefix + $tab_LeafletMapControl.$leafletCssFile);
			this.$mapData = ms;
			this.$localMapData = null;
			this.$template = new $tab_$LeafletMapTemplate();
			this.$template.domRoot.appendTo(mapDiv);
			if (ss.isValue(this.$mapSize)) {
				tab.DomUtil.setMarginBox(this.$template.get_$mapHolderElement(), { l: 0, t: 0, w: this.$mapSize.w, h: this.$mapSize.h });
			}
			ss.Debug.assert(ss.isNullOrUndefined(this.$deferredMap), 'Recreating the Leaflet map');
			var created = $.Deferred();
			var mapLoader = $.Deferred();
			this.$deferredMap = mapLoader;
			tab.ModuleManager.load$1(tab.ModulesRegistration.leafletLibFileName, []).done(ss.mkdel(this, function(o) {
				this.$continueSetup(mapLoader, created);
			}));
			return created;
		},
		$continueSetup: function LeafletMapControl$ContinueSetup(mapLoader, created) {
			if (!this.get_enabled()) {
				created.reject();
				return;
			}
			var createMapStartTimestamp = (new Date()).getTime();
			var visibilityLostDuringCreation = false;
			var loadMetricCtx = $tab_MapControlMetrics.createLoadMapContext($tab_MapControlType.leaflet, this.$mapData.get_sheetName());
			var onVisibilityChange = function() {
				if (document.hidden) {
					visibilityLostDuringCreation = true;
				}
			};
			document.addEventListener('visibilitychange', onVisibilityChange);
			var mapOps = this.$createMapOptions();
			var map = new L.Map(this.$template.get_$mapHolderElement(), mapOps);
			map.once('load', function(ev) {
				created.resolve();
			});
			map.setView(this.get_$centerFromModel(), this.get_$zoomLevelFromModel());
			var tlops = this.$createTileLayerOptions();
			this.$mapTileLayer = new L.TileLayer(this.$mapData.get_tileUrl(), tlops);
			this.$mapTileLayer.once('load', ss.mkdel(this, function(ev1) {
				if (!visibilityLostDuringCreation) {
					var elapsedTime = (new Date()).getTime() - createMapStartTimestamp;
					$tab_MapControlTelemetry.logMapCreateDone(this.$createTelemetryRecord(elapsedTime));
					loadMetricCtx.dispose();
				}
				document.removeEventListener('visibilitychange', onVisibilityChange);
			}));
			this.$updateMapVisibilityIfNoValidLayer();
			map.addLayer(this.$mapTileLayer);
			this.$mapData.add_newMapServerInfo(ss.mkdel(this, this.$handleNewMapData));
			if (this.$mapData.get_hasWashout() && this.$mapData.get_hasValidTileLayer()) {
				var washoutColorModel = this.$mapData.get_washoutColor();
				var washoutColorDataUrl = $tab_LeafletMapControl.$buildConstantColorDataUrl(washoutColorModel.toRgb());
				tlops.opacity = washoutColorModel.get_a();
				map.addLayer(new L.TileLayer(washoutColorDataUrl, tlops));
			}
			this.$template.$setBackground(this.$mapData);
			this.$adjustBarnDoors(this.get_$zoomLevelFromModel(), false);
			mapLoader.resolve(map);
		},
		$updateMapVisibilityIfNoValidLayer: function LeafletMapControl$UpdateMapVisibilityIfNoValidLayer() {
			var tileLayerOpacity = (this.$mapData.get_hasValidTileLayer() ? 1 : 0);
			this.$mapTileLayer.setOpacity(tileLayerOpacity);
		},
		destroyMap: function LeafletMapControl$DestroyMap() {
			var destroyed = $.Deferred();
			if (ss.isValue(this.$template)) {
				this.$template.dispose();
				this.$template = null;
			}
			var finishDestroy = ss.mkdel(this, function() {
				if (ss.isValue(this.$mapData)) {
					this.$mapData.remove_newMapServerInfo(ss.mkdel(this, this.$handleNewMapData));
					this.$mapData = null;
				}
				destroyed.resolve();
			});
			if (ss.isValue(this.$deferredMap)) {
				this.$deferredMap.done(function(map) {
					map.remove();
					finishDestroy();
				});
				this.$deferredMap = null;
			}
			else {
				finishDestroy();
			}
			return destroyed;
		},
		$handleNewMapData: function LeafletMapControl$HandleNewMapData() {
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				if (map._animatingZoom) {
					window.setTimeout(ss.mkdel(this, this.$handleNewMapData), $tab_LeafletMapControl.$spinWaitTimeForLeafletAnimation);
				}
				else {
					this.$updateMapVisibilityIfNoValidLayer();
					this.$localMapData = null;
					var centerLatLng = this.get_$centerFromModel();
					var localMapCenter = map.latLngToContainerPoint(map.getCenter());
					var serverMapCenter = map.latLngToContainerPoint(centerLatLng);
					var zoomDiff = Math.abs(map.getZoom() - this.get_$zoomLevelFromModel());
					tab.Log.get(this).debug('Map local-server diff: zoom %s, lat %s, long %s', [map.getZoom() - this.get_$zoomLevelFromModel(), map.getCenter().lat - centerLatLng.lat, map.getCenter().lng - centerLatLng.lng]);
					tab.Log.get(this).debug('Map local-server center diff: x %s, y %s', [localMapCenter.x - serverMapCenter.x, localMapCenter.y - serverMapCenter.y]);
					if (zoomDiff > 0.001) {
						tab.Log.get(this).debug('Local zoom %s, pmZoom %s', [map.getZoom(), this.get_$zoomLevelFromModel()]);
					}
					var smallZoomDifference = zoomDiff < $tab_LeafletMapControl.$zoomDiffTolerance && localMapCenter.distanceTo(serverMapCenter) < $tab_LeafletMapControl.$positionDiffTolerance;
					this.$setView(centerLatLng, this.get_$zoomLevelFromModel(), smallZoomDifference);
					this.$forceLeafletAnimationToEnd(map);
				}
			}));
		},
		$forceLeafletAnimationToEnd: function LeafletMapControl$ForceLeafletAnimationToEnd(map) {
			var tilePaneNodes = $(map.getPanes().tilePane).find('.leaflet-tile-container');
			for (var ii = 0; ii < tilePaneNodes.length; ++ii) {
				if (!tab.MiscUtil.isNullOrEmpty$3(tilePaneNodes[ii].style.visibility)) {
					map._onZoomTransitionEnd();
					break;
				}
			}
		},
		resize: function LeafletMapControl$Resize(width, height) {
			var newSize = { w: width, h: height };
			if (tab.SizeUtil.equals(newSize, this.$mapSize)) {
				return;
			}
			this.$mapSize = newSize;
			this.$loadModuleAndInvokeIfEnabled(ss.mkdel(this, function(map) {
				tab.DomUtil.setMarginBox(map.getContainer(), { l: 0, t: 0, w: newSize.w, h: newSize.h });
				map.invalidateSize(false);
				this.$adjustBarnDoors(this.get_$zoomLevelFromModel(), false);
				this.$template.$clearAnimationClasses();
			}));
		},
		setScrollX: function LeafletMapControl$SetScrollX(x) {
			this.$loadModuleAndInvokeIfEnabled(function(map) {
				map.getContainer().style.left = -x + 'px';
			});
		},
		setScrollY: function LeafletMapControl$SetScrollY(y) {
			this.$loadModuleAndInvokeIfEnabled(function(map) {
				map.getContainer().style.top = -y + 'px';
			});
		},
		removeMarkOverlay: function LeafletMapControl$RemoveMarkOverlay() {
			if (ss.isNullOrUndefined(this.$deferredMap)) {
				return;
			}
			this.$deferredMap.done(ss.mkdel(this, function(map) {
				if (ss.isNullOrUndefined(this.$marksOverlay)) {
					return;
				}
				map.removeLayer(this.$marksOverlay);
				this.$marksOverlay = null;
				this.$forceLeafletAnimationToEnd(map);
				this.$resumeTileFetchingFromMobilePinch(map);
			}));
		},
		dispose: function LeafletMapControl$Dispose() {
			this.destroyMap();
		},
		$createMapOptions: function LeafletMapControl$CreateMapOptions() {
			var $t1 = new Object();
			$t1.zoomControl = false;
			$t1.attributionControl = false;
			return $t1;
		},
		$createTileLayerOptions: function LeafletMapControl$CreateTileLayerOptions() {
			var toRet = new Object();
			toRet.maxZoom = 100;
			toRet.maxNativeZoom = this.$mapData.get_maxZoom();
			toRet.minZoom = this.$mapData.get_minZoom();
			toRet.continuousZoom = true;
			toRet.intermediateTileLevels = ss.isValue(this.$mapData.get_rasterMapSourceModel().get_intermediateTileLevels()) && this.$mapData.get_rasterMapSourceModel().get_intermediateTileLevels() > 1;
			var tileSize = this.$mapData.get_rasterMapSourceModel().get_mapTileSize();
			toRet.zoomOffset = tab.MapUtil.getLeafletZoomOffsetForTileSize(tileSize);
			toRet.tileSize = tileSize;
			return toRet;
		},
		$setZoomAround: function LeafletMapControl$SetZoomAround(anchor, zoom, animate) {
			var result = $.Deferred();
			var $t1 = new Object();
			$t1.animate = animate;
			var zo = $t1;
			if (zoom < 0) {
				return result.resolve(false);
			}
			this.$deferredMap.done(ss.mkdel(this, function(map) {
				if (map._animatingZoom) {
					this.$forceLeafletAnimationToEnd(map);
				}
				map.once('moveend', function(ev) {
					result.resolve(true);
				});
				map.setZoomAround(anchor, zoom, zo);
				this.$adjustBarnDoors(zoom, true);
			}));
			return result;
		},
		$setView: function LeafletMapControl$SetView(center, zoom, animate) {
			var result = $.Deferred();
			var $t1 = new Object();
			$t1.animate = animate;
			var zpo = $t1;
			if (zoom < 0) {
				return result.resolve(false);
			}
			this.$deferredMap.done(ss.mkdel(this, function(map) {
				if (map._animatingZoom) {
					this.$forceLeafletAnimationToEnd(map);
				}
				if (!tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL')) {
					this.$localMapData = new $tab_$LeafletMapControl$LocalMapData(center, zoom);
				}
				map.once('moveend', function(ev) {
					result.resolve(animate);
				});
				map.setView(center, zoom, zpo);
				this.$adjustBarnDoors(zoom, animate);
			}));
			return result;
		},
		$adjustBarnDoors: function LeafletMapControl$AdjustBarnDoors(zoom, animate) {
			var adjustedZoom = zoom + tab.MapUtil.getLeafletZoomOffsetForTileSize(this.$mapData.get_rasterMapSourceModel().get_mapTileSize());
			var coveredMapWidth = tab.MapUtil.getVisiblePixelWidth(adjustedZoom, this.$mapData.get_numWorldRepeats(), this.$mapData.get_rasterMapSourceModel().get_mapTileSize());
			var availableWidth = this.$template.get_$mapHolderWidth();
			var doorSize = Math.ceil((availableWidth - coveredMapWidth) / 2);
			doorSize = Math.max(doorSize, 0);
			this.$template.$adjustBarnDoors(doorSize, animate);
		},
		$animateZoom: function LeafletMapControl$AnimateZoom(map, zoom, scale, deltaX, deltaY) {
			var delta = new L.Point(deltaX, deltaY);
			delta = delta.subtract(this.$deltaAlreadyAccoundtedFor);
			var layerCenter = map.containerPointToLayerPoint(map.getSize().divideBy(2));
			var centerOffset = (new L.Point(0, 0)).subtract(delta).divideBy(scale);
			var origin = layerCenter.add(centerOffset);
			var center = map.layerPointToLatLng(origin);
			if (isNaN(center.lat) || isNaN(center.lng)) {
				return;
			}
			map._animateZoom(center, zoom, layerCenter, scale, delta);
			this.$adjustBarnDoors(zoom, false);
		},
		$resumeTileFetchingFromMobilePinch: function LeafletMapControl$ResumeTileFetchingFromMobilePinch(map) {
			$(map.getPanes().mapPane).removeClass($tab_LeafletMapControl.$leafletTouchingClass);
			$(map.getPanes().overlayPane).removeClass($tab_LeafletMapControl.$leafletTouchingClass);
			tab.WindowHelper.cancelAnimationFrame(this.$touchAnimationFrame);
		},
		$loadModuleAndInvokeIfEnabled: function LeafletMapControl$LoadModuleAndInvokeIfEnabled(action) {
			if (!this.get_enabled()) {
				return;
			}
			this.$deferredMap.done(action);
		},
		$createTelemetryRecord: function LeafletMapControl$CreateTelemetryRecord(elapsedTime) {
			var $t1 = {};
			$t1[$tab_$MapControlEventProperty.$mapControlType] = $tab_MapControlType.leaflet;
			$t1[$tab_$MapControlEventProperty.$zoomLevel] = this.$mapData.get_requestZoom();
			$t1[$tab_$MapControlEventProperty.$washOut] = this.$mapData.get_washoutColor().toString();
			$t1[$tab_$MapControlEventProperty.$numRepeatBackground] = this.$mapData.get_numWorldRepeats();
			$t1[$tab_$MapControlEventProperty.$renderMode] = $tab_MapRenderType.client;
			$t1[$tab_$MapControlEventProperty.$elapsedTime] = elapsedTime;
			$t1[$tab_$MapControlEventProperty.$hardwareConcurrency] = window.navigator.hardwareConcurrency;
			return $t1;
		}
	}, null, [ss.IDisposable, $tab_IMapControl]);
	ss.initClass($tab_LineAttribute, $asm, {
		get_allHighlighted: function LineAttribute$get_AllHighlighted() {
			return this.highlightedCount >= this.endIndex - this.startIndex + 1;
		},
		get_lineState: function LineAttribute$get_LineState() {
			if (this.selectedCount > 0) {
				return 'lineStateSelected';
			}
			else if (this.highlightedCount > 0) {
				return 'lineStateHighlighted';
			}
			else {
				return 'lineStateNormal';
			}
		}
	});
	ss.initClass($tab_LineMarkDrawState, $asm, {
		get_lineAttributes: function LineMarkDrawState$get_LineAttributes() {
			return this.$lineAttributes;
		},
		$reCompute: function LineMarkDrawState$ReCompute(paneDrawInfo) {
			ss.clear(this.$lineAttributes);
			var markCount = paneDrawInfo.markCount;
			var la = new $tab_LineAttribute(0);
			for (var i = 0; i < markCount; i++) {
				var bounds = paneDrawInfo.getMarkBounds(i);
				tab.RectXYUtil.unionInPlace(la.boundingBox, bounds);
				var state = paneDrawInfo.getMarkState(i);
				if (state === 'markStateSelected') {
					la.selectedCount++;
					if (paneDrawInfo.isMarkHighlighted(i)) {
						la.highlightedCount++;
					}
				}
				else if (state === 'markStateHighlighted') {
					la.highlightedCount++;
				}
				if (paneDrawInfo.markNeedsDraw(i)) {
					la.marksNeedingDraw.push(i);
				}
				if (paneDrawInfo.isMarkEndPrimitive(i)) {
					la.worldOffsets = paneDrawInfo.getWorldInstanceOffsets(la.boundingBox.x, la.boundingBox.x + la.boundingBox.w);
					la.endIndex = i;
					la.sloppyBoundingBox = tab.RectXYUtil.outsetRect(la.boundingBox, 4, 4);
					this.$lineAttributes.push(la);
					la = new $tab_LineAttribute(i + 1);
				}
			}
		}
	});
	ss.initClass($tab_VizHitTestDebouncer, $asm, {
		add_updated: function VizHitTestDebouncer$add_Updated(value) {
			this.$1$UpdatedField = ss.delegateCombine(this.$1$UpdatedField, value);
		},
		remove_updated: function VizHitTestDebouncer$remove_Updated(value) {
			this.$1$UpdatedField = ss.delegateRemove(this.$1$UpdatedField, value);
		},
		get_current: function VizHitTestDebouncer$get_Current() {
			return this.$currentHit;
		},
		get_hasHit: function VizHitTestDebouncer$get_HasHit() {
			return ss.isValue(this.$currentHit) && ss.isValue(this.$currentHit.get_result()) && this.$currentHit.get_result().get_hitObjectType() !== 0;
		},
		dispose: function VizHitTestDebouncer$Dispose() {
			this.paneTable = null;
			this.$debouncer.dispose();
			this.lastEvent = null;
			this.setCurrent(null);
		},
		isWithinLastHitTestDistance: function VizHitTestDebouncer$IsWithinLastHitTestDistance(normalizedEvent) {
			if (this.get_hasHit()) {
				var eventRegionCoordinates = this.region.toLocalCoordsEvent(normalizedEvent, false);
				return tab.PointUtil.isWithinDistance(this.$currentHit.get_regionCoordinates(), eventRegionCoordinates, 20);
			}
			return false;
		},
		getLastHitTestDistance: function VizHitTestDebouncer$GetLastHitTestDistance(normalizedEvent) {
			if (ss.isValue(this.$currentHit) && ss.isValue(this.$currentHit.get_result())) {
				var eventRegionCoordinates = this.region.toLocalCoordsEvent(normalizedEvent, false);
				return tab.PointUtil.distance(this.$currentHit.get_regionCoordinates(), eventRegionCoordinates);
			}
			return -1;
		},
		getAsync: function VizHitTestDebouncer$GetAsync(normalizedEvent) {
			tab.Log.get(this).debug('GetAsync: event = ' + normalizedEvent.gestureName, []);
			ss.Debug.assert(ss.isValue(this.paneTable.get_geometry()), 'Geometry not set');
			var deferred = $.Deferred();
			if (this.isWithinLastHitTestDistance(normalizedEvent)) {
				deferred.resolve(this.$currentHit);
			}
			else {
				var hitDelegate = null;
				hitDelegate = ss.mkdel(this, function(hit) {
					tab.Log.get(this).debug('HitTest: InLocal update delegate - resolving the deferred', []);
					this.remove_updated(hitDelegate);
					deferred.resolve(hit);
				});
				this.add_updated(hitDelegate);
				this.update(normalizedEvent);
			}
			return deferred.promise();
		},
		update: function VizHitTestDebouncer$Update(normalizedEvent) {
			tab.Log.get(this).debug('HitTest: event = ' + normalizedEvent.gestureName, []);
			this.lastEvent = normalizedEvent;
			this.$debouncer.invokeActionDelayed();
		},
		makePaneSpecId: function VizHitTestDebouncer$MakePaneSpecId(col, row) {
			ss.Debug.assert(row < this.paneTable.get_numRows() && col < this.paneTable.get_numColumns(), 'pane out of range!');
			return row * this.paneTable.get_numColumns() + col;
		},
		setCurrent: function VizHitTestDebouncer$SetCurrent(c) {
			this.$currentHit = c;
			if (ss.isValue(this.$1$UpdatedField)) {
				this.$1$UpdatedField(c);
			}
		},
		hitTest: null
	}, null, [ss.IDisposable, tab.IVizHitTestDebouncer]);
	ss.initClass($tab_LocalRenderVizHitTestDebouncer, $asm, {
		hitTest: function LocalRenderVizHitTestDebouncer$HitTest(regionCoordinates, pageCoordinates) {
			tab.Log.get(this).debug('LocalRenderVizHitTestDebouncer.HitTest', []);
			ss.Debug.assert(tab.ApplicationModel.get_instance().get_isLocalRenderMode(), 'cannot use in server rendering');
			var paneDrawInfo = this.$hitTester.getPaneDrawInfoFromSelectionAnchor(regionCoordinates);
			if (ss.isValue(paneDrawInfo)) {
				var hitResult = this.$hitTester.onTapHitTest(regionCoordinates);
				var paneSpecId = this.makePaneSpecId(paneDrawInfo.paneColumn, paneDrawInfo.paneRow);
				this.setCurrent(new $tab_VizHitInfo(this.region, paneSpecId, paneDrawInfo.paneColumn, paneDrawInfo.paneRow, regionCoordinates, pageCoordinates, hitResult));
			}
			else {
				this.setCurrent(null);
			}
		}
	}, $tab_VizHitTestDebouncer, [ss.IDisposable, tab.IVizHitTestDebouncer]);
	ss.initClass($tab_LocalRenderVizHitTester, $asm, {
		get_$hitTestChain: function LocalRenderVizHitTester$get_HitTestChain() {
			return this.$hitTestChain.value();
		},
		onTapHitTest: function LocalRenderVizHitTester$OnTapHitTest(p) {
			if (ss.isNullOrUndefined(this.get_$hitTestChain())) {
				return $tab_HitTestResult.createEmptyHitTestResult();
			}
			return this.get_$hitTestChain().onTapHitTest(p, true)[0];
		},
		onHoverHitTest: function LocalRenderVizHitTester$OnHoverHitTest(p) {
			if (ss.isNullOrUndefined(this.get_$hitTestChain())) {
				return $tab_HitTestResult.createEmptyHitTestResult();
			}
			return this.get_$hitTestChain().onHoverHitTest(p, true)[0];
		},
		clearCache: function LocalRenderVizHitTester$ClearCache() {
			this.get_$hitTestChain().clearCache();
		},
		getPaneDrawInfoFromSelectionAnchor: function LocalRenderVizHitTester$GetPaneDrawInfoFromSelectionAnchor(selectionAnchor) {
			var paneKeys = $tab_MarksHitTestLink.getPaneKeysByHitTesting(selectionAnchor, this.$sceneInfo);
			if (paneKeys.length === 0) {
				tab.Log.get(this).debug("HitTestPanes didn't return any panes. Selection anchor might be invalid: %s.", [selectionAnchor.toString()]);
				return null;
			}
			return this.$sceneInfo.getPaneDrawInfoFromKey(paneKeys[0]);
		},
		hitTestMarksAgainstSelectionShape: function LocalRenderVizHitTester$HitTestMarksAgainstSelectionShape(shapeSelector) {
			return $tab_MarksHitTestLink.hitTestMarks(null, false, null, this.$sceneInfo, shapeSelector);
		}
	});
	ss.initClass($tab_LocalRenderVizSelectionDispatcher, $asm, {});
	ss.initClass($tab_MapAttributionTemplate, $asm, {}, spiff.Template, [ss.IDisposable]);
	ss.initClass($tab_MapboxExpression, $asm, {});
	ss.initClass($tab_MapboxMapControl, $asm, {
		get_enabled: function MapboxMapControl$get_Enabled() {
			return ss.isValue(this.$deferredMap) && this.$mapData.get_useFastMaps();
		},
		get_$centerFromModel: function MapboxMapControl$get_CenterFromModel() {
			if (!tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL') && this.$mapData.get_allowLocalPanAndZoom() && ss.isValue(this.$localMapData)) {
				return this.$localMapData.get_$center();
			}
			else {
				return new mapboxgl.LngLat(this.$mapData.get_centerLongitude(), this.$mapData.get_centerLatitude());
			}
		},
		get_$zoomLevelFromModel: function MapboxMapControl$get_ZoomLevelFromModel() {
			if (!tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL') && this.$mapData.get_allowLocalPanAndZoom() && ss.isValue(this.$localMapData)) {
				return this.$localMapData.get_$zoomLevel();
			}
			else {
				return this.$mapData.get_zoom();
			}
		},
		get_testMap: function MapboxMapControl$get_TestMap() {
			if (this.$deferredMap.state() !== 'resolved') {
				return null;
			}
			var map = null;
			this.$deferredMap.done(function(_map) {
				map = _map;
			});
			return map;
		},
		zoomOnPoint: function MapboxMapControl$ZoomOnPoint(zoomCenter, zoomDir) {
			return this.$doMovementAction(ss.mkdel(this, function(map) {
				var zoomLevel = $tab_ZoomComputer.incrementZoom(this.get_$zoomLevelFromModel(), zoomDir);
				var destLngLat;
				if (ss.isNullOrUndefined(zoomCenter)) {
					destLngLat = map.getCenter();
				}
				else {
					destLngLat = map.unproject(new mapboxgl.Point(zoomCenter.x, zoomCenter.y));
				}
				this.$easeToCenter(map, destLngLat, zoomLevel, true);
			}));
		},
		anchorZoom: function MapboxMapControl$AnchorZoom(newZoomLevel, anchorPoint, animate) {
			return this.$doMovementAction(ss.mkdel(this, function(map) {
				var destLngLat = map.unproject(new mapboxgl.Point(anchorPoint.x, anchorPoint.y));
				this.$easeToAnchor(map, destLngLat, newZoomLevel, animate);
			}));
		},
		zoomRect: function MapboxMapControl$ZoomRect(rect) {
			return this.$doMovementAction(ss.mkdel(this, function(map) {
				var southWest = map.unproject(new mapboxgl.Point(rect.x, rect.y + rect.h));
				var northEast = map.unproject(new mapboxgl.Point(rect.x + rect.w, rect.y));
				var lngLatBounds = new mapboxgl.LngLatBounds(southWest, northEast);
				this.$fitBounds(map, lngLatBounds, true);
			}));
		},
		moveToBounds: function MapboxMapControl$MoveToBounds(bounds) {
			return this.$doMovementAction(ss.mkdel(this, function(map) {
				var southWest = new mapboxgl.LngLat(bounds.minLongitude, bounds.minLatitude);
				var northEast = new mapboxgl.LngLat(bounds.maxLongitude, bounds.maxLatitude);
				var lngLatBounds = new mapboxgl.LngLatBounds(southWest, northEast);
				this.$fitBounds(map, lngLatBounds, true);
			}));
		},
		panTo: function MapboxMapControl$PanTo(panXCenter, panYCenter) {
			return this.$doMovementAction(ss.mkdel(this, function(map) {
				var currentCenter = map.project(this.get_$centerFromModel());
				var newCenter = new mapboxgl.Point(currentCenter.x - panXCenter, currentCenter.y - panYCenter);
				var destLngLat = map.unproject(newCenter);
				var animationOptions = { animate: false };
				map.panTo(destLngLat, animationOptions);
			}));
		},
		$doMovementAction: function MapboxMapControl$DoMovementAction(movementAction) {
			var result = $.Deferred();
			if (!this.$interactable) {
				return result.resolve(false);
			}
			this.$invokeIfInteractable(ss.mkdel(this, function(map) {
				movementAction(map);
				this.$waitForAnimationEnd(map).done([function() {
					result.resolve(true);
				}]);
			}));
			return result;
		},
		updateLocalCenter: function MapboxMapControl$UpdateLocalCenter(panXCenter, panYCenter) {
			this.$localMapData = null;
			this.$invokeIfEnabled(ss.mkdel(this, function(map) {
				this.$waitForAnimationEnd(map).done([ss.mkdel(this, function() {
					var currentCenter = map.project(this.get_$centerFromModel());
					var newCenter = new mapboxgl.Point(currentCenter.x - panXCenter, currentCenter.y - panYCenter);
					var destLngLat = map.unproject(newCenter);
					var zoom = this.get_$zoomLevelFromModel();
					this.$localMapData = new $tab_$MapboxMapControl$LocalMapData(destLngLat, zoom);
				})]);
			}));
		},
		updateLocalMapDataForZoomAround: function MapboxMapControl$UpdateLocalMapDataForZoomAround(anchor, zoom) {
			this.$localMapData = null;
			this.$invokeIfEnabled(ss.mkdel(this, function(map) {
				this.$waitForAnimationEnd(map).done([ss.mkdel(this, function() {
					var center = map.getCenter();
					this.$localMapData = new $tab_$MapboxMapControl$LocalMapData(center, zoom);
				})]);
			}));
		},
		pinchScale: function MapboxMapControl$PinchScale(pinchX, pinchY, scale) {
			if (!tab.DoubleUtil.isApproximatelyEqual(scale, 1)) {
				this.$invokeIfInteractable(ss.mkdel(this, function(map) {
					var zoom = $tab_ZoomComputer.combineTileZoomAndStretch(this.get_$zoomLevelFromModel(), scale);
					var pinchCenterPoint = new mapboxgl.Point(pinchX, pinchY);
					var pinchCenter = map.unproject(pinchCenterPoint);
					this.$easeToAnchor(map, pinchCenter, zoom, false);
				}));
			}
		},
		touchMove: function MapboxMapControl$TouchMove(deltaX, deltaY, scale) {
			this.panTo(deltaX, deltaY);
		},
		touchEnd: function MapboxMapControl$TouchEnd(deltaX, deltaY, scale) {
		},
		splatOverlayToMapForTransition: function MapboxMapControl$SplatOverlayToMapForTransition(canvas) {
			this.$invokeIfInteractable(ss.mkdel(this, function(map) {
				var overlaySource = this.$getOverlaySource(map);
				if (ss.isNullOrUndefined(overlaySource)) {
					return;
				}
				var overlayCanvas = overlaySource.getCanvas();
				var clipRect = this.$calculateVisibleMapRect(map);
				var left = clipRect.x;
				var top = clipRect.y;
				var width = clipRect.w;
				var height = clipRect.h;
				var borderSize = 2;
				var copyArea = $tab_MapboxMapControl.$createAdjustedCanvasRect(canvas, left, top, width, height, borderSize);
				var pasteArea = $tab_MapboxMapControl.$createAdjustedCanvasRect(overlayCanvas, 0, 0, width, height, borderSize);
				var overlayContext = tab.CanvasRenderer.getRenderContext(overlayCanvas, 'transparent');
				overlayContext.drawImage5(canvas, copyArea.x, copyArea.y, copyArea.w, copyArea.h, pasteArea.x, pasteArea.y, pasteArea.w, pasteArea.h);
				canvas.width = canvas.width;
				overlaySource.play();
			}));
		},
		removeMarkOverlay: function MapboxMapControl$RemoveMarkOverlay() {
			this.$invokeIfInteractable(ss.mkdel(this, function(map) {
				var overlaySource = this.$getOverlaySource(map);
				if (ss.isNullOrUndefined(overlaySource)) {
					return;
				}
				this.$clipOverlayCanvas(map);
				map.once('render', function(ev) {
					overlaySource.pause();
				});
				overlaySource.play();
			}));
		},
		createMap: function MapboxMapControl$CreateMap(mapDiv, ms) {
			ss.Debug.assert(!this.get_enabled(), 'There should not already be a deferredMap if we are creating one');
			this.$mapData = ms;
			this.$attachModelUpdateHandlers();
			this.$localMapData = null;
			ss.Debug.assert(ss.isNullOrUndefined(this.$deferredMap), 'Recreating the Mapbox map');
			var created = $.Deferred();
			var mapLoader = $.Deferred();
			this.$deferredMap = mapLoader;
			created.fail([function() {
				mapLoader.reject();
			}]);
			var fetchRequest = this.$fetchStyleJson();
			tab.ModuleManager.load$1(tab.ModulesRegistration.mapboxGLLibFileName, []).done(ss.mkdel(this, function(o) {
				fetchRequest.done(ss.mkdel(this, function(styleJson) {
					this.$continueSetup(mapLoader, created, mapDiv, styleJson);
				})).fail(function() {
					created.reject();
				});
			}));
			return created;
		},
		$fetchStyleJson: function MapboxMapControl$FetchStyleJson() {
			var mapboxModel = this.$getMapboxMapSourceModel();
			if (ss.isNullOrUndefined(mapboxModel)) {
				return $.Deferred().reject();
			}
			var $t1 = {};
			$t1['access_token'] = mapboxModel.get_accessToken();
			var styleRequestParameters = $t1;
			return $.getJSON(mapboxModel.get_styleJsonUrl(), styleRequestParameters, null).fail(ss.mkdel(this, function(request, status, except) {
				this.$handleRequestFailure(request.status);
			}));
		},
		$continueSetup: function MapboxMapControl$ContinueSetup(mapLoader, created, mapDiv, styleJson) {
			if (!this.get_enabled()) {
				created.reject();
				return;
			}
			var mapboxSource = this.$getMapboxMapSourceModel();
			if (!mapboxSource.get_hasPresModel()) {
				created.reject();
				return;
			}
			var createMapStartTimestamp = (new Date()).getTime();
			var loadMetricCtx = $tab_MapControlMetrics.createLoadMapContext($tab_MapControlType.mapboxGLJS, this.$mapData.get_sheetName());
			var interactiveMetricCtx = $tab_MapControlMetrics.createInteractiveContext($tab_MapControlType.mapboxGLJS, this.$mapData.get_sheetName());
			var visibilityLostDuringCreation = false;
			var onVisibilityChange = function() {
				if (document.hidden) {
					visibilityLostDuringCreation = true;
				}
			};
			document.addEventListener('visibilitychange', onVisibilityChange);
			visibilityLostDuringCreation = visibilityLostDuringCreation || document.hidden;
			mapboxgl.accessToken = mapboxSource.get_accessToken();
			mapboxgl.config.API_URL = mapboxSource.get_baseUrl();
			var mapContainer = document.createElement('div');
			if (ss.isValue(this.$mapSize)) {
				tab.DomUtil.setMarginBox(mapContainer, { l: 0, t: 0, w: this.$mapSize.w, h: this.$mapSize.h });
			}
			mapDiv.append(mapContainer);
			if (ss.isNullOrUndefined(document.getElementById('hideMapboxLogoStyle'))) {
				mapDiv.append(this.$createStyleToHideMapboxLogo());
			}
			this.$simplifyStyle(styleJson, mapboxSource);
			this.$updateStyleLocale(styleJson.layers, mapboxSource);
			var mapOptions = this.$createMapOptions(mapContainer, mapboxSource, styleJson);
			var map = new mapboxgl.Map(mapOptions);
			map.once('load', ss.mkdel(this, function(loadEv) {
				if (!visibilityLostDuringCreation) {
					var elapsedTime = (new Date()).getTime() - createMapStartTimestamp;
					$tab_MapControlTelemetry.logMapCreateDone(this.$createTelemetryRecord(mapboxSource, elapsedTime));
					loadMetricCtx.dispose();
				}
				document.removeEventListener('visibilitychange', onVisibilityChange);
				this.$loaded = true;
				created.resolve();
			}));
			map.once('style.load', ss.mkdel(this, function(ev) {
				if (!visibilityLostDuringCreation) {
					interactiveMetricCtx.dispose();
				}
				this.$interactable = true;
			}));
			map.on('style.load', ss.mkdel(this, function(ev1) {
				this.$updateLayers(map);
				map.once('render', ss.mkdel(this, function(ev2) {
					this.$clipOverlayCanvas(map);
					this.$clipGLCanvas(map);
				}));
				map.moveLayer($tab_MapboxMapControl.overlayCanvasLayerId, $tab_MapboxMapControl.overlayCanvasLayerId);
			}));
			map.on('error', ss.mkdel(this, function(ev3) {
				if (ev3.error.name === 'AJAXError') {
					this.$handleRequestFailure(ev3.error.status);
				}
			}));
			map.on('zoom', ss.mkdel(this, function(ev4) {
				this.$clipGLCanvas(map);
			}));
			map.on('resize', ss.mkdel(this, function(ev5) {
				this.$clipGLCanvas(map);
				this.$clipOverlayCanvas(map);
			}));
			if (map && map.transform) {
				map.transform.latRange = null;
			}
			if (map && map.transform) {
				map.transform.maxValidLatitude = Infinity;
			}
			map.jumpTo({ center: this.get_$centerFromModel(), zoom: this.get_$zoomLevelFromModel() });
			mapLoader.resolve(map);
		},
		$handleRequestFailure: function MapboxMapControl$HandleRequestFailure(status) {
			if (ss.isNullOrUndefined(this.$mapData)) {
				return;
			}
			if (status === 401 || status === 404) {
				var $t1 = new tab.ReportMapboxParamsFailureCmd();
				$t1.cmdParams['visualIdPresModel'] = tab.ModelUtils.getVisualId(this.$mapData.get_sheetName());
				$t1.invoke();
			}
		},
		$createStyleToHideMapboxLogo: function MapboxMapControl$CreateStyleToHideMapboxLogo() {
			var mapboxLogoDisplayStyle = document.createElement('style');
			mapboxLogoDisplayStyle.setAttribute('id', 'hideMapboxLogoStyle');
			mapboxLogoDisplayStyle.innerHTML = 'a.mapboxgl-ctrl-logo {display: none}';
			return mapboxLogoDisplayStyle;
		},
		$attachModelUpdateHandlers: function MapboxMapControl$AttachModelUpdateHandlers() {
			if (ss.isNullOrUndefined(this.$mapData)) {
				return;
			}
			this.$mapData.add_newMapServerInfo(ss.mkdel(this, this.$handleNewMapData));
			var mapboxSource = this.$mapData.get_mapboxMapSourceModel();
			if (ss.isNullOrUndefined(mapboxSource)) {
				return;
			}
			mapboxSource.add_styleRefreshRequired(ss.mkdel(this, this.$handleStyleRefreshRequired));
		},
		$detachModelUpdateHandlers: function MapboxMapControl$DetachModelUpdateHandlers() {
			if (ss.isNullOrUndefined(this.$mapData)) {
				return;
			}
			this.$mapData.remove_newMapServerInfo(ss.mkdel(this, this.$handleNewMapData));
			var mapboxSource = this.$mapData.get_mapboxMapSourceModel();
			if (ss.isNullOrUndefined(mapboxSource)) {
				return;
			}
			mapboxSource.remove_styleRefreshRequired(ss.mkdel(this, this.$handleStyleRefreshRequired));
		},
		$createMapOptions: function MapboxMapControl$CreateMapOptions(container, mapboxModel, styleJson) {
			var options = { container: container, attributionControl: false, interactive: false, trackResize: false, minZoom: this.$mapData.get_minZoom(), maxZoom: this.$mapData.get_maxZoom(), localIdeographFontFamily: $tab_MapboxMapControl.$localCJKFontFamily };
			options.style = styleJson;
			var baseUrl = mapboxModel.get_baseUrl();
			var accessToken = mapboxModel.get_accessToken();
			options.transformRequest = function(url, requestType) {
				return $tab_MapboxMapControl.$updateURL(url, baseUrl, accessToken);
			};
			return options;
		},
		destroyMap: function MapboxMapControl$DestroyMap() {
			var destroyed = $.Deferred();
			this.$interactable = false;
			this.$loaded = false;
			var finishDestroy = ss.mkdel(this, function() {
				if (ss.isValue(this.$mapData)) {
					this.$detachModelUpdateHandlers();
					this.$mapData = null;
				}
				destroyed.resolve();
			});
			if (ss.isValue(this.$deferredMap)) {
				this.$deferredMap.done(function(map) {
					var mapContainer = map.getContainer();
					mapContainer.parentNode.removeChild(mapContainer);
					map.remove();
					finishDestroy();
				}).fail(finishDestroy);
				this.$deferredMap = null;
			}
			else {
				finishDestroy();
			}
			return destroyed;
		},
		$handleNewMapData: function MapboxMapControl$HandleNewMapData() {
			this.$invokeIfEnabled(ss.mkdel(this, function(map) {
				this.$waitForAnimationEnd(map).done([ss.mkdel(this, function() {
					this.$localMapData = null;
					var centerLngLat = this.get_$centerFromModel();
					map.stop();
					this.$easeToCenter(map, centerLngLat, this.get_$zoomLevelFromModel(), false);
				})]);
			}));
		},
		$handleStyleRefreshRequired: function MapboxMapControl$HandleStyleRefreshRequired() {
			this.$invokeIfEnabled(ss.mkdel(this, function(map) {
				this.$fetchStyleJson().done(ss.mkdel(this, function(styleJson) {
					var mapboxModel = this.$getMapboxMapSourceModel();
					if (ss.isNullOrUndefined(mapboxModel)) {
						return;
					}
					this.$simplifyStyle(styleJson, mapboxModel);
					this.$updateStyleLocale(styleJson.layers, mapboxModel);
					map.setStyle(styleJson, { diff: false, localIdeographFontFamily: $tab_MapboxMapControl.$localCJKFontFamily });
				}));
			}));
		},
		resize: function MapboxMapControl$Resize(width, height) {
			var newSize = { w: width, h: height };
			if (tab.SizeUtil.equals(newSize, this.$mapSize)) {
				return;
			}
			this.$mapSize = newSize;
			this.$invokeIfEnabled(function(map) {
				tab.DomUtil.setMarginBox(map.getContainer(), { l: 0, t: 0, w: newSize.w, h: newSize.h });
				map.resize();
			});
		},
		setScrollX: function MapboxMapControl$SetScrollX(x) {
			this.$invokeIfEnabled(function(map) {
				map.getContainer().style.left = -x + 'px';
			});
		},
		setScrollY: function MapboxMapControl$SetScrollY(y) {
			this.$invokeIfEnabled(function(map) {
				map.getContainer().style.top = -y + 'px';
			});
		},
		dispose: function MapboxMapControl$Dispose() {
			this.destroyMap();
		},
		$invokeIfEnabled: function MapboxMapControl$InvokeIfEnabled(action) {
			if (!this.get_enabled()) {
				return;
			}
			this.$deferredMap.done(action);
		},
		$invokeIfInteractable: function MapboxMapControl$InvokeIfInteractable(action) {
			if (!this.get_enabled() || !this.$interactable) {
				return;
			}
			this.$deferredMap.done(action);
		},
		$invokeIfLoaded: function MapboxMapControl$InvokeIfLoaded(action) {
			if (!this.get_enabled() || !this.$loaded) {
				return;
			}
			this.$deferredMap.done(action);
		},
		$waitForAnimationEnd: function MapboxMapControl$WaitForAnimationEnd(map) {
			var done = $.Deferred();
			if (map.isMoving()) {
				map.once('moveend', function(ev) {
					done.resolve();
				});
			}
			else {
				done.resolve();
			}
			return done;
		},
		$easeToAnchor: function MapboxMapControl$EaseToAnchor(map, anchorAround, zoom, animate) {
			this.$easeTo(map, null, anchorAround, zoom, animate);
		},
		$easeToCenter: function MapboxMapControl$EaseToCenter(map, center, zoom, animate) {
			this.$easeTo(map, center, null, zoom, animate);
		},
		$easeTo: function MapboxMapControl$EaseTo(map, center, anchorAround, zoom, animate) {
			if (zoom < 0) {
				return;
			}
			if (!tab.FeatureFlags.isEnabled('RuntimeComputeMapCenterInVTL') && ss.isValue(center)) {
				this.$localMapData = new $tab_$MapboxMapControl$LocalMapData(center, zoom);
			}
			var easeToOptions = { center: center, around: anchorAround, zoom: zoom, animate: animate, duration: 250 };
			map.easeTo(easeToOptions);
		},
		$fitBounds: function MapboxMapControl$FitBounds(map, bounds, animate) {
			var fitBoundsOptions = { linear: true, animate: animate, duration: 250 };
			map.fitBounds(bounds, fitBoundsOptions);
		},
		$updateLayerWorldview: function MapboxMapControl$UpdateLayerWorldview(layer, filterKeyword, mapCode) {
			var filter = ss.safeCast($tab_MapboxExpression.replaceString(layer.filter, filterKeyword, mapCode), Array);
			if (ss.isNullOrUndefined(filter)) {
				return;
			}
			layer.filter = filter;
		},
		$updateLayerLanguage: function MapboxMapControl$UpdateLayerLanguage(layer, languageKeyword, language) {
			var layout = layer.layout;
			if (ss.isNullOrUndefined(layout)) {
				return;
			}
			var textField = layout['text-field'];
			if (ss.isNullOrUndefined(textField)) {
				return;
			}
			var languageAdjustedProperty = $tab_MapboxExpression.replaceString(layout['text-field'], languageKeyword, language);
			if (ss.isNullOrUndefined(languageAdjustedProperty)) {
				return;
			}
			layout['text-field'] = languageAdjustedProperty;
		},
		$updateOverlayCanvasLayer: function MapboxMapControl$UpdateOverlayCanvasLayer(map) {
			if (ss.isNullOrUndefined(map.getSource($tab_MapboxMapControl.overlayCanvasSourceId))) {
				var $t1 = document.createElement('canvas');
				var overlayCanvas = ss.cast($t1, ss.isValue($t1) && (ss.isInstanceOfType($t1, Element) && $t1.tagName === 'CANVAS'));
				overlayCanvas.width = map.getCanvas().width;
				overlayCanvas.height = map.getCanvas().height;
				map.addSource($tab_MapboxMapControl.overlayCanvasSourceId, { type: 'canvas', animate: false, canvas: overlayCanvas, coordinates: [[0, 1], [1, 1], [1, 0], [0, 0]] });
			}
			if (ss.isNullOrUndefined(map.getLayer($tab_MapboxMapControl.overlayCanvasLayerId))) {
				map.addLayer({ id: $tab_MapboxMapControl.overlayCanvasLayerId, source: $tab_MapboxMapControl.overlayCanvasSourceId, type: 'raster', paint: { 'raster-fade-duration': 0 } });
			}
		},
		$updateWashoutLayer: function MapboxMapControl$UpdateWashoutLayer(map) {
			var addWashout = this.$mapData.get_hasWashout() && this.$mapData.get_hasValidTileLayer() && this.$mapData.get_washoutColor().get_a() > 0 && ss.isNullOrUndefined(map.getLayer($tab_MapboxMapControl.washoutLayerId));
			if (!addWashout) {
				return;
			}
			var maxWashoutOpacity = 0.999999;
			var washoutLayer = { id: $tab_MapboxMapControl.washoutLayerId, type: 'background', paint: { 'background-color': '#ffffff', 'background-opacity': Math.min(maxWashoutOpacity, this.$mapData.get_washoutColor().get_a()) } };
			map.addLayer(washoutLayer);
		},
		$updateDataLayer: function MapboxMapControl$UpdateDataLayer(map, mapboxSource) {
			var dataRequestUrl = mapboxSource.get_dataRequestUrl();
			var dataColorRamp = mapboxSource.get_dataColorRamp();
			if (ss.isNullOrEmptyString(dataRequestUrl) || ss.isNullOrEmptyString(dataColorRamp)) {
				return;
			}
			if (ss.isNullOrUndefined(map.getSource($tab_MapboxMapControl.dataSourceId))) {
				map.addSource($tab_MapboxMapControl.dataSourceId, { type: 'vector', url: dataRequestUrl });
			}
			if (ss.isNullOrUndefined(map.getLayer($tab_MapboxMapControl.dataLayerId))) {
				var dataInsertAbove = mapboxSource.get_dataInsertAbove();
				var dataSourceLayer = mapboxSource.get_dataSourceLayer();
				var dataOpacity = mapboxSource.get_dataOpacity();
				var dataLayer = { type: 'fill', id: $tab_MapboxMapControl.dataLayerId, source: $tab_MapboxMapControl.dataSourceId, 'source-layer': dataSourceLayer };
				var beforeLayerIndex = 1;
				var allLayers = map.getStyle().layers;
				for (var i = 0; i < allLayers.length; ++i) {
					if (ss.referenceEquals(allLayers[i].id, dataInsertAbove)) {
						beforeLayerIndex = i + 1;
						break;
					}
				}
				if (beforeLayerIndex < allLayers.length) {
					map.addLayer(dataLayer, allLayers[beforeLayerIndex].id);
				}
				else {
					map.addLayer(dataLayer);
				}
				map.setPaintProperty($tab_MapboxMapControl.dataLayerId, 'fill-opacity', JSON.parse(dataOpacity));
				map.setPaintProperty($tab_MapboxMapControl.dataLayerId, 'fill-color', JSON.parse(dataColorRamp));
			}
		},
		$updateLayersVisibility: function MapboxMapControl$UpdateLayersVisibility(map, layers, mapboxSource) {
			var enabledLayerIds = mapboxSource.get_enabledMapLayerIds();
			enabledLayerIds.add($tab_MapboxMapControl.dataLayerId);
			enabledLayerIds.add($tab_MapboxMapControl.washoutLayerId);
			enabledLayerIds.add($tab_MapboxMapControl.overlayCanvasLayerId);
			for (var $t1 = 0; $t1 < layers.length; $t1++) {
				var layer = layers[$t1];
				var isEnabled = enabledLayerIds.has(layer.id);
				map.setLayoutProperty(layer.id, 'visibility', (isEnabled ? 'visible' : 'none'));
			}
		},
		$updateStyleLocale: function MapboxMapControl$UpdateStyleLocale(layers, mapboxSource) {
			var mapCodeFilterKeyword = mapboxSource.get_mapCodeFilterKeyword();
			var mapCode = mapboxSource.get_mapCode();
			var languageCodePropertyKeyword = mapboxSource.get_languageCodePropertyKeyword();
			var languageCode = mapboxSource.get_languageCode();
			for (var $t1 = 0; $t1 < layers.length; $t1++) {
				var layer = layers[$t1];
				this.$updateLayerWorldview(layer, mapCodeFilterKeyword, mapCode);
				this.$updateLayerLanguage(layer, languageCodePropertyKeyword, languageCode);
			}
		},
		$updateLayers: function MapboxMapControl$UpdateLayers(map) {
			if (ss.isNullOrUndefined(this.$mapData)) {
				return;
			}
			var mapboxSource = this.$mapData.get_mapboxMapSourceModel();
			if (!mapboxSource.get_hasPresModel()) {
				return;
			}
			this.$updateDataLayer(map, mapboxSource);
			this.$updateWashoutLayer(map);
			this.$updateOverlayCanvasLayer(map);
			var layers = map.getStyle().layers;
			this.$updateLayersVisibility(map, layers, mapboxSource);
		},
		$simplifyStyle: function MapboxMapControl$SimplifyStyle(styleJson, mapboxSource) {
			if (!tab.FeatureFlags.isEnabled('MapboxVectorSimplifyStyleOnWeb')) {
				return;
			}
			var enabledLayerIds = mapboxSource.get_enabledMapLayerIds();
			styleJson.layers = styleJson.layers.filter(function(layer) {
				return enabledLayerIds.has(layer.id) || ss.referenceEquals(layer.id, mapboxSource.get_dataInsertAbove());
			});
			var sourceNames = new Set();
			for (var $t1 = 0; $t1 < styleJson.layers.length; $t1++) {
				var layer1 = styleJson.layers[$t1];
				if (ss.isValue(layer1.source)) {
					sourceNames.add(layer1.source);
				}
			}
			var prunedSources = {};
			var $t2 = new ss.ObjectEnumerator(styleJson.sources);
			try {
				while ($t2.moveNext()) {
					var source = $t2.current();
					if (sourceNames.has(source.key)) {
						prunedSources[source.key] = source.value;
					}
				}
			}
			finally {
				$t2.dispose();
			}
			styleJson.sources = prunedSources;
		},
		$getOverlaySource: function MapboxMapControl$GetOverlaySource(map) {
			return map.getSource($tab_MapboxMapControl.overlayCanvasSourceId);
		},
		$getGLContext: function MapboxMapControl$GetGLContext(map) {
			var canvas = map.getCanvas();
			var ctx = ss.safeCast(canvas.getContext('webgl'), WebGLRenderingContext);
			if (ss.isNullOrUndefined(ctx)) {
				ctx = ss.safeCast(canvas.getContext('experimental-webgl'), WebGLRenderingContext);
			}
			var ext = ss.safeCast(ctx.getExtension('WEBGL_debug_renderer_info'), Object);
			if (ss.isValue(ext)) {
				this.$renderer = ss.safeCast(ctx.getParameter(ext.UNMASKED_RENDERER_WEBGL), String);
			}
			return ctx;
		},
		$getMapboxMapSourceModel: function MapboxMapControl$GetMapboxMapSourceModel() {
			if (ss.isNullOrUndefined(this.$mapData)) {
				return null;
			}
			var model = this.$mapData.get_mapboxMapSourceModel();
			if (!model.get_hasPresModel()) {
				return null;
			}
			return model;
		},
		$clipOverlayCanvas: function MapboxMapControl$ClipOverlayCanvas(map) {
			var source = this.$getOverlaySource(map);
			if (ss.isNullOrUndefined(source)) {
				return;
			}
			var canvas = source.getCanvas();
			var clipRect = this.$calculateVisibleMapRect(map);
			var pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
			var width = clipRect.w;
			var height = clipRect.h;
			if (tab.CanvasUtil.isOverCanvasSizeLimit(width, height, pixelRatio)) {
				pixelRatio = 1;
			}
			tab.CanvasUtil.setCanvasSizeAndDensify(canvas, pixelRatio, { w: width, h: height });
			if (clipRect.h === 0) {
				return;
			}
			var left = clipRect.x;
			var right = clipRect.x + clipRect.w;
			var top = clipRect.y;
			var bottom = clipRect.y + clipRect.h;
			var coords = [map.unproject([left, top]).toArray(), map.unproject([right, top]).toArray(), map.unproject([right, bottom]).toArray(), map.unproject([left, bottom]).toArray()];
			source.setCoordinates(coords);
		},
		$clipGLCanvas: function MapboxMapControl$ClipGLCanvas(map) {
			var gl = this.$getGLContext(map);
			if (ss.isNullOrUndefined(gl)) {
				return;
			}
			var clipRect = this.$calculateVisibleMapRect(map);
			var pixelRatio = window.devicePixelRatio;
			gl.enable(WebGLRenderingContext.SCISSOR_TEST);
			gl.scissor(ss.Int32.trunc(clipRect.x * pixelRatio), ss.Int32.trunc(0 * pixelRatio), ss.Int32.trunc(clipRect.w * pixelRatio), ss.Int32.trunc(map.getContainer().offsetHeight * pixelRatio));
		},
		$getWorldWidthInPixels: function MapboxMapControl$GetWorldWidthInPixels(map) {
			return ss.Int32.trunc(map.project($tab_MapboxMapControl.$southEastBound).x - map.project($tab_MapboxMapControl.$northWestBound).x);
		},
		$calculateVisibleMapRect: function MapboxMapControl$CalculateVisibleMapRect(map) {
			var worldWidthPx = this.$getWorldWidthInPixels(map) * this.$mapData.get_numWorldRepeats();
			var worldTopPx = ss.Int32.trunc(map.project($tab_MapboxMapControl.$northWestBound).y);
			var worldBottomPx = ss.Int32.trunc(map.project($tab_MapboxMapControl.$southEastBound).y);
			var center = map.project(map.getCenter());
			var left = Math.max(ss.Int32.trunc(center.x) - ss.Int32.div(worldWidthPx, 2), 0);
			var right = Math.min(ss.Int32.trunc(center.x) + ss.Int32.div(worldWidthPx, 2), map.getContainer().offsetWidth);
			var top = Math.min(Math.max(worldTopPx, 0), map.getContainer().offsetHeight);
			var bottom = Math.min(Math.max(worldBottomPx, 0), map.getContainer().offsetHeight);
			return { x: left, y: top, w: right - left, h: bottom - top };
		},
		$createTelemetryRecord: function MapboxMapControl$CreateTelemetryRecord(mapboxSource, elapsedTime) {
			var $t1 = {};
			$t1[$tab_$MapControlEventProperty.$mapControlType] = $tab_MapControlType.mapboxGLJS;
			$t1[$tab_$MapControlEventProperty.$mapStyle] = mapboxSource.get_styleJsonUrl();
			$t1[$tab_$MapControlEventProperty.$mapCode] = mapboxSource.get_mapCode();
			$t1[$tab_$MapControlEventProperty.$zoomLevel] = this.$mapData.get_requestZoom();
			$t1[$tab_$MapControlEventProperty.$washOut] = this.$mapData.get_washoutColor().toString();
			$t1[$tab_$MapControlEventProperty.$numRepeatBackground] = this.$mapData.get_numWorldRepeats();
			$t1[$tab_$MapControlEventProperty.$renderMode] = $tab_MapRenderType.client;
			$t1[$tab_$MapControlEventProperty.$allowLocalPanAndZoom] = this.$mapData.get_allowLocalPanAndZoom();
			$t1[$tab_$MapControlEventProperty.$elapsedTime] = elapsedTime;
			$t1[$tab_$MapControlEventProperty.$hardwareConcurrency] = window.navigator.hardwareConcurrency;
			$t1[$tab_$MapControlEventProperty.$renderer] = this.$renderer;
			return $t1;
		}
	}, null, [ss.IDisposable, $tab_IMapControl]);
	ss.initClass($tab_MapControlMetrics, $asm, {});
	ss.initClass($tab_MapControlTelemetry, $asm, {});
	ss.initClass($tab_MapControlType, $asm, {});
	ss.initClass($tab_MapRenderType, $asm, {});
	ss.initClass($tab_MapsSearchComponent, $asm, {
		handleWidgetPropertyChanged: function MapsSearchComponent$HandleWidgetPropertyChanged(sender, propertyChangedEventArgs) {
		},
		updateWidgetState: function MapsSearchComponent$UpdateWidgetState(newProps) {
		}
	}, ss.makeGenericType(spiff.ReactSpiffAdapter$3, [$tab_MapsSearchView, Object, Object]));
	ss.initClass($tab_MapsSearchView, $asm, {
		get_compositeSearchWidget: function MapsSearchView$get_CompositeSearchWidget() {
			return this.$compositeSearchWidget;
		},
		get_isCollapsed: function MapsSearchView$get_IsCollapsed() {
			return this.$isCollapsed;
		},
		set_isCollapsed: function MapsSearchView$set_IsCollapsed(value) {
			this.$isCollapsed = value;
			this.mapsSearchView.toggleClass($tab_MapsSearchView.$widgetClassNameCollapsed, this.$isCollapsed);
			this.mapsSearchView.parent().toggleClass($tab_MapsSearchView.$widgetContainerClassNameCollapsed, this.$isCollapsed);
		},
		get_isVisible: function MapsSearchView$get_IsVisible() {
			return this.$isVisible;
		},
		set_isVisible: function MapsSearchView$set_IsVisible(value) {
			if (tab.FeatureParamsLookup.getBool(28) === true) {
				value = true;
			}
			if (this.$isVisible === value) {
				return;
			}
			this.$isVisible = value;
			this.mapsSearchViewTemplate.get_template().domRoot.css('display', (this.$isVisible ? '' : 'none'));
		},
		$onInputElementFocusIn: function MapsSearchView$OnInputElementFocusIn(e) {
			this.mapsSearchView.removeClass($tab_MapsSearchView.widgetClassNameTranslucent);
		},
		$onInputElementFocusOut: function MapsSearchView$OnInputElementFocusOut(e) {
			this.mapsSearchView.addClass($tab_MapsSearchView.widgetClassNameTranslucent);
		},
		$handleInputTextChange: function MapsSearchView$HandleInputTextChange(value) {
			this.$removeQueryDelayTimer();
			if (value.trim().length === 0) {
				this.handleRemoveSuggestionList();
			}
			else {
				this.$updateAllSuggestionsListItems();
				this.$setQueryDelayTimer();
			}
		},
		showNewSuggestions: function MapsSearchView$ShowNewSuggestions(searchTerm, suggestionsList) {
			if (!ss.referenceEquals(searchTerm, this.$compositeSearchWidget.get_textInputView().get_text()) || ss.isNullOrUndefined(suggestionsList)) {
				return;
			}
			this.$suggestionsListItemViewModels = tab.MiscUtil.dispose(this.$suggestionsListItemViewModels);
			this.$suggestionsListItemViewModels = [];
			for (var itemId = 0; itemId < suggestionsList.length; itemId++) {
				var suggestion = suggestionsList[itemId];
				this.$suggestionsListItemViewModels.push(spiff.ListItemViewModel.newListItem(itemId.toString(), suggestion, false, false, false));
			}
			this.get_compositeSearchWidget().showList(this.$suggestionsListItemViewModels, this, this.mapsSearchView);
		},
		$updateAllSuggestionsListItems: function MapsSearchView$UpdateAllSuggestionsListItems() {
			if (ss.isNullOrUndefined(this.$suggestionsListItemViewModels)) {
				return;
			}
			this.get_compositeSearchWidget().showList(this.$suggestionsListItemViewModels, this, this.mapsSearchView);
		},
		$getFormattedSuggestionListItemLabel: function MapsSearchView$GetFormattedSuggestionListItemLabel(suggestion) {
			var listItemLabel = $("<span class='tab-list-item-label'/>");
			var BaseHtml = '<span/>';
			var listItemLabelDisplayName = $(BaseHtml);
			var listItemLabelParentName = $(BaseHtml);
			listItemLabelDisplayName.addClass($tab_MapsSearchView.suggestionDisplayClassName);
			var displayName = suggestion.geographicSearchCandidateDisplayName;
			var searchText = ss.trimEndString(this.$compositeSearchWidget.get_textInputView().get_text());
			if (ss.startsWithString(displayName.toLowerCase(), searchText.toLowerCase())) {
				var listItemLabelActiveSearchText = $(BaseHtml);
				listItemLabelActiveSearchText.addClass($tab_MapsSearchView.suggestionActiveSearchTextClassName);
				listItemLabelActiveSearchText.text(displayName.substr(0, searchText.length));
				listItemLabelDisplayName.append(listItemLabelActiveSearchText);
				var listItemLabelPlainText = $(BaseHtml);
				listItemLabelPlainText.text(displayName.substr(searchText.length));
				listItemLabelDisplayName.append(listItemLabelPlainText);
			}
			else {
				listItemLabelDisplayName.text(suggestion.geographicSearchCandidateDisplayName);
			}
			listItemLabel.append(listItemLabelDisplayName);
			listItemLabelParentName.addClass($tab_MapsSearchView.suggestionParentClassName);
			listItemLabelParentName.text(suggestion.geographicSearchCandidateParentName);
			listItemLabel.append(listItemLabelParentName);
			return listItemLabel;
		},
		handleEnterKeyPress: function MapsSearchView$HandleEnterKeyPress() {
			this.$removeQueryDelayTimer();
			if (ss.isValue(this.get_compositeSearchWidget().get_listViewModel())) {
				this.mapsSearchViewModel.moveMapToCandidateBounds(this.get_compositeSearchWidget().get_listViewModel().get_collection()[0].get_data());
				this.handleRemoveSuggestionList();
			}
			else {
				this.mapsSearchViewModel.commitToSearchString(this.get_compositeSearchWidget().get_textInputView().get_text());
			}
		},
		handleListItemClick: function MapsSearchView$HandleListItemClick(listItem) {
			this.$removeQueryDelayTimer();
			this.handleRemoveSuggestionList();
			this.mapsSearchViewModel.moveMapToSuggestionListItem(listItem);
		},
		handleCollapseSearchWidget: function MapsSearchView$HandleCollapseSearchWidget() {
			this.set_isCollapsed(true);
		},
		$handleSetVisible: function MapsSearchView$HandleSetVisible(shouldBeVisible) {
			this.set_isVisible(shouldBeVisible);
		},
		$handleRestoreInitialTextInputValue: function MapsSearchView$HandleRestoreInitialTextInputValue() {
			this.get_compositeSearchWidget().get_textInputView().set_text('');
		},
		handleRemoveSuggestionList: function MapsSearchView$HandleRemoveSuggestionList() {
			this.$compositeSearchWidget.removeList();
			this.$suggestionsListItemViewModels = tab.MiscUtil.dispose(this.$suggestionsListItemViewModels);
		},
		$handleBlurInputElement: function MapsSearchView$HandleBlurInputElement() {
			this.get_compositeSearchWidget().get_textInputView().get_inputElement().blur();
		},
		setGeoLocationButtonVisibility: function MapsSearchView$SetGeoLocationButtonVisibility(shouldShowButton) {
			if (shouldShowButton) {
				this.gotoMyLocationButton.element.css('display', 'inline-block');
			}
			else {
				this.gotoMyLocationButton.element.css('display', 'none');
			}
		},
		handleSearchButtonClick: function MapsSearchView$HandleSearchButtonClick() {
			this.$removeQueryDelayTimer();
			this.set_isCollapsed(!this.$isCollapsed);
			if (!this.$isCollapsed) {
				if (!BrowserSupport.BrowserSupport.IsIE()) {
					this.$compositeSearchWidget.get_textInputView().get_inputElement().focus();
				}
				if (this.get_compositeSearchWidget().get_textInputView().get_text().length > 0) {
					this.selectAllSearchText();
				}
			}
		},
		$setQueryDelayTimer: function MapsSearchView$SetQueryDelayTimer() {
			this.queryDelayTimer = window.setTimeout(ss.mkdel(this, this.$queryDelayTimerCallback), $tab_MapsSearchView.queryDelayTimerMs);
		},
		$removeQueryDelayTimer: function MapsSearchView$RemoveQueryDelayTimer() {
			this.queryDelayTimer = tab.MiscUtil.clearTimeout(this.queryDelayTimer);
		},
		$queryDelayTimerCallback: function MapsSearchView$QueryDelayTimerCallback() {
			this.mapsSearchViewModel.getSuggestionsForSearchString(this.get_compositeSearchWidget().get_textInputView().get_text());
			this.$removeQueryDelayTimer();
		},
		updateSearchTextValue: function MapsSearchView$UpdateSearchTextValue(candidate) {
			var newSearchText = candidate.geographicSearchCandidateDisplayName;
			if (!ss.isNullOrEmptyString(candidate.geographicSearchCandidateParentName)) {
				newSearchText += ', ' + candidate.geographicSearchCandidateParentName;
			}
			this.get_compositeSearchWidget().setSearchText(newSearchText);
		},
		selectAllSearchText: function MapsSearchView$SelectAllSearchText() {
			tab.DomUtil.selectAllInputText(this.$compositeSearchWidget.get_textInputView().get_inputElement());
		},
		handleEnableUserInteraction: function MapsSearchView$HandleEnableUserInteraction(enable) {
			this.element.css({ 'pointer-events': (enable ? 'auto' : 'none') });
		},
		createListItemContent: function MapsSearchView$CreateListItemContent(item) {
			return this.$getFormattedSuggestionListItemLabel(item.get_data());
		},
		$setInputElementHandlers: function MapsSearchView$SetInputElementHandlers() {
			var inputElement = this.get_compositeSearchWidget().get_textInputView().get_inputElement();
			if (!ss.staticEquals(this.mapsSearchViewModel.get_focusInHandler(), null)) {
				inputElement.focusin(this.mapsSearchViewModel.get_focusInHandler());
			}
			if (!ss.staticEquals(this.mapsSearchViewModel.get_focusOutHandler(), null)) {
				inputElement.focusout(this.mapsSearchViewModel.get_focusOutHandler());
			}
			if (!ss.staticEquals(this.mapsSearchViewModel.get_keypressHandler(), null)) {
				inputElement.keypress(this.mapsSearchViewModel.get_keypressHandler());
			}
		},
		dispose: function MapsSearchView$Dispose() {
			this.$compositeSearchWidget.dispose();
			if (ss.isValue(this.gotoMyLocationButton)) {
				this.gotoMyLocationButton.dispose();
			}
			ss.makeGenericType(spiff.BaseView$1, [$tab_MapsSearchViewModel]).prototype.dispose.call(this);
		}
	}, ss.makeGenericType(spiff.BaseView$1, [$tab_MapsSearchViewModel]), [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [$tab_MapsSearchViewModel]), spiff.IListItemContentCreator]);
	ss.initClass($tab_MapsSearchViewModel, $asm, {
		add_receivedNewSuggestions: function MapsSearchViewModel$add_ReceivedNewSuggestions(value) {
			this.$2$ReceivedNewSuggestionsField = ss.delegateCombine(this.$2$ReceivedNewSuggestionsField, value);
		},
		remove_receivedNewSuggestions: function MapsSearchViewModel$remove_ReceivedNewSuggestions(value) {
			this.$2$ReceivedNewSuggestionsField = ss.delegateRemove(this.$2$ReceivedNewSuggestionsField, value);
		},
		add_updateTextInputValue: function MapsSearchViewModel$add_UpdateTextInputValue(value) {
			this.$2$UpdateTextInputValueField = ss.delegateCombine(this.$2$UpdateTextInputValueField, value);
		},
		remove_updateTextInputValue: function MapsSearchViewModel$remove_UpdateTextInputValue(value) {
			this.$2$UpdateTextInputValueField = ss.delegateRemove(this.$2$UpdateTextInputValueField, value);
		},
		add_onMoveMapToBounds: function MapsSearchViewModel$add_OnMoveMapToBounds(value) {
			this.$2$OnMoveMapToBoundsField = ss.delegateCombine(this.$2$OnMoveMapToBoundsField, value);
		},
		remove_onMoveMapToBounds: function MapsSearchViewModel$remove_OnMoveMapToBounds(value) {
			this.$2$OnMoveMapToBoundsField = ss.delegateRemove(this.$2$OnMoveMapToBoundsField, value);
		},
		add_searchWidgetCollapsed: function MapsSearchViewModel$add_SearchWidgetCollapsed(value) {
			this.$2$SearchWidgetCollapsedField = ss.delegateCombine(this.$2$SearchWidgetCollapsedField, value);
		},
		remove_searchWidgetCollapsed: function MapsSearchViewModel$remove_SearchWidgetCollapsed(value) {
			this.$2$SearchWidgetCollapsedField = ss.delegateRemove(this.$2$SearchWidgetCollapsedField, value);
		},
		add_visibilityChanged: function MapsSearchViewModel$add_VisibilityChanged(value) {
			this.$2$VisibilityChangedField = ss.delegateCombine(this.$2$VisibilityChangedField, value);
		},
		remove_visibilityChanged: function MapsSearchViewModel$remove_VisibilityChanged(value) {
			this.$2$VisibilityChangedField = ss.delegateRemove(this.$2$VisibilityChangedField, value);
		},
		add_userInteractionEnabled: function MapsSearchViewModel$add_UserInteractionEnabled(value) {
			this.$2$UserInteractionEnabledField = ss.delegateCombine(this.$2$UserInteractionEnabledField, value);
		},
		remove_userInteractionEnabled: function MapsSearchViewModel$remove_UserInteractionEnabled(value) {
			this.$2$UserInteractionEnabledField = ss.delegateRemove(this.$2$UserInteractionEnabledField, value);
		},
		add_initialTextInputValueRestored: function MapsSearchViewModel$add_InitialTextInputValueRestored(value) {
			this.$2$InitialTextInputValueRestoredField = ss.delegateCombine(this.$2$InitialTextInputValueRestoredField, value);
		},
		remove_initialTextInputValueRestored: function MapsSearchViewModel$remove_InitialTextInputValueRestored(value) {
			this.$2$InitialTextInputValueRestoredField = ss.delegateRemove(this.$2$InitialTextInputValueRestoredField, value);
		},
		add_suggestionListRemoved: function MapsSearchViewModel$add_SuggestionListRemoved(value) {
			this.$2$SuggestionListRemovedField = ss.delegateCombine(this.$2$SuggestionListRemovedField, value);
		},
		remove_suggestionListRemoved: function MapsSearchViewModel$remove_SuggestionListRemoved(value) {
			this.$2$SuggestionListRemovedField = ss.delegateRemove(this.$2$SuggestionListRemovedField, value);
		},
		add_blurInputElementCalled: function MapsSearchViewModel$add_BlurInputElementCalled(value) {
			this.$2$BlurInputElementCalledField = ss.delegateCombine(this.$2$BlurInputElementCalledField, value);
		},
		remove_blurInputElementCalled: function MapsSearchViewModel$remove_BlurInputElementCalled(value) {
			this.$2$BlurInputElementCalledField = ss.delegateRemove(this.$2$BlurInputElementCalledField, value);
		},
		get_visualID: function MapsSearchViewModel$get_VisualID() {
			return this.$visualIdPresModel;
		},
		get_gotoMyLocationButtonEnabled: function MapsSearchViewModel$get_GotoMyLocationButtonEnabled() {
			return tab.FeatureParamsLookup.getBool(32) && BrowserSupport.BrowserSupport.IsGeolocationSupported();
		},
		get_focusInHandler: function MapsSearchViewModel$get_FocusInHandler() {
			return this.$2$FocusInHandlerField;
		},
		set_focusInHandler: function MapsSearchViewModel$set_FocusInHandler(value) {
			this.$2$FocusInHandlerField = value;
		},
		get_focusOutHandler: function MapsSearchViewModel$get_FocusOutHandler() {
			return this.$2$FocusOutHandlerField;
		},
		set_focusOutHandler: function MapsSearchViewModel$set_FocusOutHandler(value) {
			this.$2$FocusOutHandlerField = value;
		},
		get_keypressHandler: function MapsSearchViewModel$get_KeypressHandler() {
			return this.$2$KeypressHandlerField;
		},
		set_keypressHandler: function MapsSearchViewModel$set_KeypressHandler(value) {
			this.$2$KeypressHandlerField = value;
		},
		commitToSearchString: function MapsSearchViewModel$CommitToSearchString(value) {
			value = value.trim();
			this.sendGeographicSearchQuery(value, 1, ss.mkdel(this, this.moveToTopGeographicCandidate));
		},
		getSuggestionsForSearchString: function MapsSearchViewModel$GetSuggestionsForSearchString(value) {
			this.sendGeographicSearchQuery(value, $tab_MapsSearchViewModel.$maxNumberOfSuggestions, ss.mkdel(this, this.processGeographicSuggestions));
		},
		moveMapToCandidateBounds: function MapsSearchViewModel$MoveMapToCandidateBounds(candidate) {
			if (ss.isValue(this.$2$UpdateTextInputValueField)) {
				this.$2$UpdateTextInputValueField(candidate);
			}
			if (ss.isValue(this.$2$OnMoveMapToBoundsField)) {
				this.$2$OnMoveMapToBoundsField(candidate.mapLatLongRect);
			}
			tab.MapClientCommands.boundingBoxPan(this.$visualIdPresModel, candidate.mapLatLongRect);
		},
		moveMapToSuggestionListItem: function MapsSearchViewModel$MoveMapToSuggestionListItem(listItem) {
			var geographicEntity = listItem.get_data();
			this.moveMapToCandidateBounds(geographicEntity);
		},
		moveToTopGeographicCandidate: function MapsSearchViewModel$MoveToTopGeographicCandidate(suggestions) {
			var allCandidates = suggestions.geographicSearchCandidateList;
			if (allCandidates.length === 0) {
				tab.Log.get(this).debug('No results returned', []);
			}
			else {
				var topCandidate = allCandidates[0];
				tab.Log.get(this).debug('Top candidate: NAME: %s, PARENT: %s, SCORE: %o, BOUNDS: %o', [topCandidate.geographicSearchCandidateDisplayName, topCandidate.geographicSearchCandidateParentName, topCandidate.geographicSearchCandidateScore, JSON.stringify(topCandidate.mapLatLongRect)]);
				this.moveMapToCandidateBounds(topCandidate);
			}
		},
		processGeographicSuggestions: function MapsSearchViewModel$ProcessGeographicSuggestions(suggestions) {
			if (!ss.isValue(this.$2$ReceivedNewSuggestionsField)) {
				return;
			}
			var listItems = [];
			for (var i = 0; i < suggestions.geographicSearchCandidateList.length; i++) {
				listItems.push(suggestions.geographicSearchCandidateList[i]);
			}
			this.$2$ReceivedNewSuggestionsField(suggestions.geographicSearchSearchString, listItems);
		},
		sendGeographicSearchQuery: function MapsSearchViewModel$SendGeographicSearchQuery(value, maxNumberOfResults, resultsCallback) {
			var locale = tsConfig.workbookLocale || tab.LocaleStrings.unitedStates.toLowerCase();
			tab.MapClientCommands.geographicSearchQuery(this.$visualIdPresModel, value, locale, maxNumberOfResults, resultsCallback);
		},
		collapseSearchWidget: function MapsSearchViewModel$CollapseSearchWidget() {
			this.raiseActionEvent(this.$2$SearchWidgetCollapsedField);
		},
		setVisible: function MapsSearchViewModel$SetVisible(isVisible) {
			this.raiseActionEvent$1(Boolean).call(this, this.$2$VisibilityChangedField, isVisible);
		},
		enableUserInteraction: function MapsSearchViewModel$EnableUserInteraction(isEnabled) {
			this.raiseActionEvent$1(Boolean).call(this, this.$2$UserInteractionEnabledField, isEnabled);
		},
		restoreInitialTextInputValue: function MapsSearchViewModel$RestoreInitialTextInputValue() {
			this.raiseActionEvent(this.$2$InitialTextInputValueRestoredField);
		},
		removeSuggestionList: function MapsSearchViewModel$RemoveSuggestionList() {
			this.raiseActionEvent(this.$2$SuggestionListRemovedField);
		},
		blurInputElement: function MapsSearchViewModel$BlurInputElement() {
			this.raiseActionEvent(this.$2$BlurInputElementCalledField);
		}
	}, spiff.BaseViewModel, [ss.IDisposable, tab.IViewModel]);
	ss.initClass($tab_MarkRange, $asm, {});
	ss.initClass($tab_MarksHitTestLink, $asm, {
		hitTest: function MarksHitTestLink$HitTest(p, isSingleSelect) {
			var selectionRect = (ss.isValue(p) ? { x: p.x, y: p.y, w: 1, h: 1 } : null);
			return $tab_MarksHitTestLink.hitTestMarks(selectionRect, isSingleSelect, this.$ensureHitTestStructure(), this.$sceneInfo, null);
		},
		$ensureHitTestStructure: function MarksHitTestLink$EnsureHitTestStructure() {
			if (ss.isNullOrUndefined(this.$hitTester)) {
				this.$hitTester = $tab_MarksHitTestLink.buildHitTester(this.$sceneInfo);
			}
			return this.$hitTester;
		},
		clearCache: function MarksHitTestLink$ClearCache() {
			this.$hitTester = null;
		}
	}, $tab_HitTestLink, [ss.IDisposable, $tab_IHitTestLink]);
	ss.initEnum($tab_NodeType, $asm, { root: 0, pane: 1, bin: 2, mark: 3, lineSegmentUnionRect: 4, trendLineSegment: 5, userPane: 6, annotation: 7, refLine: 8, refLineLabel: 9 });
	ss.initClass($tab_PaneDrawInfo, $asm, {
		setDefaultLabelLookupValues: function PaneDrawInfo$SetDefaultLabelLookupValues() {
			this.c.set('label_index', tab.VisualColumnIterator.create([-1]));
		},
		addLabelInfo: function PaneDrawInfo$AddLabelInfo(markLayoutOutput, startIndex, endIndex) {
			this.$labelColumnIterators = $tab_PaneDrawInfo.$parseColumns(markLayoutOutput, startIndex, endIndex - startIndex);
			this.transformColumnData(this.$labelColumnIterators);
			var tupleIds = this.$labelColumnIterators.get('tuple_id');
			var markIndexes = [];
			if (ss.isValue(tupleIds)) {
				var labelLookupCol = new Array(this.markCount);
				for (var i = 0; i < this.markCount; i++) {
					labelLookupCol[i] = -1;
				}
				for (var i1 = 0; i1 < tupleIds.length; i1++) {
					var markIndex = this.tupleToIndexMap.get(tupleIds.v[(tupleIds.c ? 0 : i1)]);
					if (ss.isValue(markIndex)) {
						labelLookupCol[markIndex] = i1;
						markIndexes.push(markIndex);
					}
				}
				this.c.set('label_index', tab.VisualColumnIterator.create(labelLookupCol));
			}
			tupleIds = this.c.get('tuple_id');
			var labelBoundingBoxes = new Map();
			var bboxArray = new Array(this.markCount);
			this.$visitMarksPerUserPane$1(markIndexes, ss.mkdel(this, function(markIndex1, userPaneRect) {
				if (ss.isValue(markIndex1)) {
					var bbox = $tab_PaneDrawInfo.getMarkBoundingBox('label', markIndex1, this, userPaneRect);
					labelBoundingBoxes.set(tupleIds.v[(tupleIds.c ? 0 : markIndex1)], bbox);
					bboxArray[markIndex1] = bbox;
				}
			}));
			var offsets = this.$computeInstanceOffsets(bboxArray);
			this.markLabelWorldOffsets = offsets.$worldOffsets;
			this.markLabelInstanceOffsets = offsets.$instanceOffsets;
			var $t2;
			if (this.$labelColumnIterators.has('pane_flags')) {
				var $t1 = this.$labelColumnIterators.get('pane_flags');
				$t2 = $t1.v[($t1.c ? 0 : 0)];
			}
			else {
				$t2 = 0;
			}
			var labelFlags = $t2;
			this.truncateLabelToCell = tab.SceneDataUtil.isPaneFlagSet(labelFlags, 'clip-to-cell-x');
			ss.Debug.assert(!this.truncateLabelToCell || tab.SceneDataUtil.isPaneFlagSet(labelFlags, 'clip-to-cell-y'), 'ClipToCellX must be used together with ClipToCellY for labels');
			var isTextTable = ss.isValue(markLayoutOutput.MarkLayoutData) && ss.isValue(markLayoutOutput.MarkLayoutData.TextCompositionInputKeys) && markLayoutOutput.MarkLayoutData.TextCompositionInputKeys.is_text_table === true;
			this.parseTextInfo(markLayoutOutput.TextRunTable, markLayoutOutput.TextStyleTable, true, isTextTable);
			this.sceneInfo.$addLabelBoundingBoxes(this, labelBoundingBoxes);
		},
		get_paneIndex: function PaneDrawInfo$get_PaneIndex() {
			return this.$1$PaneIndexField;
		},
		set_paneIndex: function PaneDrawInfo$set_PaneIndex(value) {
			this.$1$PaneIndexField = value;
		},
		get_hasLabels: function PaneDrawInfo$get_HasLabels() {
			return ss.isValue(this.$labelColumnIterators);
		},
		get_hasSelection: function PaneDrawInfo$get_HasSelection() {
			return this.sceneInfo.get_hasSelection();
		},
		get_hasBrushing: function PaneDrawInfo$get_HasBrushing() {
			return this.sceneInfo.get_hasBrushing();
		},
		get_lineDrawState: function PaneDrawInfo$get_LineDrawState() {
			if (this.$lineDrawState === null) {
				ss.Debug.assert(false, 'LineDrawState requested before allocation');
				this.$lineDrawState = new $tab_LineMarkDrawState(this);
			}
			return this.$lineDrawState;
		},
		get_hasBackground: function PaneDrawInfo$get_HasBackground() {
			var $t2 = this.c.has('pane_has_background');
			if ($t2) {
				var $t1 = this.c.get('pane_has_background');
				$t2 = $t1.v[($t1.c ? 0 : 0)] === true;
			}
			return $t2;
		},
		get_hasHalos: function PaneDrawInfo$get_HasHalos() {
			var $t2 = this.c.has('has_halos');
			if ($t2) {
				var $t1 = this.c.get('has_halos');
				$t2 = $t1.v[($t1.c ? 0 : 0)] === true;
			}
			return $t2;
		},
		get_hasHaloHighlightColor: function PaneDrawInfo$get_HasHaloHighlightColor() {
			return this.c.has('highlighted_halo_color') && this.c.get('highlighted_halo_color').isValid;
		},
		get_borderColor: function PaneDrawInfo$get_BorderColor() {
			var $t2;
			if (this.c.has('border_color')) {
				var $t1 = this.c.get('border_color');
				$t2 = $t1.v[($t1.c ? 0 : 0)];
			}
			else {
				$t2 = null;
			}
			return $t2;
		},
		get_textStyleColumns: function PaneDrawInfo$get_TextStyleColumns() {
			return this.$textStyleColumnIterators;
		},
		get_mapExtentOrPaneRect: function PaneDrawInfo$get_MapExtentOrPaneRect() {
			return this.mapExtents || this.paneRect;
		},
		get_clipLabelToCell: function PaneDrawInfo$get_ClipLabelToCell() {
			return this.truncateLabelToCell;
		},
		get_paneDescriptorKey: function PaneDrawInfo$get_PaneDescriptorKey() {
			return this.paneMarks.get_paneKey();
		},
		get_hasGlobalTransparency: function PaneDrawInfo$get_HasGlobalTransparency() {
			return this.globalAlpha < 1;
		},
		get_extents: function PaneDrawInfo$get_Extents() {
			return this.domainExtents;
		},
		get_paneFlags: function PaneDrawInfo$get_PaneFlags() {
			return this.$paneFlags;
		},
		set_paneFlags: function PaneDrawInfo$set_PaneFlags(value) {
			this.$paneFlags = value;
			this.$initPaneMaskPrecalculatedFields();
		},
		get_$sceneRect: function PaneDrawInfo$get_SceneRect() {
			return this.sceneInfo.get_$sceneRect();
		},
		getTextRunProperty: function PaneDrawInfo$GetTextRunProperty(columnName, index) {
			if (ss.isNullOrUndefined(this.$textRunColumnIterators) || !this.$textRunColumnIterators.has(columnName) || ss.isNullOrUndefined(this.$textRunColumnIterators.get(columnName))) {
				return null;
			}
			var $t1 = this.$textRunColumnIterators.get(columnName);
			return $t1.v[($t1.c ? 0 : index)];
		},
		markHasLabel: function PaneDrawInfo$MarkHasLabel(index) {
			return this.c.get('label_index').gv(index) !== -1;
		},
		getOneColorAlpha: function PaneDrawInfo$GetOneColorAlpha(color, mode, alpha) {
			var cm = null;
			this.$discreteColorTable = this.$discreteColorTable || new Map();
			if (!this.$discreteColorTable.has(color)) {
				cm = tab.ColorModel.fromArgbInt(color);
				var newCollection = tab.SceneDataUtil.createColorCollection(cm, this.foggedBackgroundColor, this.fogBlendFactor);
				this.$discreteColorTable.set(color, newCollection);
			}
			var colorCollection = this.$discreteColorTable.get(color);
			if (mode === 'colorOverrideReplaceAlpha') {
				cm = cm || tab.ColorModel.fromArgbInt(color);
				return tab.ColorModel.fromColorModelPlusAlpha(cm, alpha / 255).toRgba();
			}
			return colorCollection[mode];
		},
		$getColors: function PaneDrawInfo$GetColors(index, key) {
			var colors = this.c.get(key).gv(index);
			if (this.$filteredMarks.has(index)) {
				var overrideColors = {};
				overrideColors['colorOverrideFog'] = colors['colorOverrideFog'];
				overrideColors['colorOverrideNone'] = colors['colorOverrideFog'];
				overrideColors['colorOverrideOpaque'] = colors['colorOverrideFog'];
				colors = overrideColors;
			}
			return colors;
		},
		getMarkColors: function PaneDrawInfo$GetMarkColors(index) {
			var key = 'color';
			if (this.forceOpaqueColors && this.c.get('opaque_color').isValid) {
				key = 'opaque_color';
			}
			return this.$getColors(index, key);
		},
		getBorderColors: function PaneDrawInfo$GetBorderColors(index) {
			return this.$getColors(index, 'border_color');
		},
		getMarkGeometry: function PaneDrawInfo$GetMarkGeometry(geometryIndex) {
			return this.sceneInfo.$getMarkGeometry(this.pdMarksKey, geometryIndex);
		},
		isMarkPropertyConstant: function PaneDrawInfo$IsMarkPropertyConstant(columnName) {
			return this.c.get(columnName).c;
		},
		computeDirtyMarks: function PaneDrawInfo$ComputeDirtyMarks(dirtyRect) {
			this.$dirtyMarks = new Map();
			var entirePaneDirty = tab.RectXYUtil.completelyContains(dirtyRect, this.paneRect);
			var tupleIds = this.c.get('tuple_id');
			for (var i = 0; i < this.markCount; i++) {
				var tupleId = tupleIds.v[(tupleIds.c ? 0 : i)];
				if (!this.isTupleVisible(tupleId)) {
					continue;
				}
				if (entirePaneDirty) {
					this.$dirtyMarks.set(i, true);
					continue;
				}
				if (this.markType === 'line' || this.markType === 'area') {
					this.$dirtyMarks.set(i, true);
				}
				else {
					var markBounds = this.$getTupleBounds(tupleId);
					var markOffsets = this.getMarkInstanceOffsets(i);
					if (tab.RectXYUtil.intersectsWithAny$1(dirtyRect, markBounds, markOffsets)) {
						this.$dirtyMarks.set(i, true);
					}
				}
			}
		},
		clearDirtyMarks: function PaneDrawInfo$ClearDirtyMarks() {
			this.$dirtyMarks = null;
		},
		markNeedsDraw: function PaneDrawInfo$MarkNeedsDraw(index) {
			return tab.AnimationUtil.isUpdating() || ss.isValue(this.$dirtyMarks) && this.$dirtyMarks.has(index);
		},
		markLabelNeedsDraw: function PaneDrawInfo$MarkLabelNeedsDraw(index, dirtyRect) {
			if (this.getMarkState(index) === 'markStateInvisible') {
				return false;
			}
			var labelBounds = this.getMarkLabelBounds(index);
			var markLabelOffsets = this.getMarkLabelInstanceOffsets(index);
			return tab.RectXYUtil.intersectsWithAny$1(dirtyRect, labelBounds, markLabelOffsets);
		},
		refreshMarkState: function PaneDrawInfo$RefreshMarkState() {
			this.$markState = this.sceneInfo.computeTupleStates(this.c.get('tuple_id'));
			this.$filteredMarks = this.sceneInfo.computeFilteredMarks(this.c.get('tuple_id'));
			this.$marksWithMarker = new Map();
			for (var i = 0; i < this.markCount; i++) {
				if (this.$computeShouldShowMarker(i)) {
					this.$marksWithMarker.set(i, true);
				}
			}
			if (this.$isCompositeMarkType()) {
				this.$lineDrawState = new $tab_LineMarkDrawState(this);
			}
		},
		getMarkState: function PaneDrawInfo$GetMarkState(index) {
			if (ss.isValue(this.$markState) && this.$markState.length > index) {
				return this.$markState[index];
			}
			return this.$computeMarkState(index);
		},
		getMarkLabelState: function PaneDrawInfo$GetMarkLabelState(index) {
			if (this.$isCompositeMarkType()) {
				var attributes = this.get_lineDrawState().get_lineAttributes();
				for (var $t1 = 0; $t1 < attributes.length; $t1++) {
					var la = attributes[$t1];
					if (la.startIndex <= index && index <= la.endIndex) {
						switch (la.get_lineState()) {
							case 'lineStateHighlighted': {
								return (this.$markHasOneLabelPerGroup(index) ? 'markStateHighlighted' : this.getMarkState(index));
							}
							case 'lineStateSelected': {
								if (this.markType === 'pie' && !this.$markHasOneLabelPerGroup(index)) {
									return this.getMarkState(index);
								}
								return 'markStateSelected';
							}
							case 'lineStateNormal': {
								return 'markStateNormal';
							}
						}
						return 'markStateNormal';
					}
				}
			}
			return this.getMarkState(index);
		},
		getMarkLabelProperty: function PaneDrawInfo$GetMarkLabelProperty(columnName, markIndex) {
			if (this.markType === 'text') {
				return this.c.get(columnName).gv(markIndex);
			}
			var labelIndex = this.c.get('label_index').gv(markIndex);
			if (labelIndex === -1) {
				return null;
			}
			ss.Debug.assert(this.$labelColumnIterators.has(columnName), 'Accessing non-existent column: ' + columnName);
			var $t1 = this.$labelColumnIterators.get(columnName);
			return $t1.v[($t1.c ? 0 : labelIndex)];
		},
		getAllMarkBounds: function PaneDrawInfo$GetAllMarkBounds() {
			var allBounds = new Array(this.markCount);
			var tupleColumn = this.c.get('tuple_id');
			var labelColumn = this.c.get('label_index');
			for (var i = 0; i < this.markCount; i++) {
				var tupleId = tupleColumn.v[(tupleColumn.c ? 0 : i)];
				var bb = this.sceneInfo.getMarkBoundingBox(tupleId);
				var lbb = ((labelColumn.v[(labelColumn.c ? 0 : i)] === -1) ? null : this.sceneInfo.$getLabelBoundingBox(tupleId));
				allBounds[i] = { item1: bb, item2: lbb };
			}
			return allBounds;
		},
		getMarkBounds: function PaneDrawInfo$GetMarkBounds(markIndex) {
			var $t1 = this.c.get('tuple_id');
			return this.$getTupleBounds($t1.v[($t1.c ? 0 : markIndex)]);
		},
		getMarkIndexFromTupleId: function PaneDrawInfo$GetMarkIndexFromTupleId(tupleId) {
			return this.tupleToIndexMap.get(tupleId);
		},
		containsTuple: function PaneDrawInfo$ContainsTuple(tupleId) {
			return this.tupleToIndexMap.has(tupleId);
		},
		getMarkLabelBounds: function PaneDrawInfo$GetMarkLabelBounds(markIndex) {
			var $t2 = this.sceneInfo;
			var $t1 = this.c.get('tuple_id');
			return $t2.$getLabelBoundingBox($t1.v[($t1.c ? 0 : markIndex)]);
		},
		getInsetPaneClipRect: function PaneDrawInfo$GetInsetPaneClipRect(userPaneIndex, inset) {
			var twoInset = 2 * inset;
			var paneRect = this.getUserPaneRectByIndex(userPaneIndex);
			return { x: paneRect.x + inset, y: paneRect.y + inset, w: paneRect.w - twoInset, h: paneRect.h - twoInset };
		},
		getUserPaneRectByMark: function PaneDrawInfo$GetUserPaneRectByMark(markIndex) {
			if (this.hasUserPanes) {
				return this.$userPaneInfo.$getUserPaneRectByMark(markIndex);
			}
			else {
				return { x: 0, y: 0, w: this.paneRect.w, h: this.paneRect.h };
			}
		},
		getUserPaneRectByIndex: function PaneDrawInfo$GetUserPaneRectByIndex(userPaneIndex) {
			if (this.hasUserPanes) {
				return this.$userPaneInfo.$getUserPaneRectByIndex(userPaneIndex);
			}
			else {
				ss.Debug.assert(userPaneIndex === 0, 'User pane index is not 0 even though there are no user panes');
				return { x: 0, y: 0, w: this.paneRect.w, h: this.paneRect.h };
			}
		},
		getUserPaneRectByTupleId: function PaneDrawInfo$GetUserPaneRectByTupleId(tupleId) {
			if (this.hasUserPanes) {
				return this.$userPaneInfo.$getUserPaneRectByMark(this.getMarkIndexFromTupleId(tupleId));
			}
			else {
				return { x: 0, y: 0, w: this.paneRect.w, h: this.paneRect.h };
			}
		},
		getUserPaneMarkCount: function PaneDrawInfo$GetUserPaneMarkCount(userPaneIndex) {
			if (!this.hasUserPanes) {
				return this.markCount;
			}
			else {
				return this.$userPaneInfo.$getUserPaneMarkCount(userPaneIndex);
			}
		},
		getUserPaneMarkRange: function PaneDrawInfo$GetUserPaneMarkRange(userPaneIndex) {
			if (!this.hasUserPanes) {
				return { firstMark: 0, lastMark: this.markCount - 1 };
			}
			else {
				return this.$userPaneInfo.$getUserPaneMarkRange(userPaneIndex);
			}
		},
		getUserPaneIndexByMark: function PaneDrawInfo$GetUserPaneIndexByMark(markIndex) {
			if (!this.hasUserPanes) {
				return 0;
			}
			else {
				return this.$userPaneInfo.$getUserPaneIndexByMark(markIndex);
			}
		},
		initStaticProperties: function PaneDrawInfo$InitStaticProperties() {
			var $t2 = this.c.has('draw_border');
			if ($t2) {
				var $t1 = this.c.get('draw_border');
				$t2 = $t1.v[($t1.c ? 0 : 0)];
			}
			this.drawBorder = $t2;
			var $t4 = this.c.has('wrap_domain');
			if ($t4) {
				var $t3 = this.c.get('wrap_domain');
				$t4 = $t3.v[($t3.c ? 0 : 0)];
			}
			this.isWrappedDomain = $t4;
			var $t6;
			if (this.c.has('alpha')) {
				var $t5 = this.c.get('alpha');
				$t6 = $t5.v[($t5.c ? 0 : 0)];
			}
			else {
				$t6 = 1;
			}
			this.globalAlpha = $t6;
			var $t8;
			if (this.c.has('line_interp')) {
				var $t7 = this.c.get('line_interp');
				$t8 = $t7.v[($t7.c ? 0 : 0)];
			}
			else {
				$t8 = 'lim-linear';
			}
			this.lineInterpolation = $t8;
			var $t10;
			if (this.c.has('min_bar_width')) {
				var $t9 = this.c.get('min_bar_width');
				$t10 = $t9.v[($t9.c ? 0 : 0)];
			}
			else {
				$t10 = 0;
			}
			this.minBarWidth = $t10;
			var $t12;
			if (this.c.has('min_bar_height')) {
				var $t11 = this.c.get('min_bar_height');
				$t12 = $t11.v[($t11.c ? 0 : 0)];
			}
			else {
				$t12 = 0;
			}
			this.minBarHeight = $t12;
		},
		$visitMarksPerUserPane: function PaneDrawInfo$VisitMarksPerUserPane(visitor) {
			if (!this.hasUserPanes) {
				var rect = this.getUserPaneRectByIndex(0);
				var markCount = this.markCount;
				for (var markIndex = 0; markIndex < markCount; ++markIndex) {
					visitor(markIndex, rect);
				}
			}
			else {
				this.$userPaneInfo.$visitMarksPerUserPane(visitor);
			}
		},
		$visitMarksPerUserPane$1: function PaneDrawInfo$VisitMarksPerUserPane(marks, visitor) {
			if (!this.hasUserPanes) {
				var rect = this.getUserPaneRectByIndex(0);
				for (var $t1 = 0; $t1 < marks.length; $t1++) {
					var markIndex = marks[$t1];
					visitor(markIndex, rect);
				}
			}
			else {
				this.$userPaneInfo.$visitMarksPerUserPane$1(marks, visitor);
			}
		},
		getMarkInstanceOffsets: function PaneDrawInfo$GetMarkInstanceOffsets(markIndex) {
			if (!this.isWrappedDomain || ss.isNullOrUndefined(this.markInstanceOffsets)) {
				return $tab_PaneDrawInfo.$noWorldOffsetArray;
			}
			return this.markInstanceOffsets[markIndex];
		},
		getMarkLabelInstanceOffsets: function PaneDrawInfo$GetMarkLabelInstanceOffsets(labelIndex) {
			if (!this.isWrappedDomain || ss.isNullOrUndefined(this.markLabelInstanceOffsets)) {
				return $tab_PaneDrawInfo.$noWorldOffsetArray;
			}
			return this.markLabelInstanceOffsets[labelIndex];
		},
		getWorldInstanceOffsets: function PaneDrawInfo$GetWorldInstanceOffsets(xMin, xMax) {
			if (!this.isWrappedDomain) {
				return $tab_PaneDrawInfo.$noWorldOffsetArray;
			}
			var padding = Math.min(ss.Int32.trunc(this.worldWidth), this.paneRect.w);
			xMin -= padding;
			xMax += padding;
			var extents = this.get_mapExtentOrPaneRect();
			var lowIdx = Math.ceil((extents.x - xMax) / this.worldWidth);
			var highIdx = Math.floor((extents.x + extents.w - xMin) / this.worldWidth);
			var offsetCount = highIdx - lowIdx + 1;
			var offsets = new Array(offsetCount);
			var offset = lowIdx * this.worldWidth;
			for (var i = 0; i < offsetCount; i++, offset += this.worldWidth) {
				offsets[i] = offset;
			}
			return offsets;
		},
		getWorldOffsetBounds: function PaneDrawInfo$GetWorldOffsetBounds(bounds) {
			var offsetBounds = [];
			var offsets = this.getWorldInstanceOffsets(bounds.x, bounds.x + bounds.w);
			var offsetCount = offsets.length;
			for (var index = 0; index < offsetCount; index++) {
				var offset = offsets[index];
				if (offset !== 0) {
					var offsetBound = tab.RectXYUtil.offsetRectXY(bounds, ss.Int32.trunc(offset) | 0, 0);
					offsetBounds.push(offsetBound);
				}
				else {
					offsetBounds.push(bounds);
				}
			}
			return offsetBounds;
		},
		isTupleSelected: function PaneDrawInfo$IsTupleSelected(tupleId) {
			return tupleId !== 0 && this.sceneInfo.$isMarkSelected(tupleId);
		},
		isMarkSelected: function PaneDrawInfo$IsMarkSelected(index) {
			var $t1 = this.c.get('tuple_id');
			return this.isTupleSelected($t1.v[($t1.c ? 0 : index)]);
		},
		isMarkImpliedSelected: function PaneDrawInfo$IsMarkImpliedSelected(index) {
			var $t1 = this.c.get('tuple_id');
			var tupleId = $t1.v[($t1.c ? 0 : index)];
			return tupleId !== 0 && this.sceneInfo.$isMarkImpliedSelected(tupleId);
		},
		isTupleHighlighted: function PaneDrawInfo$IsTupleHighlighted(tupleId) {
			return tupleId !== 0 && this.sceneInfo.$isMarkBrushed(tupleId);
		},
		isMarkHighlighted: function PaneDrawInfo$IsMarkHighlighted(index) {
			var $t1 = this.c.get('tuple_id');
			var tupleId = $t1.v[($t1.c ? 0 : index)];
			return this.isTupleHighlighted(tupleId);
		},
		isTupleVisible: function PaneDrawInfo$IsTupleVisible(tupleId) {
			return tupleId !== 0 && this.sceneInfo.$isMarkVisible(tupleId);
		},
		isLineSegmentVisible: function PaneDrawInfo$IsLineSegmentVisible(index0, index1) {
			return this.getMarkState(index0) !== 'markStateInvisible' && this.getMarkState(index1) !== 'markStateInvisible';
		},
		isLineSegmentFiltered: function PaneDrawInfo$IsLineSegmentFiltered(index0, index1) {
			return this.$filteredMarks.has(index0) || this.$filteredMarks.has(index1);
		},
		shouldStampThisShapeMark: function PaneDrawInfo$ShouldStampThisShapeMark(markIndex) {
			if (this.$stampAllShapeMarks) {
				return true;
			}
			if (ss.isNullOrUndefined(this.shapeMarkStampingDecision)) {
				return false;
			}
			if (markIndex >= this.markCount) {
				return false;
			}
			return this.shapeMarkStampingDecision[markIndex];
		},
		isMarkEndPrimitive: function PaneDrawInfo$IsMarkEndPrimitive(index) {
			var flags = this.c.get('mark_flags').gv(index);
			return tab.SceneDataUtil.isMarkFlagSet(flags, 'endprimitive');
		},
		isMarkDebug: function PaneDrawInfo$IsMarkDebug(index) {
			var flags = this.c.get('mark_flags').gv(index);
			return tab.SceneDataUtil.isMarkFlagSet(flags, 'debug');
		},
		shouldShowMarker: function PaneDrawInfo$ShouldShowMarker(index) {
			if (ss.isNullOrUndefined(this.$marksWithMarker)) {
				return this.$computeShouldShowMarker(index);
			}
			return this.$marksWithMarker.has(index);
		},
		$getTextStyleColor: function PaneDrawInfo$GetTextStyleColor(styleId, markIdx, colorOverrideMode) {
			var colorModeDict = null;
			if (markIdx >= 0 && !this.hasConstantColor && this.markType === 'text') {
				colorModeDict = this.getMarkColors(markIdx);
			}
			else if (ss.isValue(this.$textStyleColumnIterators) && this.$textStyleColumnIterators.has('text_style_color')) {
				var $t1 = this.$textStyleColumnIterators.get('text_style_color');
				colorModeDict = $t1.v[($t1.c ? 0 : styleId)];
			}
			if (ss.isNullOrUndefined(colorModeDict)) {
				return 'black';
			}
			if (markIdx !== -1 && this.$filteredMarks.has(markIdx)) {
				colorOverrideMode = 'colorOverrideFog';
			}
			return colorModeDict[colorOverrideMode];
		},
		thisDomainToPixelX: function PaneDrawInfo$ThisDomainToPixelX(x) {
			return $tab_PaneDrawInfo.domainToPixelX(x, this.domainExtents, this.paneRect);
		},
		thisDomainToPixelY: function PaneDrawInfo$ThisDomainToPixelY(y) {
			return $tab_PaneDrawInfo.domainToPixelY(y, this.domainExtents, this.paneRect);
		},
		thisDomainToPixelWidth: function PaneDrawInfo$ThisDomainToPixelWidth(width) {
			return $tab_PaneDrawInfo.domainToPixelWidth(width, this.domainExtents, this.paneRect);
		},
		thisDomainToPixelHeight: function PaneDrawInfo$ThisDomainToPixelHeight(height) {
			return $tab_PaneDrawInfo.domainToPixelHeight(height, this.domainExtents, this.paneRect);
		},
		$isCompositeMarkType: function PaneDrawInfo$IsCompositeMarkType() {
			return this.markType === 'line' || this.markType === 'area' || this.markType === 'pie';
		},
		$markHasOneLabelPerGroup: function PaneDrawInfo$MarkHasOneLabelPerGroup(index) {
			return ss.unbox(ss.cast(this.getMarkLabelProperty('label_one_per_group', index), Boolean));
		},
		$computeShouldShowMarker: function PaneDrawInfo$ComputeShouldShowMarker(index) {
			var flags = this.c.get('mark_flags').gv(index);
			return tab.SceneDataUtil.isMarkFlagSet(flags, 'marked') || tab.SceneDataUtil.isMarkFlagSet(flags, 'markediflabel') && this.markHasLabel(index) && !this.$markHasOneLabelPerGroup(index);
		},
		setUserPaneInfo: function PaneDrawInfo$SetUserPaneInfo(sceneUserPaneInfo) {
			if (ss.isNullOrUndefined(sceneUserPaneInfo)) {
				return;
			}
			if (this.markType === 'text') {
				return;
			}
			this.$userPaneInfo = new $tab_UserPaneInfo(sceneUserPaneInfo, this);
			this.userPaneCount = this.$userPaneInfo.$userPaneCount;
			this.hasUserPanes = true;
		},
		processColors: function PaneDrawInfo$ProcessColors(colorDict) {
			var generateOpaqueColors = this.$shouldGenerateOpaqueColors();
			if (ss.isNullOrUndefined(colorDict) || !this.c.has('color_idx')) {
				if (generateOpaqueColors) {
					this.$buildOpaqueColors();
				}
				return;
			}
			var colorTable = tab.VisualColumnHelpers.buildColorTable(colorDict, this.c, this.foggedBackgroundColor, this.fogBlendFactor);
			var opaqueColorTable = null;
			if (generateOpaqueColors) {
				opaqueColorTable = tab.VisualColumnHelpers.buildOpaqueColorTable(colorTable);
			}
			var colorIndexIterator = this.c.get('color_idx');
			var count = colorIndexIterator.length;
			var markColors = new Array(count);
			var opaqueMarkColors = (generateOpaqueColors ? new Array(count) : null);
			for (var index = 0; index < count; index++) {
				var translatedIndex = colorIndexIterator.v[(colorIndexIterator.c ? 0 : index)];
				markColors[index] = colorTable[translatedIndex];
				if (generateOpaqueColors) {
					opaqueMarkColors[index] = opaqueColorTable[translatedIndex];
				}
			}
			this.c.set('color', tab.VisualColumnIterator.create(markColors));
			if (generateOpaqueColors) {
				this.c.set('opaque_color', tab.VisualColumnIterator.create(opaqueMarkColors));
			}
			this.c.delete('color_idx');
		},
		$buildOpaqueColors: function PaneDrawInfo$BuildOpaqueColors() {
			var colorIter = this.c.get('color');
			if (ss.isValue(colorIter)) {
				var opaqueColors = new Array(colorIter.length);
				for (var ii = 0; ii < colorIter.length; ++ii) {
					opaqueColors[ii] = tab.SceneDataUtil.createOpaqueColorCollection(colorIter.v[(colorIter.c ? 0 : ii)]);
				}
				this.c.set('opaque_color', tab.VisualColumnIterator.create(opaqueColors));
			}
		},
		buildTupleLookup: function PaneDrawInfo$BuildTupleLookup() {
			this.tupleToIndexMap.clear();
			var tuples = this.c.get('tuple_id');
			if (!ss.isNullOrUndefined(tuples)) {
				var numTuples = tuples.length;
				for (var i = 0; i < numTuples; i++) {
					this.tupleToIndexMap.set(tuples.v[(tuples.c ? 0 : i)], i);
				}
			}
		},
		$getTupleBounds: function PaneDrawInfo$GetTupleBounds(tupleId) {
			return this.sceneInfo.getMarkBoundingBox(tupleId);
		},
		$shouldGenerateOpaqueColors: function PaneDrawInfo$ShouldGenerateOpaqueColors() {
			return this.markType === 'line' && this.get_hasGlobalTransparency();
		},
		transformColumnData: function PaneDrawInfo$TransformColumnData(columns) {
			var hasAlpha = tab.VisualColumnHelpers.transformColumn(columns.get('alpha'), function(val) {
				return val / 255;
			});
			for (var $t1 = 0; $t1 < $tab_PaneDrawInfo.$colorColumns.length; $t1++) {
				var colorColumn = $tab_PaneDrawInfo.$colorColumns[$t1];
				var useAlpha = { $: hasAlpha && colorColumn === 'text_style_color' };
				var $t3;
				if (useAlpha.$) {
					var $t2 = columns.get('alpha');
					$t3 = $t2.v[($t2.c ? 0 : 0)];
				}
				else {
					$t3 = 1;
				}
				var colorAlpha = { $: $t3 };
				tab.VisualColumnHelpers.transformColumn(columns.get(colorColumn), ss.mkdel({ useAlpha: useAlpha, colorAlpha: colorAlpha, $this: this }, function(val1) {
					var cm = tab.ColorModel.fromArgbInt(val1);
					if (this.useAlpha.$) {
						cm = new tab.ColorModel(cm.get_r(), cm.get_g(), cm.get_b(), this.colorAlpha.$ * cm.get_a());
					}
					return tab.SceneDataUtil.createColorCollection(cm, this.$this.foggedBackgroundColor, this.$this.fogBlendFactor);
				}));
			}
			tab.VisualColumnHelpers.transformColumn(columns.get('shape_id'), function(val2) {
				return tab.SceneDataUtil.shapeMapping[val2] || val2;
			});
			tab.VisualColumnHelpers.transformColumn(columns.get('line_interp'), function(val3) {
				return tab.SceneDataUtil.lineInterpolationMapping[val3] || val3;
			});
			if (ss.isValue(this.paneRect) && ss.isValue(this.domainExtents) && this.domainExtents.w !== 0 && this.domainExtents.h !== 0) {
				$tab_PaneDrawInfo.$floatColumnsMappedToInt.forEach(ss.mkdel(this, function(col, floatColName) {
					var scale;
					var offset;
					var intColName = floatColName + $tab_PaneDrawInfo.$intColumnSuffix;
					if (ss.contains($tab_PaneDrawInfo.$columnsToConvertToXDomainCoords, floatColName)) {
						var divisor = $tab_PaneDrawInfo.$dimensionFloatToIntMapMultiplier * Math.max(1, this.paneRect.w);
						scale = this.domainExtents.w / divisor;
						offset = this.domainExtents.x;
					}
					else if (ss.contains($tab_PaneDrawInfo.$columnsToConvertToYDomainCoords, floatColName)) {
						var divisor1 = $tab_PaneDrawInfo.$dimensionFloatToIntMapMultiplier * Math.max(1, this.paneRect.h);
						scale = this.domainExtents.h / divisor1;
						offset = this.domainExtents.y;
					}
					else {
						scale = ($tab_PaneDrawInfo.$floatColumnsMappedToInt.get(floatColName).y - $tab_PaneDrawInfo.$floatColumnsMappedToInt.get(floatColName).x) / 32767;
						offset = $tab_PaneDrawInfo.$floatColumnsMappedToInt.get(floatColName).x;
					}
					var found = tab.VisualColumnHelpers.transformColumn(columns.get(intColName), function(val4) {
						return (ss.isValue(val4) ? (val4 * scale + offset) : null);
					});
					if (found) {
						columns.set(floatColName, columns.get(intColName));
						columns.delete(intColName);
					}
				}));
				var offsetPaneRect = { x: 0, y: 0, w: this.paneRect.w, h: this.paneRect.h };
				for (var $t4 = 0; $t4 < $tab_PaneDrawInfo.$columnsToConvertToXDomainCoords.length; $t4++) {
					var xCol = $tab_PaneDrawInfo.$columnsToConvertToXDomainCoords[$t4];
					tab.VisualColumnHelpers.transformColumn(columns.get(xCol), ss.mkdel(this, function(val5) {
						return $tab_PaneDrawInfo.domainToPixelX(val5, this.domainExtents, offsetPaneRect);
					}));
				}
				for (var $t5 = 0; $t5 < $tab_PaneDrawInfo.$columnsToConvertToWidthDomainCoords.length; $t5++) {
					var widthCol = $tab_PaneDrawInfo.$columnsToConvertToWidthDomainCoords[$t5];
					tab.VisualColumnHelpers.transformColumn(columns.get(widthCol), ss.mkdel(this, function(val6) {
						return $tab_PaneDrawInfo.domainToPixelWidth(val6, this.domainExtents, this.paneRect);
					}));
				}
				for (var $t6 = 0; $t6 < $tab_PaneDrawInfo.$columnsToConvertToYDomainCoords.length; $t6++) {
					var yCol = $tab_PaneDrawInfo.$columnsToConvertToYDomainCoords[$t6];
					tab.VisualColumnHelpers.transformColumn(columns.get(yCol), ss.mkdel(this, function(val7) {
						return $tab_PaneDrawInfo.domainToPixelY(val7, this.domainExtents, offsetPaneRect);
					}));
				}
				for (var $t7 = 0; $t7 < $tab_PaneDrawInfo.$columnsToConvertToHeightDomainCoords.length; $t7++) {
					var heightCol = $tab_PaneDrawInfo.$columnsToConvertToHeightDomainCoords[$t7];
					tab.VisualColumnHelpers.transformColumn(columns.get(heightCol), ss.mkdel(this, function(val8) {
						return $tab_PaneDrawInfo.domainToPixelHeight(val8, this.domainExtents, this.paneRect);
					}));
				}
			}
		},
		$createTextStyleColumns: function PaneDrawInfo$CreateTextStyleColumns(textStyles, useMarkAlpha) {
			var toRet = new Map();
			if (!ss.isNullOrUndefined(textStyles.font)) {
				var fontCol = textStyles.font;
				var numStyles = fontCol.length;
				var preparedFonts = new Array(numStyles);
				for (var ii = 0; ii < numStyles; ++ii) {
					preparedFonts[ii] = $tab_PaneDrawInfo.$createPreparedFont$1(textStyles, ii);
				}
				toRet.set('font', tab.VisualColumnIterator.create(preparedFonts));
				var textStylesDict = textStyles;
				var $t1 = _.keys(textStylesDict);
				for (var $t2 = 0; $t2 < $t1.length; $t2++) {
					var key = $t1[$t2];
					if (!ss.contains($tab_PaneDrawInfo.$combinedFontTerms, key)) {
						var styles = textStylesDict[key];
						toRet.set(key, tab.VisualColumnIterator.create(tab.VisualColumnHelpers.copyArray(styles, 0, styles.length)));
					}
				}
				if (useMarkAlpha) {
					var markAlpha = this.c.get('alpha').gv(0);
					if (ss.isValue(markAlpha)) {
						toRet.set('alpha', tab.VisualColumnIterator.create([markAlpha * 255]));
					}
				}
				this.transformColumnData(toRet);
				tab.VisualColumnHelpers.transformColumn(toRet.get('text_orientation'), function(styleVal) {
					ss.Debug.assert($tab_PaneDrawInfo.textAngleInRad.has(ss.unbox(ss.cast(styleVal, ss.Int32))), 'unknown text orientation value: ' + styleVal);
					return $tab_PaneDrawInfo.textAngleInRad.get(ss.unbox(ss.cast(styleVal, ss.Int32)));
				});
				tab.VisualColumnHelpers.transformColumn(toRet.get('text_alignment'), function(styleVal1) {
					var textHAlign = 'start';
					var alignmentNum = ss.unbox(ss.cast(styleVal1, ss.Int32));
					if (alignmentNum === 2) {
						textHAlign = 'end';
					}
					return textHAlign;
				});
			}
			return toRet;
		},
		prepareLeftRight: function PaneDrawInfo$PrepareLeftRight() {
			var left = new Array(this.markCount);
			var right = new Array(this.markCount);
			for (var ii = 0; ii < this.markCount; ++ii) {
				left[ii] = -1;
				right[ii] = -1;
			}
			var areaStart = 0;
			var flagsCol = this.c.get('mark_flags');
			for (var mark = 0; mark < this.markCount; mark++) {
				var flags = flagsCol.v[(flagsCol.c ? 0 : mark)];
				if (!tab.SceneDataUtil.isMarkFlagSet(flags, 'end')) {
					right[mark] = mark + 1;
					left[mark + 1] = mark;
				}
				if (tab.SceneDataUtil.isMarkFlagSet(flags, 'closedprimitive')) {
					right[mark] = areaStart;
					left[areaStart] = mark;
				}
				if (tab.SceneDataUtil.isMarkFlagSet(flags, 'endprimitive')) {
					areaStart = mark + 1;
				}
			}
			this.c.set('l_neighbor', tab.VisualColumnIterator.create(left));
			this.c.set('r_neighbor', tab.VisualColumnIterator.create(right));
		},
		setupBoundingBoxes: function PaneDrawInfo$SetupBoundingBoxes() {
			var tupleIds = this.c.get('tuple_id');
			var markBoundingBoxes = new Map();
			var bboxArray = new Array(this.markCount);
			this.$visitMarksPerUserPane(ss.mkdel(this, function(markIndex, userPaneRect) {
				var bbox = $tab_PaneDrawInfo.getMarkBoundingBox(this.markType, markIndex, this, userPaneRect);
				markBoundingBoxes.set(tupleIds.v[(tupleIds.c ? 0 : markIndex)], bbox);
				bboxArray[markIndex] = bbox;
			}));
			if (this.markType === 'pie') {
				ss.Debug.assert(!this.hasUserPanes, 'Single-header optimization should not be enabled for pie charts');
				var lmds = new $tab_LineMarkDrawState(this);
				var $t1 = lmds.get_lineAttributes();
				for (var $t2 = 0; $t2 < $t1.length; $t2++) {
					var la = $t1[$t2];
					var tupleArray = [];
					var tupleId = tupleIds.v[(tupleIds.c ? 0 : la.startIndex)];
					tupleArray.push(tupleId);
					var fullMarkBoundingBox = tab.RectXYUtil.clone(markBoundingBoxes.get(tupleId));
					for (var idx = la.startIndex + 1; idx <= la.endIndex; ++idx) {
						tupleId = tupleIds.v[(tupleIds.c ? 0 : idx)];
						tupleArray.push(tupleId);
						tab.RectXYUtil.unionInPlace(fullMarkBoundingBox, markBoundingBoxes.get(tupleId));
					}
					this.sceneInfo.$addFullMarkBoundingBoxes(this, fullMarkBoundingBox, tupleArray);
				}
			}
			var offsets = this.$computeInstanceOffsets(bboxArray);
			this.markWorldOffsets = offsets.$worldOffsets;
			this.markInstanceOffsets = offsets.$instanceOffsets;
			this.sceneInfo.$addMarkBoundingBoxes(this, markBoundingBoxes);
		},
		setupCustomShapePositions: function PaneDrawInfo$SetupCustomShapePositions() {
			if (this.markType === 'shape' && this.sceneInfo.customShapes.length > 0) {
				var leftValues = [];
				var topValues = [];
				var shapeIdCol = this.c.get('shape_id');
				var xCol = this.c.get('x');
				var yCol = this.c.get('y');
				var sizeCol = this.c.get('size');
				for (var markIndex = 0; markIndex < this.markCount; ++markIndex) {
					if (tab.SceneDataUtil.isCustomShape(shapeIdCol.v[(shapeIdCol.c ? 0 : markIndex)])) {
						var halfSize = sizeCol.v[(sizeCol.c ? 0 : markIndex)] / 2;
						leftValues[markIndex] = Math.round(xCol.v[(xCol.c ? 0 : markIndex)] - halfSize);
						topValues[markIndex] = Math.round(yCol.v[(yCol.c ? 0 : markIndex)] - halfSize);
					}
				}
				if (leftValues.length > 0) {
					this.c.set('left', tab.VisualColumnIterator.create(leftValues));
					this.c.set('top', tab.VisualColumnIterator.create(topValues));
				}
			}
		},
		setupShapeMarkStampingMap: function PaneDrawInfo$SetupShapeMarkStampingMap() {
			if (this.markCount < $tab_PaneDrawInfo.shapeMarkStampingRatio) {
				return;
			}
			if (BrowserSupport.BrowserSupport.IsIE()) {
				this.shapeMarkStampingDecision = null;
				if (!this.sceneInfo.get_isSingleUserPane()) {
					return;
				}
				if (this.clipCase !== 0) {
					return;
				}
			}
			var constantColor = this.isMarkPropertyConstant('color');
			var constantWidth = this.isMarkPropertyConstant('size');
			var constantShapeId = this.isMarkPropertyConstant('shape_id');
			if (constantShapeId) {
				var shape = this.c.get('shape_id').gv(0);
				if (!tab.SceneDataUtil.isSupportedStampShape(shape)) {
					return;
				}
				if (constantColor && constantWidth) {
					this.$stampAllShapeMarks = true;
					return;
				}
			}
			var widthIterator = this.c.get('size');
			var shapeIdIterator = this.c.get('shape_id');
			var distinctMap = {};
			var result = new Array(this.markCount);
			for (var markIndex = 0; markIndex < this.markCount; markIndex++) {
				result[markIndex] = false;
				var identifier = [];
				if (!constantWidth) {
					identifier.push(widthIterator.v[(widthIterator.c ? 0 : markIndex)]);
				}
				if (!constantShapeId) {
					var shape1 = shapeIdIterator.v[(shapeIdIterator.c ? 0 : markIndex)];
					if (!tab.SceneDataUtil.isSupportedStampShape(shape1)) {
						continue;
					}
					identifier.push(shape1);
				}
				if (!constantColor) {
					var colorMappingTable = this.getMarkColors(markIndex);
					identifier.push(colorMappingTable['colorOverrideNone']);
				}
				var identifierString = identifier.toString();
				if (!ss.keyExists(distinctMap, identifierString)) {
					distinctMap[identifierString] = [];
				}
				distinctMap[identifierString].push(markIndex);
			}
			var stamped = false;
			var stampCount = 0;
			var $t1 = _.keys(distinctMap);
			for (var $t2 = 0; $t2 < $t1.length; $t2++) {
				var identifier1 = $t1[$t2];
				var marksIndexCollection = distinctMap[identifier1];
				if (marksIndexCollection.length >= $tab_PaneDrawInfo.shapeMarkStampingRatio) {
					for (var $t3 = 0; $t3 < marksIndexCollection.length; $t3++) {
						var markIndex1 = marksIndexCollection[$t3];
						result[markIndex1] = true;
						stampCount++;
					}
					stamped = true;
				}
			}
			if (stampCount === this.markCount) {
				this.$stampAllShapeMarks = true;
				this.shapeMarkStampingDecision = null;
			}
			else if (stamped) {
				this.shapeMarkStampingDecision = result;
			}
			else {
				this.shapeMarkStampingDecision = null;
			}
		},
		parseTextInfo: function PaneDrawInfo$ParseTextInfo(textRuns, textStyles, isMarkLabel, isTextTable) {
			if (!ss.isNullOrUndefined(textRuns)) {
				ss.Debug.assert(ss.isNullOrUndefined(this.$textRunColumnIterators), 'Overwriting text run columns!');
				this.$textRunColumnIterators = new Map();
				var textRunDict = textRuns;
				var $t1 = new ss.ObjectEnumerator(textRunDict);
				try {
					while ($t1.moveNext()) {
						var pair = $t1.current();
						var vals = pair.value;
						this.$textRunColumnIterators.set(pair.key, tab.VisualColumnIterator.create(vals));
					}
				}
				finally {
					$t1.dispose();
				}
				if (!isMarkLabel && !isTextTable) {
					this.$textRunColumnIterators.set('text_run_x', this.$textRunColumnIterators.get('text_run_x_remote'));
					this.$textRunColumnIterators.set('text_run_y', this.$textRunColumnIterators.get('text_run_y_remote'));
				}
			}
			if (ss.isValue(textStyles)) {
				ss.Debug.assert(ss.isNullOrUndefined(this.$textStyleColumnIterators), 'Overwriting text style columns!');
				this.$textStyleColumnIterators = this.$createTextStyleColumns(textStyles, !isMarkLabel);
			}
		},
		$computeInstanceOffsets: function PaneDrawInfo$ComputeInstanceOffsets(boundingBoxes) {
			var worldOffsets = new Map();
			var instanceOffsets = null;
			if (!this.isWrappedDomain) {
				worldOffsets.set(0, new Set());
				return new $tab_$PaneDrawInfo$WorldAndInstanceOffsets(worldOffsets, instanceOffsets);
			}
			var boxCount = boundingBoxes.length;
			instanceOffsets = new Array(boxCount);
			for (var i = 0; i < boxCount; i++) {
				var boundingBox = boundingBoxes[i];
				if (ss.isNullOrUndefined(boundingBox)) {
					continue;
				}
				instanceOffsets[i] = this.getWorldInstanceOffsets(boundingBox.x + this.paneRect.x, boundingBox.x + boundingBox.w + this.paneRect.x);
				var $t1 = instanceOffsets[i];
				for (var $t2 = 0; $t2 < $t1.length; $t2++) {
					var offset = $t1[$t2];
					if (!worldOffsets.has(offset)) {
						worldOffsets.set(offset, new Set());
						for (var rangeIdx = 0; rangeIdx < this.markCount; rangeIdx++) {
							worldOffsets.get(offset).add(rangeIdx);
						}
					}
					worldOffsets.get(offset).delete(i);
				}
			}
			var offsets = new $tab_$PaneDrawInfo$WorldAndInstanceOffsets(worldOffsets, instanceOffsets);
			return offsets;
		},
		$initPaneMaskPrecalculatedFields: function PaneDrawInfo$InitPaneMaskPrecalculatedFields() {
			this.scaleMarksInX = tab.SceneDataUtil.isPaneFlagSet(this.$paneFlags, 'enable-scale-x');
			this.scaleMarksInY = tab.SceneDataUtil.isPaneFlagSet(this.$paneFlags, 'enable-scale-y');
			this.useCellClipForSelection = tab.SceneDataUtil.isPaneFlagSet(this.$paneFlags, 'clip-to-cell-for-selection');
			this.paneHasCellsX = tab.SceneDataUtil.isPaneFlagSet(this.$paneFlags, 'has-cells-x');
			this.paneHasCellsY = tab.SceneDataUtil.isPaneFlagSet(this.$paneFlags, 'has-cells-y');
		},
		$computeMarkState: function PaneDrawInfo$ComputeMarkState(index) {
			var $t1 = this.c.get('tuple_id');
			var tuples = [$t1.v[($t1.c ? 0 : index)]];
			var states = this.sceneInfo.computeTupleStates(tab.VisualColumnIterator.create(tuples));
			return states[0];
		}
	});
	$tab_PaneDrawInfo.$ctor1.prototype = $tab_PaneDrawInfo.prototype;
	ss.initClass($tab_PaneTable2DRenderer, $asm, {
		drawReferenceLineAndTrendLineGroup: function PaneTable2DRenderer$DrawReferenceLineAndTrendLineGroup(items, targetState, context, drawAll, applyFog) {
			var colorUpdatedForState = false;
			var originalStrokeStyle = null;
			var originalShapeFillStyle = null;
			var originalTextFillStyle = null;
			for (var $t1 = 0; $t1 < items.length; $t1++) {
				var item = items[$t1];
				var isFillRectOrDrawText = item.type === 'draw-fill-rect' || item.type === 'draw-text';
				var isHoverOrSelected = targetState === 'hover' || targetState === 'selected';
				var shouldApplyStateColorChange = true;
				if (isFillRectOrDrawText && isHoverOrSelected) {
					var colorModel = tab.ColorModel.fromColorCode(context.get_shapeFillStyle());
					if (colorModel.get_a() < 1) {
						if (targetState === 'hover') {
							continue;
						}
						shouldApplyStateColorChange = false;
					}
				}
				var isStyleItem = item.type === 'draw-pen' || item.type === 'draw-solid-brush' || item.type === 'draw-text-props';
				if (drawAll || isStyleItem) {
					if ((isStyleItem || !shouldApplyStateColorChange) && colorUpdatedForState) {
						context.set_strokeStyle(originalStrokeStyle.toString());
						context.set_shapeFillStyle(originalShapeFillStyle.toString());
						context.set_textFillStyle(originalTextFillStyle.toString());
						colorUpdatedForState = false;
					}
					if ((ss.isValue(applyFog) || targetState !== 'normal') && !colorUpdatedForState && !isStyleItem && shouldApplyStateColorChange) {
						var isTypeVisuallyAffected = item.type === 'draw-polyline' || item.type === 'draw-path' || item.type === 'draw-rect' || item.type === 'draw-fill-rect';
						originalStrokeStyle = tab.ColorModel.fromColorCode(context.get_strokeStyle());
						originalShapeFillStyle = tab.ColorModel.fromColorCode(context.get_shapeFillStyle());
						originalTextFillStyle = tab.ColorModel.fromColorCode(context.get_textFillStyle());
						var newStrokeStyle = $tab_PaneTable2DRenderer.calculateColorForState(originalStrokeStyle, targetState, isTypeVisuallyAffected, applyFog);
						var newShapeFillStyle = $tab_PaneTable2DRenderer.calculateColorForState(originalShapeFillStyle, targetState, isTypeVisuallyAffected, applyFog);
						var newTextFillStyle = $tab_PaneTable2DRenderer.calculateColorForState(originalTextFillStyle, targetState, isTypeVisuallyAffected, applyFog);
						colorUpdatedForState = !ss.referenceEquals(newStrokeStyle, originalStrokeStyle.toString()) || !ss.referenceEquals(newShapeFillStyle, originalShapeFillStyle.toString()) || !ss.referenceEquals(newTextFillStyle, originalTextFillStyle.toString());
						if (colorUpdatedForState) {
							context.set_strokeStyle(newStrokeStyle);
							context.set_shapeFillStyle(newShapeFillStyle);
							context.set_textFillStyle(newTextFillStyle);
						}
					}
					this.renderVisualParts(context, item);
				}
			}
			if (colorUpdatedForState) {
				context.set_strokeStyle(originalStrokeStyle.toString());
				context.set_shapeFillStyle(originalShapeFillStyle.toString());
				context.set_textFillStyle(originalTextFillStyle.toString());
			}
		},
		renderScene: function PaneTable2DRenderer$RenderScene(paneTableVm) {
			if (ss.isNullOrUndefined(paneTableVm)) {
				throw new ss.ArgumentNullException('paneTableVm', 'Cant render a null scene');
			}
			this.$sceneInfo = paneTableVm.get_scene();
			var scenePresModel = this.$sceneInfo.scene;
			if (!ss.isValue(scenePresModel)) {
				return;
			}
			this.$displayListRenderer.setRenderOffsetNoTranslate(this.get_renderOffset());
			var startingNumSavedStates = this.get_currentContext().get_numberSavedStates();
			var fastMaps = paneTableVm.get_mapServerModel().get_useFastMaps();
			if (!fastMaps) {
				this.$renderVisualRegions(paneTableVm.get_vizRegionMap(), paneTableVm.get_drawFirstParts());
			}
			var sceneDirtyRect = tab.RectXYUtil.offsetRect(this.get_currentContext().dirtyRect, this.get_renderOffset());
			var Slop = 3;
			sceneDirtyRect = tab.RectXYUtil.outsetRect(sceneDirtyRect, Slop, Slop);
			this.$sceneInfo.prepareForDraw(sceneDirtyRect);
			var panes = (ss.isValue(this.$sceneInfo.get_runtimeData()) ? this.$sceneInfo.get_runtimeData().get_annexedData().Panes : null);
			this.$renderPanes(panes, fastMaps);
			this.$sceneInfo.cleanupFromDraw();
			this.$renderVisualRegions(paneTableVm.get_vizRegionMap(), paneTableVm.get_drawLastParts());
			ss.Debug.assert(this.get_currentContext().get_numberSavedStates() === startingNumSavedStates, 'The saves/restores of states should be balanced');
			while (this.get_currentContext().get_numberSavedStates() > startingNumSavedStates) {
				this.get_currentContext().restore();
			}
		},
		renderViewportBorders: function PaneTable2DRenderer$RenderViewportBorders(paneTableVm) {
			if (ss.isNullOrUndefined(paneTableVm)) {
				throw new ss.ArgumentNullException('paneTableVm', 'Cant render a null scene');
			}
			this.$sceneInfo = paneTableVm.get_scene();
			var scenePresModel = this.$sceneInfo.scene;
			if (ss.isNullOrUndefined(scenePresModel)) {
				return;
			}
			var paneBorderDisplayList = null;
			var $t1 = paneTableVm.get_scene().get_runtimeData();
			if ($t1 === Object($t1)) {
				paneBorderDisplayList = this.$getFirstPaneBorderVisualList(paneTableVm.get_scene().get_runtimeData().get_panes());
			}
			if (ss.isNullOrUndefined(paneBorderDisplayList)) {
				return;
			}
			var viewportBorderDrawItems = [];
			var borderWidth = this.get_currentCanvas().width - 1;
			var borderHeight = this.get_currentCanvas().height - 1;
			var topLeft = { x: 0, y: 0 };
			var topRight = { x: borderWidth, y: 0 };
			var bottomLeft = { x: 0, y: borderHeight };
			var bottomRight = { x: borderWidth, y: borderHeight };
			var seenOneHorizontal = false;
			var seenOneVertical = false;
			for (var $t2 = 0; $t2 < paneBorderDisplayList.drawItems.length; $t2++) {
				var drawItem = paneBorderDisplayList.drawItems[$t2];
				if (drawItem.type === 'clip-rect' || drawItem.type === 'transform') {
					continue;
				}
				if (drawItem.type === 'draw-polyline') {
					var drawPoints = tab.MiscUtil.cloneObject(drawItem);
					if (drawPoints.points[1] === drawPoints.points[3]) {
						if (seenOneHorizontal) {
							$tab_PaneTable2DRenderer.$setCoordinatesFromPoints(drawPoints.points, bottomLeft, bottomRight);
						}
						else {
							$tab_PaneTable2DRenderer.$setCoordinatesFromPoints(drawPoints.points, topLeft, topRight);
						}
						seenOneHorizontal = true;
					}
					else {
						ss.Debug.assert(drawPoints.points[0] === drawPoints.points[2], "Assuming if it's not horizontal then it's vertical");
						if (seenOneVertical) {
							$tab_PaneTable2DRenderer.$setCoordinatesFromPoints(drawPoints.points, topRight, bottomRight);
						}
						else {
							$tab_PaneTable2DRenderer.$setCoordinatesFromPoints(drawPoints.points, topLeft, bottomLeft);
						}
						seenOneVertical = true;
					}
					viewportBorderDrawItems.push(drawPoints);
				}
				else {
					viewportBorderDrawItems.push(drawItem);
				}
			}
			this.get_currentContext().save();
			this.$renderDrawItems(viewportBorderDrawItems, null, 'pane-borders');
			this.get_currentContext().restore();
		},
		renderAxisRulers: function PaneTable2DRenderer$RenderAxisRulers(paneTableVm, docSize, scrollPos) {
			var vlvm = paneTableVm.get_vizRegionMap()['axis-rules'];
			if (ss.isValue(vlvm)) {
				var lineMaker = function(start, end) {
					var line = { type: 'draw-polyline', points: new Array(4) };
					$tab_PaneTable2DRenderer.$setCoordinatesFromPoints(line.points, start, end);
					return line;
				};
				var pixelRatio = tab.RenderUtil.calculatePixelRatio(true);
				var canvasBottom = this.get_currentCanvas().height - 1;
				var rulersDrawItems = [];
				var $t1 = vlvm.get_visualListPM().drawItems;
				for (var $t2 = 0; $t2 < $t1.length; $t2++) {
					var drawItem = $t1[$t2];
					if (drawItem.type === 'draw-pen') {
						rulersDrawItems.push(drawItem);
					}
					else if (drawItem.type === 'draw-polyline') {
						var drawPoints = drawItem;
						if (drawPoints.points[0] === drawPoints.points[2]) {
							rulersDrawItems.push(lineMaker({ x: 0, y: -scrollPos.y }, { x: 0, y: Math.round(pixelRatio * docSize.h) - scrollPos.y }));
						}
						else if (drawPoints.points[1] === drawPoints.points[3]) {
							rulersDrawItems.push(lineMaker({ x: -scrollPos.x, y: canvasBottom }, { x: Math.round(pixelRatio * docSize.w) - scrollPos.x, y: canvasBottom }));
						}
					}
				}
				this.get_currentContext().save();
				this.$renderDrawItems(rulersDrawItems, null, 'axis-rules');
				this.get_currentContext().restore();
			}
		},
		$getFirstPaneBorderVisualList: function PaneTable2DRenderer$GetFirstPaneBorderVisualList(panes) {
			for (var $t1 = 0; $t1 < panes.length; $t1++) {
				var panePM = panes[$t1];
				for (var $t2 = 0; $t2 < panePM.drawPane.length; $t2++) {
					var vlpm = panePM.drawPane[$t2];
					if (vlpm.visualPart === 'pane-borders') {
						return vlpm;
					}
				}
			}
			return null;
		},
		$renderVisualRegions: function PaneTable2DRenderer$RenderVisualRegions(lists, parts) {
			if (tab.MiscUtil.isNullOrEmpty$2(lists) || ss.getKeyCount(lists) === 0) {
				return;
			}
			for (var $t1 = 0; $t1 < parts.length; $t1++) {
				var part = parts[$t1];
				var vlvm = lists[part];
				if (!ss.contains($tab_PaneTableViewModel.blackListVisualParts, part) && part !== 'axis-rules') {
					ss.Debug.assert(ss.isValue(vlvm), 'VisualListViewModel should always be non-null');
					if (ss.isValue(vlvm)) {
						this.get_currentContext().save();
						var imgDict = this.$sceneInfo.get_imageDictionary();
						this.$displayListRenderer.renderVisualListHelper(vlvm, imgDict);
						this.get_currentContext().restore();
					}
				}
			}
		},
		$renderVisualList: function PaneTable2DRenderer$RenderVisualList(list, paneDrawInfo) {
			if (!ss.isValue(list)) {
				return;
			}
			this.get_currentContext().save();
			this.$renderDrawItems(list.drawItems, paneDrawInfo, list.visualPart);
			this.get_currentContext().restore();
		},
		$renderPanes: function PaneTable2DRenderer$RenderPanes(panes, fastMaps) {
			if (!ss.isValue(panes)) {
				return;
			}
			var visiblePanes = this.$gatherVisiblePanes(panes);
			if (!fastMaps) {
				this.$renderBackgroundElements(visiblePanes);
			}
			if (ss.isValue(this.$sceneInfo.get_runtimeData().get_finalDataStore().GridLines)) {
				this.$renderGridlines(visiblePanes);
			}
			this.startCachingVisibleRect();
			this.$renderMarksPanes(visiblePanes);
			this.stopCachingVisibleRect();
			this.$renderVisualLists(visiblePanes, 'foreground');
		},
		$renderBackgroundElements: function PaneTable2DRenderer$RenderBackgroundElements(visiblePanes) {
			var visualParts = ['background', 'decoration', 'ref-bands', 'cell-borders', 'misc'];
			for (var $t1 = 0; $t1 < visualParts.length; $t1++) {
				var vp = visualParts[$t1];
				for (var $t2 = 0; $t2 < visiblePanes.length; $t2++) {
					var visiblePane = visiblePanes[$t2];
					var pane = visiblePane.item1;
					var paneDrawInfo = visiblePane.item2;
					var drawPanes = pane.DrawPanes;
					for (var $t3 = 0; $t3 < drawPanes.length; $t3++) {
						var drawPane = drawPanes[$t3];
						var panePartArray = drawPane;
						var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
						var shouldDraw = visualPart === vp;
						if (!shouldDraw && vp === 'misc') {
							shouldDraw = this.$getDrawRole(visualPart) === 'background' && visualParts.indexOf(visualPart) < 0;
						}
						if (shouldDraw) {
							var visualList = tab.RuntimeUtil.visualListFromDrawPane(drawPane);
							this.$renderVisualList(visualList, paneDrawInfo);
						}
					}
					if (vp === 'ref-bands') {
						this.$renderRefBands(paneDrawInfo);
					}
				}
			}
		},
		$renderGridlines: function PaneTable2DRenderer$RenderGridlines(visiblePanes) {
			var renderer = new $tab_GridLinesRenderer(this.get_currentCanvas(), this.get_currentContext());
			for (var $t1 = 0; $t1 < visiblePanes.length; $t1++) {
				var paneItem = visiblePanes[$t1];
				var pane = paneItem.item1;
				var drawPanes = pane.DrawPanes;
				for (var $t2 = 0; $t2 < drawPanes.length; $t2++) {
					var drawPane = drawPanes[$t2];
					var panePartArray = drawPane;
					var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
					if (visualPart === 'decoration') {
						var paneRect = { x: pane.Rect[0], y: pane.Rect[1], w: pane.Rect[2], h: pane.Rect[3] };
						renderer.renderGridLines(this.$sceneInfo.get_runtimeData().get_finalDataStore(), pane.Column, pane.Row, paneRect);
					}
				}
			}
		},
		$renderVisualLists: function PaneTable2DRenderer$RenderVisualLists(visiblePanes, role) {
			for (var $t1 = 0; $t1 < visiblePanes.length; $t1++) {
				var visiblePane = visiblePanes[$t1];
				var pane = visiblePane.item1;
				var paneDrawInfo = visiblePane.item2;
				var drawPanes = pane.DrawPanes;
				for (var $t2 = 0; $t2 < drawPanes.length; $t2++) {
					var drawPane = drawPanes[$t2];
					var panePartArray = drawPane;
					var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
					if (role === this.$getDrawRole(visualPart)) {
						var visualList = tab.RuntimeUtil.visualListFromDrawPane(drawPane);
						this.$renderVisualList(visualList, paneDrawInfo);
					}
				}
			}
		},
		$gatherVisiblePanes: function PaneTable2DRenderer$GatherVisiblePanes(panes) {
			var visiblePanes = [];
			for (var $t1 = 0; $t1 < panes.length; $t1++) {
				var pane = panes[$t1];
				if (this.$isPaneVisible(pane)) {
					visiblePanes.push({ item1: pane, item2: this.$sceneInfo.getPaneDrawInfoAssociatedWithPane(pane) });
				}
			}
			return visiblePanes;
		},
		$renderMarksPanes: function PaneTable2DRenderer$RenderMarksPanes(visiblePanes) {
			for (var $t1 = 0; $t1 < $tab_PaneTable2DRenderer.$renderPassOrder.length; $t1++) {
				var renderPass = $tab_PaneTable2DRenderer.$renderPassOrder[$t1];
				for (var $t2 = 0; $t2 < $tab_PaneTable2DRenderer.$drawRoleOrder.length; $t2++) {
					var role = $tab_PaneTable2DRenderer.$drawRoleOrder[$t2];
					for (var $t3 = 0; $t3 < visiblePanes.length; $t3++) {
						var visiblePane = visiblePanes[$t3];
						var pane = visiblePane.item1;
						var paneDrawInfo = visiblePane.item2;
						if (ss.isNullOrUndefined(paneDrawInfo)) {
							continue;
						}
						if (role === 'marks' || role === 'label') {
							this.$renderMarksAndLabels(pane.DrawPanes, paneDrawInfo, renderPass, role);
						}
						else {
							this.$renderReferenceLines(paneDrawInfo, renderPass, role);
							this.$renderPredictionMarks(pane.PredictionMarks, paneDrawInfo, renderPass, role);
						}
					}
				}
			}
		},
		$renderDrawItems: function PaneTable2DRenderer$RenderDrawItems(items, paneDrawInfo, visPart) {
			if (!ss.isValue(items)) {
				return;
			}
			var imgDict = this.$sceneInfo.get_imageDictionary();
			if (visPart !== 'ref-lines' && visPart !== 'ref-bands' && visPart !== 'trend-lines') {
				var mapClipRect = null;
				if (visPart === 'decoration') {
					if (ss.isValue(paneDrawInfo)) {
						mapClipRect = paneDrawInfo.mapExtents;
					}
				}
				this.$displayListRenderer.renderDrawItems(items, null, imgDict, mapClipRect);
			}
			else {
				if (this.$hasSemanticModelInstantRefLines(visPart, paneDrawInfo)) {
					return;
				}
				var refLineSelector = this.$sceneInfo.selections.refLineSelection;
				var hasRefLineSelection = !refLineSelector.isEmpty;
				var trendLineSelector = this.$sceneInfo.selections.trendLineSelection;
				var hasTrendLineSelection = !trendLineSelector.isEmpty;
				var trendLineBrusher = this.$sceneInfo.brushings.trendLineSelection;
				var fogInfo = null;
				for (var $t1 = 0; $t1 < items.length; $t1++) {
					var item = items[$t1];
					if (item.type === 'draw-group') {
						var drawGroup = item;
						var isSelected = false;
						var isFogged = false;
						switch (visPart) {
							case 'ref-lines': {
								isSelected = refLineSelector.isObjectSelected(drawGroup.objectId);
								isFogged = !isSelected && (hasRefLineSelection || hasTrendLineSelection);
								break;
							}
							case 'ref-bands': {
								isFogged = (hasRefLineSelection || hasTrendLineSelection) && !refLineSelector.isObjectSelected(drawGroup.objectId);
								break;
							}
							case 'trend-lines': {
								if (drawGroup.objectId > 2147483647) {
									if (!trendLineBrusher.isEmpty) {
										continue;
									}
									isSelected = false;
									isFogged = false;
								}
								else {
									isSelected = trendLineSelector.isObjectSelected(drawGroup.objectId);
									isFogged = !isSelected && !trendLineBrusher.isObjectSelected(drawGroup.objectId) && (this.$sceneInfo.get_hasBrushing() || this.$sceneInfo.get_hasSelection());
								}
								break;
							}
						}
						var targetState = (isFogged ? 'fogged' : (isSelected ? 'selected' : 'normal'));
						if (isFogged && ss.isNullOrUndefined(fogInfo)) {
							fogInfo = $tab_PaneTable2DRenderer.getFogBlendFactorAndBackgroundColor(paneDrawInfo);
						}
						this.drawReferenceLineAndTrendLineGroup(drawGroup.drawItems, targetState, this.get_currentContext(), true, (isFogged ? fogInfo : null));
					}
					else {
						this.renderVisualParts(this.get_currentContext(), item);
					}
				}
			}
		},
		renderVisualParts: function PaneTable2DRenderer$RenderVisualParts(context, item) {
			this.$displayListRenderer.renderDrawItemDefaultOptions(context, item);
		},
		$isPaneVisible: function PaneTable2DRenderer$IsPaneVisible(pane) {
			return this.isRectVisible({ x: pane.Rect[0], y: pane.Rect[1], w: pane.Rect[2], h: pane.Rect[3] });
		},
		$renderUserPane: function PaneTable2DRenderer$RenderUserPane(paneDrawInfo, userPaneIndex, renderer, renderPass, func, userPaneRect) {
			this.get_currentContext().save();
			if (!paneDrawInfo.skipClipping) {
				this.get_currentContext().setClip(userPaneRect);
			}
			this.get_currentContext().translate(paneDrawInfo.paneRect.x, paneDrawInfo.paneRect.y);
			func(paneDrawInfo, userPaneIndex, renderer, renderPass);
			this.get_currentContext().restore();
		},
		$iterateUserPanes: function PaneTable2DRenderer$IterateUserPanes(paneDrawInfo, renderPass, func) {
			if (paneDrawInfo.markCount === 0) {
				return;
			}
			var renderer = new $tab_MarksRenderer(this.get_currentCanvas(), this.get_currentContext());
			renderer.setRenderOffsetNoTranslate(this.get_renderOffset());
			if (!paneDrawInfo.hasUserPanes) {
				this.$renderUserPane(paneDrawInfo, 0, renderer, renderPass, func, paneDrawInfo.get_mapExtentOrPaneRect());
				return;
			}
			var userPaneCount = paneDrawInfo.userPaneCount;
			var wholePaneX = paneDrawInfo.paneRect.x;
			var wholePaneY = paneDrawInfo.paneRect.y;
			for (var i = 0; i < userPaneCount; ++i) {
				var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(i);
				userPaneRect = tab.RectXYUtil.offsetRectXY(userPaneRect, wholePaneX, wholePaneY);
				var markCount = paneDrawInfo.getUserPaneMarkCount(i);
				if (markCount > 0 && this.isRectVisible(userPaneRect)) {
					this.$renderUserPane(paneDrawInfo, i, renderer, renderPass, func, userPaneRect);
				}
			}
		},
		$renderMarksAndLabels: function PaneTable2DRenderer$RenderMarksAndLabels(drawPanes, paneDrawInfo, renderPass, role) {
			for (var $t1 = 0; $t1 < drawPanes.length; $t1++) {
				var visualList = drawPanes[$t1];
				var panePartArray = visualList;
				var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
				if (visualPart === 'marks') {
					if (role === 'marks') {
						this.$renderPaneMarks(paneDrawInfo, renderPass);
						break;
					}
					else if (role === 'label') {
						if (paneDrawInfo.get_hasLabels()) {
							this.$renderPaneLabels(paneDrawInfo, renderPass);
							break;
						}
					}
				}
			}
		},
		$renderPaneMarks: function PaneTable2DRenderer$RenderPaneMarks(paneDrawInfo, renderPass) {
			this.$iterateUserPanes(paneDrawInfo, renderPass, ss.mkdel(this, this.$renderMarkLayer));
		},
		$renderPaneLabels: function PaneTable2DRenderer$RenderPaneLabels(paneDrawInfo, renderPass) {
			this.$iterateUserPanes(paneDrawInfo, renderPass, function(pdi, userPaneIndex, renderer, rp) {
				renderer.renderMarkLabels(pdi, userPaneIndex, rp);
			});
		},
		$renderMarkLayer: function PaneTable2DRenderer$RenderMarkLayer(paneDrawInfo, userPaneIndex, renderer, renderPass) {
			var markType = paneDrawInfo.markType;
			switch (markType) {
				case 'shape': {
					{
						renderer.renderShapeMark(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				case 'square':
				case 'bar': {
					{
						renderer.renderBarMark(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				case 'pie': {
					{
						renderer.renderPieMark(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				case 'line': {
					{
						renderer.renderLineMark(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				case 'area': {
					{
						renderer.renderAreaMark(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				case 'text': {
					{
						renderer.renderTextMarks(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				case 'multipolygon': {
					{
						renderer.renderMultipolygonMark(paneDrawInfo, userPaneIndex, renderPass);
					}
					break;
				}
				default: {
					ss.Debug.fail('unknown primitive type');
					break;
				}
			}
		},
		$getDrawRole: function PaneTable2DRenderer$GetDrawRole(part) {
			switch (part) {
				case 'background':
				case 'decoration':
				case 'ref-bands':
				case 'cell-borders': {
					return 'background';
				}
				case 'mark-trails':
				case 'marks':
				case 'mark-labels': {
					return 'marks';
				}
				case 'borders':
				case 'trend-lines':
				case 'ref-lines':
				case 'pane-borders':
				case 'annotations':
				case 'axis-rules': {
					return 'foreground';
				}
			}
			return 'background';
		},
		$getReferenceLineVisualState: function PaneTable2DRenderer$GetReferenceLineVisualState(thisRefLine) {
			if (thisRefLine.get_instantRefLineIsEnabled() && $tab_PaneTable2DRenderer.anInstantRefLineIsPresent(this.$sceneInfo.get_runtimeData())) {
				return 'fogged';
			}
			var refLineSelection = this.$sceneInfo.selections.refLineSelection;
			var noTrendLineIsSelected = this.$sceneInfo.selections.trendLineSelection.isEmpty;
			if (refLineSelection.isEmpty && noTrendLineIsSelected) {
				return 'normal';
			}
			if (refLineSelection.isObjectSelected(thisRefLine.get_id())) {
				return 'selected';
			}
			return 'fogged';
		},
		$renderPredictionMarks: function PaneTable2DRenderer$RenderPredictionMarks(predictionMarks, paneDrawInfo, renderPass, role) {
			if (!ss.isNullOrUndefined(predictionMarks)) {
				for (var $t1 = 0; $t1 < predictionMarks.length; $t1++) {
					var predictionMark = predictionMarks[$t1];
					var renderNode = tab.RuntimeUtil.renderNodeFromPredictionMark(predictionMark);
					switch (renderNode.type) {
						case 'prediction-band': {
							var renderer = new $tab_MarksRenderer(this.get_currentCanvas(), this.get_currentContext());
							renderer.setRenderOffsetNoTranslate(this.get_renderOffset());
							renderer.renderPredictionBand(paneDrawInfo, renderPass, renderNode, role);
							break;
						}
						case 'prediction-whisker': {
							var renderer1 = new $tab_MarksRenderer(this.get_currentCanvas(), this.get_currentContext());
							renderer1.setRenderOffsetNoTranslate(this.get_renderOffset());
							renderer1.renderPredictionWhisker(paneDrawInfo, renderPass, renderNode, role);
							break;
						}
					}
				}
			}
		},
		$renderRefBands: function PaneTable2DRenderer$RenderRefBands(paneDrawInfo) {
			this.$renderReferenceLineElements$1(paneDrawInfo, 'normalUnderPass', 'background', function(refLines, pdKey) {
				return refLines.getRefBands(pdKey);
			}, function(refLines1, pdKey1) {
				return refLines1.getInstantRefBands(pdKey1);
			});
		},
		$renderReferenceLines: function PaneTable2DRenderer$RenderReferenceLines(paneDrawInfo, renderPass, role) {
			this.$renderReferenceLineElements$1(paneDrawInfo, renderPass, role, function(refLines, pdKey) {
				return refLines.getRefLines(pdKey);
			}, function(refLines1, pdKey1) {
				return refLines1.getInstantRefLines(pdKey1);
			});
		},
		$renderReferenceLineElements$1: function PaneTable2DRenderer$RenderReferenceLineElements(paneDrawInfo, renderPass, role, getElements, getInstantElements) {
			if (ss.isNullOrUndefined(this.$sceneInfo) || ss.isNullOrUndefined(paneDrawInfo) || ss.isNullOrUndefined(this.$sceneInfo.get_referenceLines())) {
				return;
			}
			this.$referenceLinesRenderer.setRenderOffsetNoTranslate(this.get_renderOffset());
			var refLinesModel = this.$sceneInfo.get_referenceLines();
			var pdKey = paneDrawInfo.get_paneDescriptorKey();
			this.$renderReferenceLineElements(paneDrawInfo, getElements(refLinesModel, pdKey), ss.mkdel(this, this.$getReferenceLineVisualState), renderPass, role);
			this.$renderReferenceLineElements(paneDrawInfo, getInstantElements(refLinesModel, pdKey), function(element) {
				return 'normal';
			}, renderPass, role);
		},
		$renderReferenceLineElements: function PaneTable2DRenderer$RenderReferenceLineElements(pdi, elements, getVisualState, pass, role) {
			for (var $t1 = 0; $t1 < elements.length; $t1++) {
				var refLine = elements[$t1];
				this.$referenceLinesRenderer.renderReferenceLines(refLine, getVisualState, pdi, pass, role);
			}
		},
		$hasSemanticModelInstantRefLines: function PaneTable2DRenderer$HasSemanticModelInstantRefLines(visualPart, paneDrawInfo) {
			return (visualPart === 'ref-lines' || visualPart === 'ref-bands') && ss.isValue(this.$sceneInfo.get_referenceLines()) && ss.isValue(paneDrawInfo) && this.$sceneInfo.get_referenceLines().getInstantRefLines(paneDrawInfo.get_paneDescriptorKey()).length > 0;
		}
	}, tab.CanvasRenderer);
	ss.initClass($tab_PaneTableCanvasView, $asm, {
		get_$paneTableVM: function PaneTableCanvasView$get_PaneTableVM() {
			return this.get_viewModel();
		},
		get_$paneTableRenderer: function PaneTableCanvasView$get_PaneTableRenderer() {
			return ss.cast(this.renderer, $tab_PaneTable2DRenderer);
		},
		get_isContentOpaque: function PaneTableCanvasView$get_IsContentOpaque() {
			return !this.get_$paneTableVM().get_mapServerModel().get_useFastMaps();
		},
		get_backgroundFillColor: function PaneTableCanvasView$get_BackgroundFillColor() {
			return this.get_$paneTableVM().get_visualModel().get_backgroundColor();
		},
		performRender: function PaneTableCanvasView$PerformRender() {
			var extraInfo = 'viz: ' + this.get_$paneTableVM().get_sheetId();
			{
				var mc = tabBootstrap.MetricsController.createContext('RNDRPT'.toString(), 16, extraInfo);
				try {
					this.renderer.clear();
					this.get_$paneTableRenderer().renderScene(this.get_$paneTableVM());
				}
				finally {
					if (ss.isValue(mc)) {
						mc.dispose();
					}
				}
			}
		},
		onViewModelPropertyChanged: function PaneTableCanvasView$OnViewModelPropertyChanged(sender, e) {
			if (ss.referenceEquals(e.get_propertyName(), $tab_PaneTableViewModel.borderHighlightPropertyName)) {
				return;
			}
			var invalidRects = this.get_$paneTableVM().getAndClearInvalidationRects();
			if (invalidRects.length === 0) {
				this.invalidate(false);
			}
			else {
				var unionRect = tab.RectXYUtil.unionAll(invalidRects);
				var Slop = 3;
				tab.RectXYUtil.outsetRectInPlace(unionRect, Slop, Slop);
				tab.RectXYUtil.offsetRectXYInPlace(unionRect, -this.get_scrollPos().x, -this.get_scrollPos().y);
				this.invalidateRect(unionRect, false);
			}
		},
		postRenderFinalPass: function PaneTableCanvasView$PostRenderFinalPass() {
			this.get_$paneTableRenderer().renderViewportBorders(this.get_$paneTableVM());
			this.get_$paneTableRenderer().renderAxisRulers(this.get_$paneTableVM(), this.get_docSize(), this.get_scrollPos());
		}
	}, ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_PaneTableViewModel]), [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [$tab_PaneTableViewModel]), spiff.IScrollable, tab.IRegionContentProvider]);
	ss.initClass($tab_PaneTableGeometryArgCache, $asm, {
		update: function PaneTableGeometryArgCache$Update(newArgs) {
			var geometryIsCached = ss.isValue(this.$lastArgs) && _.isEqual(newArgs, this.$lastArgs);
			if (!geometryIsCached) {
				this.$lastArgs = newArgs;
			}
			return geometryIsCached;
		},
		clear: function PaneTableGeometryArgCache$Clear() {
			this.$lastArgs = null;
		}
	});
	ss.initClass($tab_PaneTableGeometryBundle, $asm, {
		get_regionGeometry: function PaneTableGeometryBundle$get_RegionGeometry() {
			return this.$1$RegionGeometryField;
		},
		set_regionGeometry: function PaneTableGeometryBundle$set_RegionGeometry(value) {
			this.$1$RegionGeometryField = value;
		},
		get_visibleGeometry: function PaneTableGeometryBundle$get_VisibleGeometry() {
			return this.$1$VisibleGeometryField;
		},
		set_visibleGeometry: function PaneTableGeometryBundle$set_VisibleGeometry(value) {
			this.$1$VisibleGeometryField = value;
		},
		get_geometryWithRegions: function PaneTableGeometryBundle$get_GeometryWithRegions() {
			return this.$1$GeometryWithRegionsField;
		},
		set_geometryWithRegions: function PaneTableGeometryBundle$set_GeometryWithRegions(value) {
			this.$1$GeometryWithRegionsField = value;
		}
	});
	ss.initClass($tab_PaneTableGeometryComputer, $asm, {});
	ss.initClass($tab_PaneTableOverlayView, $asm, {
		get_paneTableVM: function PaneTableOverlayView$get_PaneTableVM() {
			return this.get_viewModel();
		},
		get_lastTargetState: function PaneTableOverlayView$get_LastTargetState() {
			return this.$lastTargetState;
		},
		get_backgroundFillColor: function PaneTableOverlayView$get_BackgroundFillColor() {
			return this.get_paneTableVM().get_visualModel().get_backgroundColor();
		},
		clearOverlays: function PaneTableOverlayView$ClearOverlays() {
			this.$emptyHoverOverlays();
			this.$emptyPressedOverlays();
			this.$emptyDragOverlays();
			this.$checkInvalidArea();
			this.$timedOut = false;
		},
		hoverOverWhitespace: function PaneTableOverlayView$HoverOverWhitespace() {
			this.$hasTargetBeenPressed = false;
		},
		setScrollPosition: function PaneTableOverlayView$SetScrollPosition(scrollPoint) {
			this.set_scrollPos(scrollPoint);
			this.$dirtyDragRects = [];
			this.invalidate(true);
		},
		setDragOverlayTuples: function PaneTableOverlayView$SetDragOverlayTuples(tuples) {
			$tab_PaneTableOverlayView.$checkArrayIsSorted(tuples);
			this.$emptyHoverOverlays();
			this.$emptyPressedOverlays();
			this.$checkInvalidArea();
			if (this.$timedOut) {
				return;
			}
			this.$pendingDragTuples = tuples;
			var changedTuples = $tab_PaneTableOverlayView.$computeTupleDifference(this.$dragTuples, tuples);
			var tupleCount = changedTuples.length;
			if (tupleCount > 0) {
				var markRects = [];
				for (var markIndex = 0; markIndex < tupleCount; markIndex++) {
					var tuple = changedTuples[markIndex];
					var bboxes = this.$getInvalidRectsForMark(tuple);
					markRects.push(bboxes);
				}
				var shapeSelector = this.$vizRegion.get_shapeSelector();
				this.$selectorShapeState = shapeSelector.retrieveStateObject(this.$selectorShapeState);
				var changedRects = shapeSelector.getStateDiff(this.$selectorShapeState);
				var changeCount = changedRects.length;
				var handledMarks = new Set();
				var dirtyRects = new Array(changeCount);
				for (var i = 0; i < changeCount; i++) {
					var changeRect = changedRects[i];
					var dirtyRect = { x: 0, y: 0, w: 0, h: 0 };
					for (var markIndex1 = 0; markIndex1 < tupleCount; markIndex1++) {
						if (handledMarks.has(markIndex1)) {
							continue;
						}
						var markInstanceRects = markRects[markIndex1];
						if (tab.RectXYUtil.intersectsWithAny(changeRect, markInstanceRects)) {
							dirtyRect = tab.RectXYUtil.union(tab.RectXYUtil.unionAll(markInstanceRects), dirtyRect);
							handledMarks.add(markIndex1);
						}
					}
					dirtyRects[i] = (tab.RectXYUtil.isEmpty(dirtyRect) ? dirtyRect : tab.RectXYUtil.outsetRect(dirtyRect, $tab_PaneTableOverlayView.$dirtyRectPadding, $tab_PaneTableOverlayView.$dirtyRectPadding));
				}
				dirtyRects = tab.RectXYUtil.reduceRectangles(dirtyRects);
				this.$dirtyDragRects = dirtyRects;
				if ($tab_PaneTableOverlayView.$debugMode) {
					this.invalidate(false);
				}
				var totalDirtyRect = tab.RectXYUtil.unionAll(dirtyRects);
				totalDirtyRect = tab.RectXYUtil.offsetRect(totalDirtyRect, { x: -this.get_scrollPos().x, y: -this.get_scrollPos().y });
				this.invalidateRect(totalDirtyRect, true);
			}
			else {
				this.$dirtyDragRects = [];
				this.clearDirty();
				this.$pendingDragTuples = null;
			}
		},
		setHoverOverlayTarget: function PaneTableOverlayView$SetHoverOverlayTarget(target, targetType) {
			this.$lastTargetState = 'hover';
			if (!this.$hoverTarget.$isSameTarget(target, targetType)) {
				this.$hasTargetBeenPressed = false;
			}
			if (this.$hoverTarget.$isSameValidTarget(target, targetType) || ss.isValue(this.$dragTuples) && this.$dragTuples.length > 0) {
				return false;
			}
			this.$clearExistingOverlays();
			var invalidRectsForTarget = this.$getInvalidRectsForTarget(target, targetType);
			this.$invalidateRects(invalidRectsForTarget);
			this.$hoverTarget.$update(target, targetType, invalidRectsForTarget);
			this.$redrawInvalidArea();
			return true;
		},
		setPressedOverlayTarget: function PaneTableOverlayView$SetPressedOverlayTarget(target, targetType) {
			this.$hasTargetBeenPressed = true;
			this.$lastTargetState = 'press';
			if (this.$pressTarget.$isSameValidTarget(target, targetType)) {
				return false;
			}
			this.$clearExistingOverlays();
			var invalidRectsForTarget = this.$getInvalidRectsForTarget(target, targetType);
			this.$invalidateRects(invalidRectsForTarget);
			this.$pressTarget.$update(target, targetType, invalidRectsForTarget);
			this.$redrawInvalidArea();
			return true;
		},
		$onSceneChanged: function PaneTableOverlayView$OnSceneChanged(sender, e) {
			if (ss.referenceEquals(e.get_propertyName(), $tab_PaneTableViewModel.sceneChangedPropertyName)) {
				this.$validateTupleStates();
			}
		},
		performRender: function PaneTableOverlayView$PerformRender() {
			var mc = tabBootstrap.MetricsController.createContext('Render Overlay Panetable', 32, null);
			{
				if (this.$dirtyDragRects.length > 0 || ss.isValue(this.$dragTuples) && this.$dragTuples.length > 0) {
					this.$renderDragOverlays();
				}
				else {
					this.renderer.clear();
					var dirtyAreaRect = tab.RectXYUtil.offsetRect(this.get_dirtyRect(), { x: this.get_scrollPos().x, y: this.get_scrollPos().y });
					if (this.$hoverTarget.get_$hasValidTupleId()) {
						if (this.$hoverTarget.$targetType === 'mark') {
							var paneDrawInfo = this.get_paneTableVM().get_scene().getPaneDrawInfoFromTupleId(this.$hoverTarget.get_$id());
							if (!ss.isNullOrUndefined(paneDrawInfo)) {
								this.$clipAndTranslateForMark(this.$hoverTarget.get_$id(), paneDrawInfo, dirtyAreaRect);
								$tab_PaneTable2DRenderer.renderHoverOverlay(this.$hoverTarget.get_$id(), paneDrawInfo, this.context);
							}
						}
						else {
							this.$renderReferenceLine(this.$hoverTarget);
							this.$renderVisualPart(this.$hoverTarget);
						}
					}
					else if (this.$pressTarget.get_$hasValidTupleId()) {
						if (this.$pressTarget.$targetType === 'mark') {
							var paneDrawInfo1 = this.get_paneTableVM().get_scene().getPaneDrawInfoFromTupleId(this.$pressTarget.get_$id());
							if (!ss.isNullOrUndefined(paneDrawInfo1)) {
								this.$clipAndTranslateForMark(this.$pressTarget.get_$id(), paneDrawInfo1, dirtyAreaRect);
								$tab_PaneTable2DRenderer.renderPressedOverlay(this.$pressTarget.get_$id(), paneDrawInfo1, this.context);
							}
						}
						else {
							this.$renderReferenceLine(this.$pressTarget);
							this.$renderVisualPart(this.$pressTarget);
						}
					}
				}
			}
			mc.dispose();
		},
		$clipAndTranslateForUserPane$1: function PaneTableOverlayView$ClipAndTranslateForUserPane(userPaneRect, paneDrawInfo, dirtyAreaRect) {
			var clipRect = tab.RectXYUtil.offsetRectXY(userPaneRect, paneDrawInfo.paneRect.x, paneDrawInfo.paneRect.y);
			var mapRect = paneDrawInfo.mapExtents;
			if (ss.isValue(mapRect)) {
				tab.RectXYUtil.intersectInPlace(clipRect, mapRect);
			}
			tab.RectXYUtil.intersectInPlace(clipRect, dirtyAreaRect);
			this.context.setClip(clipRect);
			this.context.translate(paneDrawInfo.paneRect.x, paneDrawInfo.paneRect.y);
		},
		$clipAndTranslateForMark: function PaneTableOverlayView$ClipAndTranslateForMark(tupleId, paneDrawInfo, dirtyAreaRect) {
			var userPaneRect = paneDrawInfo.getUserPaneRectByTupleId(tupleId);
			this.$clipAndTranslateForUserPane$1(userPaneRect, paneDrawInfo, dirtyAreaRect);
		},
		$clipAndTranslateForUserPane: function PaneTableOverlayView$ClipAndTranslateForUserPane(userPaneIndex, paneDrawInfo, dirtyAreaRect) {
			var userPaneRect = paneDrawInfo.getUserPaneRectByIndex(userPaneIndex);
			this.$clipAndTranslateForUserPane$1(userPaneRect, paneDrawInfo, dirtyAreaRect);
		},
		$renderDragOverlays: function PaneTableOverlayView$RenderDragOverlays() {
			var CountUntilTimeCheck = 75;
			var renderStart = (new Date()).getTime();
			if (ss.isNullOrUndefined(this.$pendingDragTuples)) {
				this.$pendingDragTuples = this.$dragTuples;
			}
			if (this.$dirtyDragRects.length === 0) {
				var visibleRect = { x: this.get_scrollPos().x, y: this.get_scrollPos().y, w: this.get_effectiveViewSize().w, h: this.get_effectiveViewSize().h };
				this.$dirtyDragRects.push(visibleRect);
			}
			if (this.$pendingDragTuples.length === 0) {
				this.renderer.clear();
				return;
			}
			if ($tab_PaneTableOverlayView.$debugMode) {
				this.renderer.clear();
			}
			var tuplesNeedingDraw = {};
			var paneDrawInfos = {};
			var boundingBoxes = {};
			var scene = this.get_paneTableVM().get_scene();
			for (var $t1 = 0; $t1 < this.$pendingDragTuples.length; $t1++) {
				var tuple = this.$pendingDragTuples[$t1];
				var paneDrawInfo = scene.getPaneDrawInfoFromTupleId(tuple);
				var paneDrawInfoKey = paneDrawInfo.paneDrawInfoKey;
				tuplesNeedingDraw[paneDrawInfoKey] = ss.coalesce(tuplesNeedingDraw[paneDrawInfoKey], new Set());
				tuplesNeedingDraw[paneDrawInfoKey].add(tuple);
				paneDrawInfos[paneDrawInfoKey] = paneDrawInfo;
				var bbox = scene.getMarkBoundingBox(tuple);
				var bboxes = paneDrawInfo.getWorldOffsetBounds(bbox);
				boundingBoxes[tuple] = bboxes;
			}
			var countSinceTimeCheck = 0;
			var rectCount = this.$dirtyDragRects.length;
			for (var i = 0; i < rectCount; i++) {
				var dirtyAreaRect = this.$dirtyDragRects[i];
				this.context.clearRect(dirtyAreaRect.x, dirtyAreaRect.y, dirtyAreaRect.w, dirtyAreaRect.h);
				if ($tab_PaneTableOverlayView.$debugMode) {
					this.context.set_strokeStyle('rgb(255,0,0)');
					this.context.strokeRect(dirtyAreaRect.x, dirtyAreaRect.y, dirtyAreaRect.w, dirtyAreaRect.h);
				}
				var $t2 = new ss.ObjectEnumerator(tuplesNeedingDraw);
				try {
					while ($t2.moveNext()) {
						var paneTuples = $t2.current();
						var paneDrawInfo1 = paneDrawInfos[paneTuples.key];
						var clipRect = tab.RectXYUtil.intersect(dirtyAreaRect, paneDrawInfo1.get_mapExtentOrPaneRect());
						if (tab.RectXYUtil.isEmpty(clipRect)) {
							continue;
						}
						var clipSet = false;
						var hasUserPanes = paneDrawInfo1.hasUserPanes;
						var prevUserPane = -1;
						var timedout = false;
						var tupleIds = tab.SetUtilities.getValues(ss.Int32).call(null, paneTuples.value);
						for (var $t3 = 0; $t3 < tupleIds.length; $t3++) {
							var tuple1 = tupleIds[$t3];
							if (countSinceTimeCheck >= CountUntilTimeCheck) {
								if ((new Date()).getTime() - renderStart > 145) {
									timedout = true;
									break;
								}
								countSinceTimeCheck = 0;
							}
							++countSinceTimeCheck;
							if (!tab.RectXYUtil.intersectsWithAny(clipRect, boundingBoxes[tuple1])) {
								continue;
							}
							var userPaneIndex = 0;
							if (hasUserPanes) {
								userPaneIndex = paneDrawInfo1.getUserPaneIndexByMark(paneDrawInfo1.getMarkIndexFromTupleId(tuple1));
								if (userPaneIndex !== prevUserPane) {
									if (clipSet) {
										this.context.restore();
										clipSet = false;
									}
									prevUserPane = userPaneIndex;
								}
							}
							if (!clipSet) {
								this.context.save();
								this.$clipAndTranslateForUserPane(userPaneIndex, paneDrawInfo1, dirtyAreaRect);
								clipSet = true;
							}
							$tab_PaneTable2DRenderer.renderHoverOverlay(tuple1, paneDrawInfo1, this.context);
						}
						if (clipSet) {
							this.context.restore();
						}
						if (timedout) {
							this.$timedOut = true;
							this.renderer.clear();
							return;
						}
					}
				}
				finally {
					$t2.dispose();
				}
			}
		},
		$renderVisualPart: function PaneTableOverlayView$RenderVisualPart(targetObject) {
			var analyticLines = [];
			if (targetObject.get_$targetState() === 'hover' && tsConfig.is_authoring) {
				switch (targetObject.$targetType) {
					case 'ref-line': {
						analyticLines = this.get_paneTableVM().get_refLineVisualLists();
						break;
					}
					case 'trend-line': {
						analyticLines = this.get_paneTableVM().get_trendLineVisualLists();
						break;
					}
				}
			}
			for (var $t1 = 0; $t1 < analyticLines.length; $t1++) {
				var analyticLine = analyticLines[$t1];
				var lineItems = [];
				ss.arrayAddRange(lineItems, analyticLine.drawItems);
				this.$renderDrawItems(lineItems, targetObject);
			}
		},
		$renderReferenceLine: function PaneTableOverlayView$RenderReferenceLine(targetObject) {
			if (targetObject.$targetType === 'semantic-ref-line' && targetObject.get_$targetState() === 'hover' && tsConfig.is_authoring) {
				if (this.$hasTargetBeenPressed && this.get_paneTableVM().get_scene().selections.refLineSelection.isObjectSelected(targetObject.get_$id())) {
					return;
				}
				var refLines = this.get_paneTableVM().get_scene().get_referenceLines().getRefLineById(targetObject.get_$id());
				var paneDrawInfos = this.$gatherPaneDrawInfos();
				for (var $t1 = 0; $t1 < paneDrawInfos.length; $t1++) {
					var pdi = paneDrawInfos[$t1];
					for (var $t2 = 0; $t2 < refLines.length; $t2++) {
						var refLine = refLines[$t2];
						this.$referenceLinesRenderer.renderOverlay(refLine, pdi);
					}
				}
			}
		},
		$gatherPaneDrawInfos: function PaneTableOverlayView$GatherPaneDrawInfos() {
			var paneDrawInfos = [];
			var panes = this.get_paneTableVM().get_scene().get_runtimeData().safeFetchMarkPanes();
			for (var $t1 = 0; $t1 < panes.length; $t1++) {
				var pane = panes[$t1];
				var paneDrawInfo = this.get_paneTableVM().get_scene().getPaneDrawInfoAssociatedWithPane(pane);
				if (ss.isValue(paneDrawInfo)) {
					paneDrawInfos.push(paneDrawInfo);
				}
			}
			return paneDrawInfos;
		},
		$renderDrawItems: function PaneTableOverlayView$RenderDrawItems(items, targetObject) {
			var targetState = targetObject.get_$targetState();
			var objectId = targetObject.get_$id();
			this.context.save();
			var rend = ss.cast(this.renderer, $tab_PaneTable2DRenderer);
			var $t1 = ss.getEnumerator(items);
			try {
				while ($t1.moveNext()) {
					var item = $t1.current();
					if (item.type === 'draw-group') {
						var drawGroup = item;
						var shouldDrawItem = true;
						if (this.$hasTargetBeenPressed) {
							switch (targetObject.$targetType) {
								case 'ref-line': {
									shouldDrawItem = !this.get_paneTableVM().get_scene().selections.refLineSelection.isObjectSelected(drawGroup.objectId);
									break;
								}
								case 'trend-line': {
									shouldDrawItem = !this.get_paneTableVM().get_scene().selections.trendLineSelection.isObjectSelected(drawGroup.objectId);
									break;
								}
							}
						}
						if (shouldDrawItem) {
							rend.drawReferenceLineAndTrendLineGroup(drawGroup.drawItems, targetState, this.context, objectId === drawGroup.objectId, null);
						}
					}
					else {
						rend.renderVisualParts(this.context, item);
					}
				}
			}
			finally {
				$t1.dispose();
			}
			this.context.restore();
		},
		postRenderFinalPass: function PaneTableOverlayView$PostRenderFinalPass() {
		},
		redrawFinished: function PaneTableOverlayView$RedrawFinished() {
			this.$dragTuples = this.$pendingDragTuples;
			this.$pendingDragTuples = null;
			this.$vizRegion.get_shapeSelector().updateLastState(this.$selectorShapeState);
			this.$dirtyDragRects = [];
			if (this.$timedOut) {
				this.$emptyDragOverlays();
			}
		},
		$redrawInvalidArea: function PaneTableOverlayView$RedrawInvalidArea() {
			if (this.$hasInvalidAreas || tab.MiscUtil.isNullOrEmpty$1(this.$invalidRects)) {
				this.$hasInvalidAreas = false;
				this.invalidate(true);
			}
			else {
				var unionRect = tab.RectXYUtil.unionAll(this.$invalidRects);
				ss.clear(this.$invalidRects);
				var offset = { x: -this.get_scrollPos().x, y: -this.get_scrollPos().y };
				unionRect = tab.RectXYUtil.offsetRect(unionRect, offset);
				unionRect = tab.RectXYUtil.outsetRect(unionRect, $tab_PaneTableOverlayView.$dirtyRectPadding, $tab_PaneTableOverlayView.$dirtyRectPadding);
				this.invalidateRect(unionRect, true);
			}
		},
		$checkInvalidArea: function PaneTableOverlayView$CheckInvalidArea() {
			if (this.$hasInvalidAreas || !tab.MiscUtil.isNullOrEmpty$1(this.$invalidRects)) {
				this.$redrawInvalidArea();
			}
		},
		$validateTupleStates: function PaneTableOverlayView$ValidateTupleStates() {
			if (!this.$isTargetObjectValidForOverlay(this.$hoverTarget)) {
				this.$hoverTarget.$invalidateId();
			}
			if (!this.$isTargetObjectValidForOverlay(this.$pressTarget)) {
				this.$pressTarget.$invalidateId();
			}
			if (ss.isValue(this.$dragTuples)) {
				var tuples = new Set();
				for (var $t1 = 0; $t1 < this.$dragTuples.length; $t1++) {
					var tupleId = this.$dragTuples[$t1];
					if (this.$isTupleValidForOverlay(tupleId)) {
						tuples.add(tupleId);
					}
				}
				this.$dragTuples = tab.SetUtilities.getValues(ss.Int32).call(null, tuples);
			}
		},
		$isTargetObjectValidForOverlay: function PaneTableOverlayView$IsTargetObjectValidForOverlay(targetObject) {
			if (!targetObject.get_$hasValidTupleId()) {
				return false;
			}
			switch (targetObject.$targetType) {
				case 'mark': {
					return this.$isTupleValidForOverlay(targetObject.get_$id());
				}
				case 'ref-line': {
					return this.$isVisualPartValidForOverlay(this.get_paneTableVM().get_refLineVisualLists(), targetObject.get_$id());
				}
				case 'trend-line': {
					return this.$isVisualPartValidForOverlay(this.get_paneTableVM().get_trendLineVisualLists(), targetObject.get_$id());
				}
				case 'unspecified':
				default: {
					return false;
				}
			}
		},
		$isTupleValidForOverlay: function PaneTableOverlayView$IsTupleValidForOverlay(tupleId) {
			var vizData = this.get_paneTableVM().get_visualModel().get_vizDataModel();
			var sceneInfo = this.get_paneTableVM().get_scene();
			return ss.isValue(vizData) && vizData.hasTupleId(tupleId) && !sceneInfo.isMarkFiltered(tupleId);
		},
		$isVisualPartValidForOverlay: function PaneTableOverlayView$IsVisualPartValidForOverlay(visualLists, objectId) {
			for (var $t1 = 0; $t1 < visualLists.length; $t1++) {
				var vlpm = visualLists[$t1];
				var drawItems = vlpm.drawItems;
				for (var $t2 = 0; $t2 < drawItems.length; $t2++) {
					var drawItem = drawItems[$t2];
					if (drawItem.objectId === objectId) {
						return true;
					}
				}
			}
			return false;
		},
		$clearExistingOverlays: function PaneTableOverlayView$ClearExistingOverlays() {
			this.$emptyHoverOverlays();
			this.$emptyPressedOverlays();
			this.$emptyDragOverlays();
		},
		$getInvalidRectsForTarget: function PaneTableOverlayView$GetInvalidRectsForTarget(targetId, targetType) {
			if (targetType === 'mark') {
				return this.$getInvalidRectsForMark(targetId);
			}
			else {
				return null;
			}
		},
		$invalidateRects: function PaneTableOverlayView$InvalidateRects(rectsToAdd) {
			if (ss.isNullOrUndefined(rectsToAdd)) {
				this.$hasInvalidAreas = true;
				ss.clear(this.$invalidRects);
				return;
			}
			for (var $t1 = 0; $t1 < rectsToAdd.length; $t1++) {
				var rect = rectsToAdd[$t1];
				this.$invalidRects.push(rect);
			}
		},
		$getInvalidRectsForMark: function PaneTableOverlayView$GetInvalidRectsForMark(tupleId) {
			var scene = this.get_paneTableVM().get_scene();
			var markRect = scene.getMarkBoundingBox(tupleId);
			var paneDrawInfo = scene.getPaneDrawInfoFromTupleId(tupleId);
			var boundingBoxes = paneDrawInfo.getWorldOffsetBounds(markRect);
			return boundingBoxes;
		},
		$emptyHoverOverlays: function PaneTableOverlayView$EmptyHoverOverlays() {
			if (this.$hoverTarget.get_$hasValidTupleId()) {
				this.$invalidateRects(this.$hoverTarget.get_$invalidationRects());
				this.$hoverTarget.$invalidateId();
			}
		},
		$emptyPressedOverlays: function PaneTableOverlayView$EmptyPressedOverlays() {
			if (this.$pressTarget.get_$hasValidTupleId()) {
				this.$invalidateRects(this.$hoverTarget.get_$invalidationRects());
				this.$pressTarget.$invalidateId();
			}
		},
		$emptyDragOverlays: function PaneTableOverlayView$EmptyDragOverlays() {
			if (ss.isValue(this.$dragTuples)) {
				for (var $t1 = 0; $t1 < this.$dragTuples.length; $t1++) {
					var tuple = this.$dragTuples[$t1];
					ss.arrayAddRange(this.$invalidRects, this.$getInvalidRectsForMark(tuple));
				}
				this.$dragTuples = null;
			}
			this.$pendingDragTuples = null;
			this.$dirtyDragRects = [];
			this.$selectorShapeState = null;
		}
	}, ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_PaneTableViewModel]), [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [$tab_PaneTableViewModel]), spiff.IScrollable, tab.IRegionContentProvider]);
	ss.initClass($tab_PaneTableTemplate, $asm, {}, spiff.Template, [ss.IDisposable]);
	ss.initClass($tab_PaneTableView, $asm, {
		get_zoomToolbarContainerDiv: function PaneTableView$get_ZoomToolbarContainerDiv() {
			return this.dom.view.get(0);
		},
		get_isMapSearchEnabled: function PaneTableView$get_IsMapSearchEnabled() {
			return this.get_paneTableVM().get_mapSearchEnabled();
		},
		get_shouldEnableZoomHomeToolbar: function PaneTableView$get_ShouldEnableZoomHomeToolbar() {
			return this.get_paneTableVM().shouldEnableZoomHomeToolbar();
		},
		get_geometryBundle: function PaneTableView$get_GeometryBundle() {
			return this.$3$GeometryBundleField;
		},
		set_geometryBundle: function PaneTableView$set_GeometryBundle(value) {
			this.$3$GeometryBundleField = value;
		},
		get_geometry: function PaneTableView$get_Geometry() {
			return this.get_geometryBundle().get_geometryWithRegions();
		},
		get_visibleGeometry: function PaneTableView$get_VisibleGeometry() {
			return this.get_geometryBundle().get_visibleGeometry();
		},
		get_vizHitTestDebouncer: function PaneTableView$get_VizHitTestDebouncer() {
			return this.$3$VizHitTestDebouncerField;
		},
		set_vizHitTestDebouncer: function PaneTableView$set_VizHitTestDebouncer(value) {
			this.$3$VizHitTestDebouncerField = value;
		},
		get_sortIndicators: function PaneTableView$get_SortIndicators() {
			return this.get_paneTableVM().get_sortIndicators();
		},
		get_axisRegions: function PaneTableView$get_AxisRegions() {
			return this.get_paneTableVM().get_axisRegions();
		},
		get_tableViewPosition: function PaneTableView$get_TableViewPosition() {
			return tab.PointUtil.fromPosition(this.dom.domRoot.offset());
		},
		get_sheetid: function PaneTableView$get_Sheetid() {
			return this.get_paneTableVM().get_sheetId();
		},
		get_session: function PaneTableView$get_Session() {
			return this.get_controller().get_viewSession();
		},
		get_numColumns: function PaneTableView$get_NumColumns() {
			return (ss.isValue(this.get_geometry()) ? this.get_geometry().pi.xWidths.length : 0);
		},
		get_numRows: function PaneTableView$get_NumRows() {
			return (ss.isValue(this.get_geometry()) ? this.get_geometry().pi.yHeights.length : 0);
		},
		get_paneSize: function PaneTableView$get_PaneSize() {
			var width = ((this.get_numColumns() > 0) ? this.get_geometry().pi.xWidths[0] : 0);
			var height = ((this.get_numRows() > 0) ? this.get_geometry().pi.yHeights[0] : 0);
			return { w: width, h: height };
		},
		get_scrollPosition: function PaneTableView$get_ScrollPosition() {
			return this.$scrollPos;
		},
		set_scrollPosition: function PaneTableView$set_ScrollPosition(value) {
			this.$scrollPos = value;
			this.$setOverlayScrollPosition(this.$scrollPos);
			this.$updateMapAttributionPlacement();
		},
		get_controller: function PaneTableView$get_Controller() {
			var pvm = this.get_paneTableVM();
			var controller = pvm.get_viewController();
			return controller;
		},
		get_visualId: function PaneTableView$get_VisualId() {
			return this.get_paneTableVM().get_visualId();
		},
		get_isSameVisualID: function PaneTableView$get_IsSameVisualID() {
			return ss.referenceEquals(this.get_visualId(), this.vizTooltip.get_visualIDPresModel());
		},
		get_paneTableVM: function PaneTableView$get_PaneTableVM() {
			return this.get_viewModel();
		},
		get_vizToolTip: function PaneTableView$get_VizToolTip() {
			this.$ensureTooltip();
			return this.vizTooltip;
		},
		get_tooltipMode: function PaneTableView$get_TooltipMode() {
			return this.get_paneTableVM().get_visualModel().get_tooltipMode();
		},
		get_mapToolSelectionMode: function PaneTableView$get_MapToolSelectionMode() {
			return this.get_paneTableVM().get_visualModel().get_defaultMapTool();
		},
		get_isTooltipAllowed: function PaneTableView$get_IsTooltipAllowed() {
			return ss.isNullOrUndefined(tsConfig.allow_tooltip) || tsConfig.allow_tooltip;
		},
		get_vizRegion: function PaneTableView$get_VizRegion() {
			return this.regions['viz'];
		},
		set_vizRegion: function PaneTableView$set_VizRegion(value) {
			this.regions['viz'] = value;
		},
		get_vizRegionDomNode: function PaneTableView$get_VizRegionDomNode() {
			return this.dom.view.children().first();
		},
		get_zoomToolbarOffset: null,
		get_zoomToolbarOperations: null,
		get_shouldDisablePanTool: function PaneTableView$get_ShouldDisablePanTool() {
			return this.get_paneTableVM().get_visualModel().get_vizNavigationSetting() === 'fixed';
		},
		get_shouldShowTools: function PaneTableView$get_ShouldShowTools() {
			var shouldShowBasedOnVisibilitySetting = this.get_paneTableVM().get_visualModel().get_floatingToolbarVisibility() === 'show' || this.get_paneTableVM().get_visualModel().get_floatingToolbarVisibility() === 'auto' && this.allowPanZoomActions();
			return shouldShowBasedOnVisibilitySetting;
		},
		get_geometryArgCache: function PaneTableView$get_GeometryArgCache() {
			return this.$geometryArgCache;
		},
		init: function PaneTableView$Init() {
			this.$makeSubscriptions();
			this.makeConnections();
			this.makeRegions();
			this.initEventHandlers();
			this.makeRegionContentProviders();
			this.set_vizHitTestDebouncer(tab.MiscUtil.dispose$1(this.get_vizHitTestDebouncer()));
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				this.set_vizHitTestDebouncer(new $tab_LocalRenderVizHitTestDebouncer(this, this.get_vizRegion(), this.get_paneTableVM().get_localRenderVizHitTester()));
			}
			else {
				this.set_vizHitTestDebouncer(new $tab_ServerRenderVizHitTestDebouncer(this, this.get_vizRegion()));
			}
		},
		dispose: function PaneTableView$Dispose() {
			tab.Log.get(this).debug('Dispose', []);
			this.$hasBeenDisposed = true;
			if (ss.isValue(this.get_vizHitTestDebouncer())) {
				this.get_vizHitTestDebouncer().dispose();
			}
			this.destroyInputHandlers();
			this.destroyRegions();
			this.disposables.dispose();
			this.disposeOfOverlays();
			if (ss.isValue(this.get_paneTableVM())) {
				this.get_paneTableVM().remove_vizRegionMapChange(ss.mkdel(this, this.$updateRegionContentProviders));
			}
			this.floatingZoomToolbarView.dispose();
			if (ss.isValue(this.$titleView)) {
				this.$titleView.dispose();
			}
			if (ss.isValue(this.$captionView)) {
				this.$captionView.dispose();
			}
			if (ss.isValue(this.$mapAttribution)) {
				this.$mapAttribution.dispose();
			}
			if (ss.isValue(this.$mapScaleView)) {
				this.$mapScaleView.dispose();
			}
			if (ss.isValue(this.vizTooltip)) {
				this.vizTooltip.remove_tooltipClosed(ss.mkdel(this, this.onTooltipClosed));
				this.vizTooltip.remove_ubertipUpdated(ss.mkdel(this, this.maybeShowOverlayImages));
				this.vizTooltip.remove_ubertipCommandExecuted(ss.mkdel(this, this.onCommandExecuted));
				this.vizTooltip.remove_ubertipActionExecuted(ss.mkdel(this, this.onActionExecuted));
				this.vizTooltip.dispose();
			}
			if (ss.isValue(this.$overlayTableView)) {
				this.get_paneTableVM().remove_propertyChanged(ss.mkdel(this.$overlayTableView, this.$overlayTableView.$onSceneChanged));
				this.$overlayTableView.dispose();
			}
			if (ss.isValue(this.mapsSearchView)) {
				this.mapsSearchView.dispose();
			}
			ss.makeGenericType(spiff.BaseView$1, [tab.IPaneTableViewModel]).prototype.dispose.call(this);
		},
		$executeAsyncDragOverrides: function PaneTableView$ExecuteAsyncDragOverrides(enumerator, pseudoEvent, result) {
			if (enumerator.moveNext() && !ss.staticEquals(enumerator.current(), null)) {
				enumerator.current()(this, pseudoEvent).done(ss.mkdel(this, function(success) {
					if (success) {
						result.resolve(true);
						return;
					}
					this.$executeAsyncDragOverrides(enumerator, pseudoEvent, result);
				}));
			}
			else {
				result.resolve(false);
			}
		},
		initEventHandlers: function PaneTableView$InitEventHandlers() {
			this.$attachStaticEventHandlers();
			this.makeInputHandlers();
			this.setupDrilling();
			this.setupSortIndicators();
			this.setupAxisContextMenuIndicator();
			this.refreshScrollingAndAxisIcons();
		},
		callAsyncVizDragHandlers: function PaneTableView$CallAsyncVizDragHandlers(pseudoEvent, defaultAction) {
			var result = $.Deferred();
			this.$executeAsyncDragOverrides(ss.getEnumerator($tab_PaneTableView.$asyncVizDragHandlers), pseudoEvent, result);
			result.done(ss.mkdel(this, function(success) {
				if (success) {
					this.get_vizToolTip().close();
					return;
				}
				defaultAction(pseudoEvent);
			}));
		},
		callVizDragHandlers: function PaneTableView$CallVizDragHandlers(pseudoEvent, defaultAction) {
			for (var i = 0; i < $tab_PaneTableView.$vizDragHandlers.length; i++) {
				if ($tab_PaneTableView.$vizDragHandlers[i](this, pseudoEvent)) {
					this.get_vizToolTip().close();
					return;
				}
			}
			defaultAction(pseudoEvent);
		},
		getVizDragApproval: function PaneTableView$GetVizDragApproval(hitTest) {
			if (ss.isValue(hitTest)) {
				for (var i = 0; i < $tab_PaneTableView.$vizDragApprovers.length; i++) {
					if ($tab_PaneTableView.$vizDragApprovers[i](hitTest)) {
						return true;
					}
				}
			}
			return false;
		},
		zoomHome: function PaneTableView$ZoomHome() {
			tab.PanZoomCommands.requestRestoreFixedAxes(this.get_visualId());
			if (ss.isValue(this.mapsSearchView)) {
				this.get_paneTableVM().get_mapsSearchViewModel().collapseSearchWidget();
				this.get_paneTableVM().get_mapsSearchViewModel().restoreInitialTextInputValue();
			}
		},
		doTiledViewerRefreshImages: function PaneTableView$DoTiledViewerRefreshImages(tileCacheUrl) {
			this.refreshImages(tileCacheUrl);
		},
		setPointerToolMode: function PaneTableView$SetPointerToolMode(pointerToolMode, isLocked) {
			this.isPointerToolLocked = isLocked;
			if (this.isPointerToolLocked) {
				this.get_paneTableVM().get_vizRegionToolModeViewModel().setLockedPointerToolMode(pointerToolMode);
			}
			this.get_paneTableVM().get_vizRegionToolModeViewModel().setPointerToolMode(pointerToolMode);
		},
		defaultPointerToolMode: function PaneTableView$DefaultPointerToolMode() {
			if (ss.isValue(this.get_vizRegion())) {
				return this.get_paneTableVM().get_vizRegionToolModeViewModel().defaultPointerToolMode;
			}
			return 'rectangular-selection';
		},
		resetPointerToolMode: function PaneTableView$ResetPointerToolMode() {
			var toolbarModeReset = this.floatingZoomToolbarView.resetPointerToolbarMode();
			if (!toolbarModeReset && ss.isValue(this.get_vizRegion())) {
				this.get_paneTableVM().get_vizRegionToolModeViewModel().resetPointerToolMode();
			}
		},
		connectTooltipEventHandlers: function PaneTableView$ConnectTooltipEventHandlers() {
			var tooltip = this.get_vizToolTip();
			tooltip.add_tooltipClosed(ss.mkdel(this, this.onTooltipClosed));
			tooltip.add_ubertipUpdated(ss.mkdel(this, this.maybeShowOverlayImages));
			tooltip.add_ubertipCommandExecuted(ss.mkdel(this, this.onCommandExecuted));
			tooltip.add_ubertipActionExecuted(ss.mkdel(this, this.onActionExecuted));
		},
		updateRegionBackgroundColor: function PaneTableView$UpdateRegionBackgroundColor() {
			var vm = this.get_paneTableVM().get_visualModel();
			var colors = [vm.get_backgroundColor().toString(), vm.get_paneBGColor(), vm.get_headerBGColor()];
			if (ss.isValue(this.$cachedColors) && _.isEqual(this.$cachedColors, colors)) {
				return;
			}
			this.$cachedColors = colors;
			var serverRendered = !tab.ApplicationModel.get_instance().get_isLocalRenderMode();
			for (var $t1 = 0; $t1 < $tab_PaneTableViewRegionParts.contentRegions.length; $t1++) {
				var regionPart = $tab_PaneTableViewRegionParts.contentRegions[$t1];
				var domNode = this.regionParts.getSelectorForRegion(regionPart);
				if (ss.isNullOrUndefined(domNode)) {
					continue;
				}
				var backgroundColor = $tab_PaneTableView.$getRegionBackgroundColor(colors, regionPart);
				domNode.css('background-color', backgroundColor);
				if (serverRendered) {
					var imageContainer = $('.tvimagesContainer', domNode);
					imageContainer.css('background-color', backgroundColor);
				}
			}
			this.$updateCorners(colors[2]);
		},
		$updateCorners: function PaneTableView$UpdateCorners(color) {
			for (var $t1 = 0; $t1 < $tab_PaneTableViewRegionParts.spacerRegions.length; $t1++) {
				var regionPart = $tab_PaneTableViewRegionParts.spacerRegions[$t1];
				this.regionParts.getSelectorForRegion(regionPart).css('background-color', color);
			}
		},
		$makeRegionContentProvidersForServerRender: function PaneTableView$MakeRegionContentProvidersForServerRender(vizRegionDomNode, onQueueComplete) {
			for (var $t1 = 0; $t1 < $tab_PaneTableViewRegionParts.nonVizContentRegions.length; $t1++) {
				var regionPart = $tab_PaneTableViewRegionParts.nonVizContentRegions[$t1];
				var domNode = this.regionParts.getSelectorForRegion(regionPart);
				var tiledWindowRegion = this.makeTiledWindow(domNode, this.get_session(), this.get_controller(), ss.mkdel(this, this.$getRequestId), null);
				this.regions[regionPart].set_contentProvider(tiledWindowRegion);
			}
			this.get_vizRegion().set_contentProvider(this.makeTiledWindow(vizRegionDomNode, this.get_session(), this.get_controller(), ss.mkdel(this, this.$getRequestId), onQueueComplete));
		},
		makeRegionContentProvidersHelper: function PaneTableView$MakeRegionContentProvidersHelper(vizRegionDomNode, onQueueComplete) {
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				this.get_paneTableVM().add_vizRegionMapChange(ss.mkdel(this, this.$updateRegionContentProviders));
				var backgroundMode = 'transparent';
				var paneTableView = new $tab_PaneTableCanvasView(this.get_paneTableVM(), this.getDomNodeForContentRegion(vizRegionDomNode), backgroundMode);
				var containers = $('.tvimagesContainer', vizRegionDomNode);
				containers.get(0).appendChild(paneTableView.element.get(0));
				this.get_vizRegion().set_contentProvider(paneTableView);
				this.$updateRegionContentProviders();
				this.$overlayTableView = this.makePaneTableOverlayView(this.getDomNodeForContentRegion(vizRegionDomNode));
				this.get_paneTableVM().add_propertyChanged(ss.mkdel(this.$overlayTableView, this.$overlayTableView.$onSceneChanged));
				containers.get(0).appendChild(this.$overlayTableView.element.get(0));
			}
			else {
				this.$makeRegionContentProvidersForServerRender(vizRegionDomNode, onQueueComplete);
			}
			this.updateRegionBackgroundColor();
		},
		makePaneTableOverlayView: function PaneTableView$MakePaneTableOverlayView(domNode) {
			return new $tab_PaneTableOverlayView(this.get_paneTableVM(), domNode, this.get_vizRegion());
		},
		makeTiledWindowHelper: function PaneTableView$MakeTiledWindowHelper(domNode, sessionRef, controllerRef, getRequestIdFunc, optionalCallback, scrollDomNode) {
			var tw = new $tab_TiledWindow(this.getDomNodeForContentRegion(domNode), sessionRef, controllerRef, getRequestIdFunc, scrollDomNode);
			if (ss.isValue(optionalCallback)) {
				tw.add_loadComplete(optionalCallback);
				this.disposables.add$1(new tab.CallOnDispose(function() {
					tw.remove_loadComplete(optionalCallback);
				}));
			}
			return tw;
		},
		destroyRegions: function PaneTableView$DestroyRegions() {
			var $t1 = ss.getEnumerator(Object.keys(this.regions));
			try {
				while ($t1.moveNext()) {
					var regionPart = $t1.current();
					if (ss.isValue(this.regions[regionPart])) {
						this.regions[regionPart].destroy();
					}
				}
			}
			finally {
				$t1.dispose();
			}
		},
		checkForHoverOverlay: null,
		isUserDragging: null,
		onTooltipClosed: function PaneTableView$OnTooltipClosed() {
		},
		$tuplesInScene: function PaneTableView$TuplesInScene(command) {
			ss.Debug.assert(tab.ApplicationModel.get_instance().get_isLocalRenderMode(), 'TuplesInScene should only be used in local render mode.');
			if (ss.keyExists(command.commandParams, 'tupleId')) {
				var tupleid = parseInt(command.commandParams['tupleId'].toString(), 10);
				var paneDrawInfo = this.get_paneTableVM().get_scene().getPaneDrawInfoFromTupleId(tupleid);
				if (ss.isNullOrUndefined(paneDrawInfo)) {
					return false;
				}
			}
			if (ss.keyExists(command.commandParams, 'selection')) {
				var selection = ss.cast(command.commandParams['selection'], String);
				if (ss.isValue(selection)) {
					try {
						var spm = JSON.parse(selection);
						if (spm.selectionType === 'tuples') {
							for (var $t1 = 0; $t1 < spm.objectIds.length; $t1++) {
								var tid = spm.objectIds[$t1];
								var paneDrawInfo1 = this.get_paneTableVM().get_scene().getPaneDrawInfoFromTupleId(tid);
								if (ss.isNullOrUndefined(paneDrawInfo1)) {
									return false;
								}
							}
						}
					}
					catch ($t2) {
						return false;
					}
				}
			}
			return true;
		},
		onCommandExecuted: function PaneTableView$OnCommandExecuted(senderUbertip, args) {
			if (ss.isNullOrUndefined(args) || ss.isNullOrUndefined(args.command)) {
				return;
			}
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode() && ss.isValue(args.command.command) && !this.$tuplesInScene(args.command.command)) {
				return;
			}
			if (args.command.get_commandType() === 7) {
				this.get_session().executeCommand(args.command);
			}
			else {
				tab.UberTipClientCommands.executeUbertipCommand(args.command);
			}
		},
		onActionExecuted: function PaneTableView$OnActionExecuted(senderUbertip, args) {
			if (ss.isNullOrUndefined(args) || ss.isNullOrUndefined(args.action)) {
				return;
			}
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode() && ss.isValue(args.action.command) && !this.$tuplesInScene(args.action.command)) {
				return;
			}
			var onFailure = function() {
				ss.cast(senderUbertip, tab.Ubertip).hideSpinner();
			};
			var successCallback = function(pm) {
				ss.cast(senderUbertip, tab.Ubertip).hideSpinner();
			};
			this.get_session().executeAction(args.action, successCallback, onFailure);
		},
		doDoubleTap: function PaneTableView$DoDoubleTap(region, pseudoEvent, scale) {
			if (!tsConfig.allow_filter) {
				return;
			}
			if (region.get_regionPart() !== 'viz' || !this.allowPanZoomActionsOnDoubleTap()) {
				return;
			}
			if (this.get_paneTableVM().get_isMapWithBaseLayer() && !region.allowMapZoomAtCurrentLevel(scale)) {
				return;
			}
			this.get_controller().incrementCacheVersion();
			var defer = tab.DeferLayoutImpl.get_instance();
			defer.setDeferLayoutUpdates(true);
			tab.Log.get(this).debug('double click - increment rid', []);
			var pane = this.resolvePane(region.toLocalCoordsEvent(pseudoEvent, false));
			region.zoomPoint(pane, region.toLocalCoordsEvent(pseudoEvent, false), scale, true, defer);
			this.get_vizToolTip().close();
			this.disposeOfOverlays();
		},
		$onSelectionChanged: function PaneTableView$OnSelectionChanged(sheetName, info) {
			if (!ss.referenceEquals(sheetName, this.get_controller().get_sheetName())) {
				return;
			}
			this.checkForHoverOverlay();
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				this.get_vizRegion().reset();
			}
		},
		dragOverride: function PaneTableView$DragOverride(pseudoEvent, defaultAction) {
			if (this.isUserDragging()) {
				return;
			}
			this.callVizDragHandlers(pseudoEvent, defaultAction);
		},
		dragOverrideAsync: function PaneTableView$DragOverrideAsync(pseudoEvent, defaultAction) {
			if (this.isUserDragging()) {
				return;
			}
			this.callAsyncVizDragHandlers(pseudoEvent, defaultAction);
		},
		clearSelection: function PaneTableView$ClearSelection() {
			this.get_paneTableVM().clearAnnotationSelection();
			tab.SelectionClientCommands.clearAllSelections(this.get_visualId());
		},
		refreshImages: function PaneTableView$RefreshImages(tileCacheUrl) {
			tab.Log.get(this).debug('RefreshImages: %s', [this.get_instanceId()]);
			this.$requestId += 1;
			var $t1 = ss.getEnumerator(Object.keys(this.regions));
			try {
				while ($t1.moveNext()) {
					var regionPart = $t1.current();
					this.regions[regionPart].refreshImages(tileCacheUrl);
				}
			}
			finally {
				$t1.dispose();
			}
			this.$cornersRenderer.$refreshCornerImages(tileCacheUrl, this.get_session(), this.$getRequestId());
		},
		$setTitleGeometry: function PaneTableView$SetTitleGeometry(geo, regionGeometry) {
			var titleVerticalOffset = 0;
			if (ss.isValue(geo.title) && this.dom.title.css('display') !== 'none') {
				var titleSizeHint = this.$titleView.minSizeHint();
				var newRect = { l: 0, t: geo.title.y, w: Math.max(geo.title.w + regionGeometry.get_scrollWidth(), titleSizeHint.w), h: Math.max(geo.title.h, titleSizeHint.h) };
				this.titleHeight = newRect.h;
				var oldRect = tab.DomUtil.getMarginBoxJQ(this.dom.title);
				if (!_.isEqual(newRect, oldRect)) {
					tab.DomUtil.setAbsolutePositionBox(this.dom.title, newRect);
					this.$titleView.handleNewTextRegion();
					titleVerticalOffset = geo.title.h + geo.title.y;
				}
			}
			return titleVerticalOffset;
		},
		$setCaptionGeometry: function PaneTableView$SetCaptionGeometry(geo, regionGeometry) {
			var spaceForCaption = 0;
			if (ss.isValue(this.$captionView) && this.dom.caption.css('display') !== 'none') {
				var newRect1;
				if (ss.isValue(geo.caption)) {
					spaceForCaption = geo.caption.h + $tab_PaneTableView.$captionTopPadding + regionGeometry.get_scrollHeight();
					newRect1 = { l: geo.caption.x, t: geo.caption.y - regionGeometry.get_heightScrollOffset(), w: geo.caption.w, h: geo.caption.h };
				}
				else {
					newRect1 = { l: 0, t: 0, w: 0, h: 0 };
				}
				var oldRect1 = tab.DomUtil.getMarginBoxJQ(this.dom.caption);
				if (!_.isEqual(newRect1, oldRect1)) {
					tab.DomUtil.setAbsolutePositionBox(this.dom.caption, newRect1);
					this.$captionView.handleNewTextRegion();
				}
			}
			return spaceForCaption;
		},
		updateGeometry: function PaneTableView$UpdateGeometry() {
			this.$cornersRenderer.$resetRegionImages();
			this.$requestId += 1;
			var regionGeometry = this.get_geometryBundle().get_regionGeometry();
			var visGeo = this.get_geometryBundle().get_visibleGeometry();
			var geo = this.get_geometryBundle().get_geometryWithRegions();
			this.titleHeight = 0;
			var scrollXTop = regionGeometry.get_overallHeight();
			var titleVerticalOffset = this.$setTitleGeometry(geo, regionGeometry);
			scrollXTop = Math.max(scrollXTop, titleVerticalOffset);
			var spaceForCaption = this.$setCaptionGeometry(geo, regionGeometry);
			scrollXTop -= spaceForCaption;
			this.$setPositionForAllRegions(visGeo, geo);
			this.setGeometryForWebScrollbars(regionGeometry, scrollXTop);
			this.refreshScrollingAndAxisIcons();
			this.setRegionResizersForWeb();
			this.refreshTooltipIfNeeded();
		},
		$setPositionForAllRegions: function PaneTableView$SetPositionForAllRegions(visGeo, geo) {
			var backgroundDisplayList = null;
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				var backgroundVlvm = this.get_paneTableVM().get_vizRegionMap()['background'];
				if (ss.isValue(backgroundVlvm)) {
					backgroundDisplayList = backgroundVlvm.get_visualListPM().drawItems;
				}
			}
			this.$setCornerPositionAndRenderOrHide(geo.uleft, visGeo.uleftArea, backgroundDisplayList, this.dom.topLeftSpacer, 'uleft');
			this.setupTopSpacerAreaRects(visGeo.uleftArea, geo);
			this.$setRegionAndContentGeometry(geo.yheader, this.dom.yLabel, 'yheader', geo.ts, visGeo.yheaderArea);
			this.$setRegionAndContentGeometry(geo.leftaxis, this.dom.leftAxis, 'leftaxis', geo.ts, visGeo.leftaxisArea);
			this.$setRegionAndContentGeometry(geo.rightaxis, this.dom.rightAxis, 'rightaxis', geo.ts, visGeo.rightaxisArea);
			this.$setRegionAndContentGeometry(geo.xheader, this.dom.xLabel, 'xheader', geo.ts, visGeo.xheaderArea);
			this.$setRegionAndContentGeometry(geo.bottomaxis, this.dom.bottomAxis, 'bottomaxis', geo.ts, visGeo.bottomaxisArea);
			this.$setRegionAndContentGeometry(geo.topaxis, this.dom.topAxis, 'topaxis', geo.ts, visGeo.topaxisArea);
			this.$setCornerPositionAndRenderOrHide(geo.uright, visGeo.urightArea, backgroundDisplayList, this.dom.topRightSpacer, 'uright');
			this.$setCornerPositionAndRenderOrHide(geo.lleft, visGeo.lleftArea, backgroundDisplayList, this.dom.bottomLeftSpacer, 'lleft');
			this.$setCornerPositionAndRenderOrHide(geo.lright, visGeo.lrightArea, backgroundDisplayList, this.dom.bottomRightSpacer, 'lright');
			this.$setRegionAndContentGeometry(geo.viz, this.dom.view, 'viz', geo.ts, visGeo.vizArea);
		},
		setupTopSpacerAreaRects: function PaneTableView$SetupTopSpacerAreaRects(uleftVisGeo, geo) {
			if (ss.isValue(geo.uleft)) {
				this.tlspacerAreaY = $.extend({}, uleftVisGeo);
				if (ss.isValue(geo.di) && geo.uleft.h >= 40) {
					this.tlspacerAreaY.t = geo.uleft.y + geo.uleft.h - 40;
					this.tlspacerAreaY.h = 40;
				}
				this.tlspacerAreaX = null;
				if (ss.isValue(geo.di) && ss.isValue(geo.di.xy) && ss.isValue(geo.di.xy[0])) {
					var XspacerW = 18;
					var xh = geo.xheader;
					if (ss.isValue(xh) && xh.h > geo.di.xs) {
						var len1 = geo.di.xy.length;
						for (var i1 = 0; i1 < len1; i1++) {
							if (geo.di.xy[i1][1] > 0) {
								this.tlspacerAreaX = { l: this.tlspacerAreaY.l + this.tlspacerAreaY.w - XspacerW, t: geo.uleft.y, w: XspacerW, h: geo.uleft.h };
								this.tlspacerAreaY.w = this.tlspacerAreaX.l;
								break;
							}
						}
					}
				}
			}
			else {
				this.tlspacerAreaY = null;
				this.tlspacerAreaX = null;
			}
		},
		$setCornerPositionAndRenderOrHide: function PaneTableView$SetCornerPositionAndRenderOrHide(rect, marginBoxSpec, backgroundDisplayList, domNode, cornerName) {
			if (ss.isValue(marginBoxSpec)) {
				tab.DomUtil.setAbsolutePositionBox(domNode, marginBoxSpec);
				this.setRegionGeometryHelper(domNode, marginBoxSpec);
				domNode.show();
				this.$cornersRenderer.$setupCornerRenderer(rect, domNode, cornerName, backgroundDisplayList);
			}
			else {
				domNode.hide();
			}
		},
		$setRegionAndContentGeometry: function PaneTableView$SetRegionAndContentGeometry(rect, domNode, regionPart, tileSize, marginBoxSpec) {
			if (ss.isValue(rect)) {
				tab.DomUtil.setAbsolutePositionBox(domNode, marginBoxSpec);
				this.setRegionGeometryHelper(domNode, marginBoxSpec);
				domNode.show();
				this.regions[regionPart].setGeometry(rect, marginBoxSpec, tileSize);
				if (regionPart === 'viz') {
					this.updateOverlayTableGeometry(rect, tileSize, marginBoxSpec);
				}
			}
			else {
				domNode.hide();
			}
		},
		updateOverlayTableGeometry: function PaneTableView$UpdateOverlayTableGeometry(rect, tileSize, marginBoxSpec) {
			if (ss.isNullOrUndefined(this.$overlayTableView)) {
				return;
			}
			this.$overlayTableView.set_actualViewSize({ w: marginBoxSpec.w, h: marginBoxSpec.h });
			this.$overlayTableView.reset(rect, tileSize);
		},
		resolvePane: function PaneTableView$ResolvePane(point) {
			var geometryOfPanes = this.get_geometry().pi;
			var pane = { canDragH: geometryOfPanes.hasXQAxis, canDragV: geometryOfPanes.hasYQAxis, x: 0, y: 0, w: 0, h: 0 };
			$tab_PaneTableView.$resolvePaneAcross(point.x, geometryOfPanes.xWidths, pane);
			$tab_PaneTableView.$resolvePaneDown(point.y, geometryOfPanes.yHeights, pane);
			return pane;
		},
		allowPanZoomActions: null,
		allowPanZoomActionsOnDoubleTap: null,
		isVizLargerThanScreen: function PaneTableView$IsVizLargerThanScreen() {
			if (ss.isValue(this.get_geometry()) && ss.isValue(this.get_geometry().viz)) {
				var width = this.get_geometry().viz.w;
				var height = this.get_geometry().viz.h;
				var tv = this.get_vizRegion();
				var contentProvider = tv.get_contentProvider();
				var containerWidth = contentProvider.get_effectiveViewSize().w;
				var containerHeight = contentProvider.get_effectiveViewSize().h;
				return width > containerWidth || height > containerHeight;
			}
			return false;
		},
		isOneVisiblePane: function PaneTableView$IsOneVisiblePane() {
			if (ss.isValue(this.get_geometry()) && ss.isValue(this.get_geometry().viz)) {
				var i, len;
				var width = this.get_geometry().viz.w;
				var height = this.get_geometry().viz.h;
				var xWidths = this.get_geometry().pi.xWidths;
				var yHeights = this.get_geometry().pi.yHeights;
				len = xWidths.length;
				for (i = 0; i < len; i++) {
					if (Math.abs(width - xWidths[i]) > 1) {
						return false;
					}
				}
				len = yHeights.length;
				for (i = 0; i < len; i++) {
					if (Math.abs(height - yHeights[i]) > 1) {
						return false;
					}
				}
			}
			return true;
		},
		maybeShowOverlayImages: null,
		createOverlayImageFromDataUri: function PaneTableView$CreateOverlayImageFromDataUri(imageDataUri) {
			var overlayImage = new tab.OverlayImage(this.dom.view.find('.tvimagesContainer').get(0), 'data:image/png;base64,' + imageDataUri);
			return overlayImage;
		},
		createOverlayImageFromFile: function PaneTableView$CreateOverlayImageFromFile(uri) {
			var overlayImage = new tab.OverlayImage(this.dom.view.find('.tvimagesContainer').get(0), this.get_session().formatSessionTempfileReference(uri, false, false));
			return overlayImage;
		},
		updateOverlayTarget: function PaneTableView$UpdateOverlayTarget(target, targetState, visualPart) {
			if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				return;
			}
			switch (targetState) {
				case 'press': {
					this.$overlayTableView.setPressedOverlayTarget(target, visualPart);
					break;
				}
				case 'hover': {
					this.$overlayTableView.setHoverOverlayTarget(target, visualPart);
					break;
				}
				default: {
					break;
				}
			}
		},
		updateOverlayForLastTargetState: function PaneTableView$UpdateOverlayForLastTargetState(target, visualPart) {
			this.updateOverlayTarget(target, this.$overlayTableView.get_lastTargetState(), visualPart);
		},
		hoverOverWhitespace: function PaneTableView$HoverOverWhitespace() {
			this.$overlayTableView.hoverOverWhitespace();
		},
		updateHoveredCategoricalHeadersAndQuantitativeAxes: function PaneTableView$UpdateHoveredCategoricalHeadersAndQuantitativeAxes(drawGroup, targetState, visualPart) {
			var vlvm = this.get_paneTableVM().get_vizRegionMap()[visualPart];
			if (ss.isNullOrUndefined(vlvm)) {
				return;
			}
			switch (targetState) {
				case 'press': {
					vlvm.set_hoveredNodeOrAxis(null);
					break;
				}
				case 'hover': {
					vlvm.set_hoveredNodeOrAxis(drawGroup);
					break;
				}
				default: {
					break;
				}
			}
		},
		showOverlayImages: function PaneTableView$ShowOverlayImages(overlayImage, overlayAnchors) {
			if (ss.isValue(overlayAnchors) && ss.isValue(overlayImage) && overlayAnchors.length > 0) {
				this.disposeOfOverlayImages();
				for (var i = 1; i < overlayAnchors.length; ++i) {
					var clone = overlayImage.clone();
					this.$overlayImages.push(clone);
					clone.show(overlayAnchors[i]);
				}
				this.$overlayImages.push(overlayImage);
				overlayImage.show(overlayAnchors[0]);
			}
		},
		setRegionGeometryHelper: null,
		getDomNodeForContentRegion: null,
		clickTitle: function PaneTableView$ClickTitle(e) {
		},
		clickCaption: function PaneTableView$ClickCaption(e) {
		},
		makeConnections: function PaneTableView$MakeConnections() {
		},
		makeMapsSearchViewConnections: null,
		makeRegions: null,
		makeInputHandlers: null,
		makeRegionContentProviders: null,
		setupDrilling: function PaneTableView$SetupDrilling() {
		},
		refreshScrollingAndAxisIcons: null,
		refreshTooltipIfNeeded: function PaneTableView$RefreshTooltipIfNeeded() {
		},
		setupSortIndicators: function PaneTableView$SetupSortIndicators() {
		},
		setupAxisContextMenuIndicator: function PaneTableView$SetupAxisContextMenuIndicator() {
		},
		destroyInputHandlers: null,
		setGeometryForWebScrollbars: function PaneTableView$SetGeometryForWebScrollbars(regionGeometry, scrollXTop) {
		},
		setRegionResizersForWeb: function PaneTableView$SetRegionResizersForWeb() {
		},
		makeTooltipLegacyMode: null,
		makeTooltip: function PaneTableView$MakeTooltip() {
			if (this.get_isTooltipAllowed() && this.get_tooltipMode() === 'smooth') {
				return new $tab_TooltipResponsiveMode(this.get_paneTableVM().get_tooltipContextProvider(), this.get_visualId(), this.dom.view, true);
			}
			else if (this.get_isTooltipAllowed() && this.get_tooltipMode() === 'sticky') {
				return this.makeTooltipLegacyMode(this.get_paneTableVM().get_tooltipContextProvider());
			}
			else {
				return new $tab_TooltipDisabledMode(this.get_paneTableVM().get_tooltipContextProvider(), this.get_visualId());
			}
		},
		onHoverOverlay: function PaneTableView$OnHoverOverlay(region, pseudoEvent) {
			if (this.isUserDragging()) {
				return;
			}
			if (this.wasPressOverlayJustUpdated) {
				this.wasPressOverlayJustUpdated = false;
				return;
			}
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode() && region.get_regionPart() === 'viz') {
				if (!this.isAnimationOccurring && (region.get_toolModeViewModel().get_isSelectingToolActive() || !region.get_isDragTracking() && region.get_toolModeViewModel().get_currentPointerToolMode() === 'pan-map')) {
					var regionCoordinates = region.toLocalCoordsEvent(pseudoEvent, false);
					var pageCoordinates = { x: pseudoEvent.pageX, y: pseudoEvent.pageY };
					this.lastVizHoverPoint = regionCoordinates;
					if (this.get_vizToolTip().isHoverAllowed(pageCoordinates)) {
						this.hitTestAndSetHoverOverMarkOrVisualPartHelper(true);
					}
				}
				else {
					this.lastVizHoverPoint = null;
				}
			}
		},
		hitTestAndSetHoverOverMarkOrVisualPartHelper: function PaneTableView$HitTestAndSetHoverOverMarkOrVisualPartHelper(updateTargetStateToHover) {
			var vizRegion = this.get_vizRegion();
			var objectHit = this.get_paneTableVM().get_localRenderVizHitTester().onHoverHitTest(this.lastVizHoverPoint);
			this.onHoverOverVisualPart(vizRegion, objectHit.get_hitType() !== 0);
			if (objectHit.get_hitType() === 0) {
				this.hoverOverWhitespace();
			}
			if (objectHit.get_shouldRenderOverlay()) {
				if (!updateTargetStateToHover) {
					this.updateOverlayForLastTargetState(objectHit.get_id(), objectHit.get_overlayTargetType());
				}
				else {
					this.updateOverlayTarget(objectHit.get_id(), 'hover', objectHit.get_overlayTargetType());
				}
			}
			else {
				this.disposeOfOverlayImages();
			}
		},
		onHoverOverVisualPart: null,
		$onHoverTooltipViz: function PaneTableView$OnHoverTooltipViz(region, regionCoordinates, tooltip, pageCoordinates) {
			this.$clearVisualPartHoverTimeOut();
			region.get_shapeSelector().setSingleSelectPoint(regionCoordinates);
			var vizRegion = this.get_vizRegion();
			var tooltipObject = this.get_paneTableVM().get_localRenderVizHitTester().onHoverHitTest(regionCoordinates);
			var hitSomething = tooltipObject.get_hitType() !== 0;
			this.onHoverOverVisualPart(vizRegion, hitSomething);
			if (hitSomething) {
				switch (tooltipObject.get_hitObjectType()) {
					case 7:
					case 8: {
						var markBBox = this.get_paneTableVM().get_scene().getMarkBoundingBox(tooltipObject.get_id());
						regionCoordinates = $tab_PaneTableView.$adjustMarkHitTestCoord(regionCoordinates, markBBox);
						var selectionsModel = this.get_paneTableVM().get_visualModel().get_selectionsModel();
						var isSelected = selectionsModel.tupleSelection.isObjectSelected(tooltipObject.get_id());
						var paneDrawInfo = this.get_paneTableVM().get_scene().getPaneDrawInfoFromTupleId(tooltipObject.get_id());
						var paneDescriptorKey = paneDrawInfo.get_paneDescriptorKey();
						tooltip.hoverOverObject(pageCoordinates, regionCoordinates, tooltipObject.get_id(), isSelected, paneDescriptorKey, 'mark', region.get_regionPart());
						break;
					}
					case 6:
					case 4:
					case 5:
					case 3: {
						this.$visualPartHoverCommandTimeOut = window.setTimeout(function() {
							tooltip.hoverOverCoordinates(pageCoordinates, regionCoordinates, 'visualparts', region.get_regionPart(), null, null, false);
						}, EventUtils.Hover.FastHoverTime);
						break;
					}
					case 2: {
						if (tooltip.get_isTooltipShown()) {
							tooltip.close();
						}
						break;
					}
					default: {
						break;
					}
				}
			}
			return hitSomething;
		},
		onHover: function PaneTableView$OnHover(region, pseudoEvent) {
			if (this.isUserDragging() || this.get_paneTableVM().vizContextMenuOpened() || this.get_paneTableVM().isAnnotationDragging()) {
				return;
			}
			if (tab.BaseSession.get_waitHandler().isBusy()) {
				return;
			}
			var tooltip = this.get_vizToolTip();
			if (tooltip.get_isTooltipShown() && tooltip.shownTooltipIsStatic()) {
				return;
			}
			var regionCoordinates = region.toLocalCoordsEvent(pseudoEvent, false);
			var pageCoordinates = tab.PointUtil.add(regionCoordinates, region.getLocalOffsetPoint(false));
			this.get_paneTableVM().handleAnnotationHover(regionCoordinates);
			if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				this.$onHoverTooltipServerRendered(region, tooltip, pageCoordinates, regionCoordinates);
				return;
			}
			var hitSomething = false;
			var visualListVM = this.getVisualListViewModelForRegion(region.get_regionPart());
			if (region.get_regionPart() === 'viz') {
				hitSomething = this.$onHoverTooltipViz(region, regionCoordinates, tooltip, pageCoordinates);
			}
			else if (ss.isValue(visualListVM)) {
				var hoveredNode = visualListVM.hitTestNodes(regionCoordinates);
				if (ss.isValue(hoveredNode)) {
					var newSel = tab.SelectionUtils.nodeSelectionFromDrawGroup(hoveredNode);
					var interactedTupleIds = tab.BrushingComputer.getTuplesAssociatedWithSelectedNodes(this.get_paneTableVM().get_visualModel(), [newSel]);
					tooltip.hoverOverHeader(pageCoordinates, regionCoordinates, 'header', region.get_regionPart(), interactedTupleIds);
					hitSomething = true;
				}
			}
			if (!hitSomething) {
				tooltip.hoverOverWhitespace(pageCoordinates, region.get_regionPart());
			}
		},
		$onHoverTooltipServerRendered: function PaneTableView$OnHoverTooltipServerRendered(region, tooltip, pageCoordinates, regionCoordinates) {
			if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				var targetType = $tab_PaneTableView.guessTooltipTargetTypeFromRegion(region.get_regionPart());
				tooltip.hoverOverCoordinates(pageCoordinates, regionCoordinates, targetType, region.get_regionPart(), null, null, false);
				return;
			}
		},
		$clearVisualPartHoverTimeOut: function PaneTableView$ClearVisualPartHoverTimeOut() {
			if (ss.isValue(this.$visualPartHoverCommandTimeOut)) {
				window.clearTimeout(ss.unbox(this.$visualPartHoverCommandTimeOut));
				this.$visualPartHoverCommandTimeOut = null;
			}
		},
		makeTiledWindow: null,
		shouldInformTooltipOfLocalTapOnViz: null,
		disposeOfOverlays: function PaneTableView$DisposeOfOverlays() {
			this.disposeOfOverlayImages();
		},
		disposeOfOverlayImages: function PaneTableView$DisposeOfOverlayImages() {
			for (var $t1 = 0; $t1 < this.$overlayImages.length; $t1++) {
				var overlay = this.$overlayImages[$t1];
				if (ss.isValue(overlay)) {
					overlay.dispose();
				}
			}
			ss.clear(this.$overlayImages);
			if (ss.isValue(this.$overlayTableView)) {
				this.$overlayTableView.clearOverlays();
			}
			this.$pendingOverlayDrag = tab.MiscUtil.clearTimeout(this.$pendingOverlayDrag);
		},
		$setOverlayScrollPosition: function PaneTableView$SetOverlayScrollPosition(scrollPosition) {
			if (ss.isValue(this.$overlayTableView)) {
				this.$overlayTableView.setScrollPosition(scrollPosition);
			}
		},
		checkForDragOverlays: function PaneTableView$CheckForDragOverlays() {
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				if (ss.isValue(this.$pendingOverlayDrag)) {
					return;
				}
				var deltaTime = (new Date()).getTime() - this.$lastDragTime;
				if (deltaTime >= $tab_PaneTableView.$dragOverlayDrawThrottleMs) {
					this.$createDragOverlays();
				}
				else {
					this.$pendingOverlayDrag = window.setTimeout(ss.mkdel(this, this.$createDragOverlays), $tab_PaneTableView.$dragOverlayDrawThrottleMs - deltaTime);
				}
			}
		},
		$createDragOverlays: function PaneTableView$CreateDragOverlays() {
			this.$pendingOverlayDrag = null;
			var hitTestResults = this.get_paneTableVM().get_localRenderVizHitTester().hitTestMarksAgainstSelectionShape(this.get_vizRegion().get_shapeSelector());
			var tupleIds = $tab_HitTestResult.getIdsFromHitTestResults(hitTestResults, true);
			this.$overlayTableView.setDragOverlayTuples(tupleIds);
			this.$lastDragTime = (new Date()).getTime();
		},
		updateRegionContentProvider: function PaneTableView$UpdateRegionContentProvider(regionPart, canvasView) {
			this.regions[regionPart].set_contentProvider(canvasView);
		},
		isSelectActionOnVizAllowed: function PaneTableView$IsSelectActionOnVizAllowed(action) {
			return true;
		},
		handleLocalTap: function PaneTableView$HandleLocalTap(region, action, pageCoords, regionCoords, behavior, isEndOfSmoothTooltipGesture, isZoneMultiSelect) {
			var hitSomething = false;
			if (this.isSelectActionOnVizAllowed(action)) {
				var visualListVM = this.getVisualListViewModelForRegion(region.get_regionPart());
				if (region.get_regionPart() === 'viz') {
					var toolTipAction = ss.mkdel(this, function(hitTestResult) {
						if (this.shouldInformTooltipOfLocalTapOnViz(hitTestResult, isEndOfSmoothTooltipGesture)) {
							this.informTooltipOfLocalTapOnViz(hitTestResult, region, pageCoords, regionCoords);
						}
					});
					var htr = this.get_paneTableVM().get_localRenderVizHitTester().onTapHitTest(regionCoords);
					$tab_LocalRenderVizSelectionDispatcher.doSingleSelect(htr, regionCoords, action, toolTipAction, behavior, this.get_paneTableVM().get_visualId(), isZoneMultiSelect);
					hitSomething = htr.get_hitType() !== 0;
				}
				else if (ss.isValue(visualListVM)) {
					var selected = visualListVM.hitTestNodes(regionCoords);
					if (ss.isValue(selected)) {
						var tooltipCallback = ss.mkdel(this, function() {
							this.get_vizToolTip().singleSelectCoordinates(pageCoords, regionCoords, region.get_regionPart(), 'header', null);
						});
						visualListVM.selectNode(regionCoords, selected, action, tooltipCallback);
						hitSomething = true;
					}
					else {
						tab.SelectionClientCommands.clearAllSelections(this.get_visualId());
					}
				}
				if (!hitSomething) {
					this.get_vizToolTip().hoverOverWhitespace(pageCoords, region.get_regionPart());
				}
			}
		},
		informTooltipOfLocalTapOnViz: function PaneTableView$InformTooltipOfLocalTapOnViz(htr, region, pageCoords, regionCoords) {
			var paneDescriptorKey = null;
			if (ss.isValue(this.get_paneTableVM()) && ss.isValue(this.get_paneTableVM().get_scene()) && htr.get_tooltipTargetType() === 'mark') {
				var paneDrawInfo = this.get_paneTableVM().get_scene().getPaneDrawInfoFromTupleId(htr.get_id());
				if (ss.isValue(paneDrawInfo)) {
					paneDescriptorKey = paneDrawInfo.get_paneDescriptorKey();
				}
			}
			var canHandleTooltipLocally = !tab.ActionUtils.canRemoteSelectTriggeredActionsModifyTheirSourceSheet(this.get_visualId().worksheet) && ss.isValue(paneDescriptorKey) && !ss.isNullOrUndefined(this.get_geometry().viz);
			if (!canHandleTooltipLocally) {
				this.get_vizToolTip().singleSelectCoordinates(pageCoords, regionCoords, region.get_regionPart(), htr.get_tooltipTargetType(), null);
			}
			else {
				this.get_vizToolTip().singleSelectComplete(pageCoords, regionCoords, htr.get_id(), paneDescriptorKey, htr.get_tooltipTargetType(), region.get_regionPart());
			}
		},
		$handleTextUpdated: function PaneTableView$HandleTextUpdated() {
			this.$redrawCorners();
		},
		$redrawCorners: function PaneTableView$RedrawCorners() {
			var visualModel = this.get_paneTableVM().get_visualModel();
			if (ss.isNullOrUndefined(visualModel)) {
				return;
			}
			var geom = visualModel.get_geometryModel().pm;
			this.$redrawCorners$1(geom);
		},
		$redrawCorners$1: function PaneTableView$RedrawCorners(geom) {
			$tab_$PaneTableCornersRenderer.$redrawCorners(geom, this.get_paneTableVM(), this.dom);
		},
		handleNewVisual: function PaneTableView$HandleNewVisual() {
			if (this.get_paneTableVM().isInvalidSheet()) {
				$('<div/>').text(tab.Strings.BaseClientInvalidSheet(this.get_paneTableVM().get_sheetId())).addClass('wcInvalidSheet').appendTo(this.get_template().domRoot).get(0);
				return;
			}
			if (this.$hasBeenDisposed) {
				return;
			}
			var visualModel = this.get_paneTableVM().get_visualModel();
			if (ss.isNullOrUndefined(visualModel)) {
				return;
			}
			this.$updateTitle(visualModel);
			this.$updateCaption(visualModel);
			this.$updateAccessibilityBindingsForView();
			this.updateTooltipMode(visualModel);
			var geom = visualModel.get_geometryModel().pm;
			var containerBox = visualModel.get_containerGeometry();
			var geometryKey = { containerBox: containerBox, geometry: geom };
			var geometryIsCached = this.get_geometryArgCache().update(geometryKey);
			if (geometryIsCached) {
				this.refreshScrollingAndAxisIcons();
			}
			else {
				this.set_geometryBundle($tab_PaneTableGeometryComputer.computeGeometry(geometryKey));
				this.updateGeometry();
			}
			this.$updateVizNavigationTools(visualModel);
			this.floatingZoomToolbarView.setToolMode(this.defaultPointerToolMode(), true);
			this.updateRegionBackgroundColor();
			this.$updateBackgroundMap();
			this.$updateMapScale();
			this.$updateMapAttribution();
			this.$redrawCorners$1(geom);
			this.$updateDebugInfo(visualModel);
			this.isAnimationOccurring = false;
			if (ss.isValue(this.get_paneTableVM().get_annotationSelectionChromeViewModel())) {
				this.get_paneTableVM().updateAnnotationSelection();
			}
		},
		$updateVizNavigationTools: function PaneTableView$UpdateVizNavigationTools(visualModel) {
			this.updateMapsSearchView();
			if (visualModel.get_isMap() && this.get_shouldDisablePanTool() && (this.get_paneTableVM().get_vizRegionToolModeViewModel().get_isPanToolActive() || this.get_paneTableVM().get_vizRegionToolModeViewModel().get_isZoomToolActive())) {
				this.setPointerToolMode(visualModel.get_defaultMapTool(), true);
			}
			this.get_paneTableVM().get_vizRegionToolModeViewModel().updateDefaultToolMode(this.allowPanZoomActions());
			this.floatingZoomToolbarView.updateZoomToolbar(visualModel.get_floatingToolbarVisibility());
			if (tab.GestureModelSettings.get_newModelEnabled()) {
				this.get_paneTableVM().get_floatingToolbarContainerVM().showTools(this.get_shouldShowTools());
				this.get_paneTableVM().get_floatingToolbarContainerVM().shouldEnablePanAndZoom(!this.get_shouldDisablePanTool());
				this.get_paneTableVM().get_floatingToolbarContainerVM().updateZoomHomeState(!this.get_paneTableVM().shouldEnableZoomHomeToolbar());
			}
		},
		updateMapsSearchView: function PaneTableView$UpdateMapsSearchView() {
			if (this.get_paneTableVM().get_mapSearchEnabled()) {
				if (ss.isNullOrUndefined(this.get_paneTableVM().get_mapsSearchViewModel()) || ss.isNullOrUndefined(this.mapsSearchView)) {
					this.$buildMapsSearchViewModel();
					this.buildMapsSearchView();
				}
				this.addMapsSearchViewToDomIfNeeded();
			}
			else {
				this.removeMapsSearchViewFromDomIfNeeded();
			}
		},
		$buildMapsSearchViewModel: function PaneTableView$BuildMapsSearchViewModel() {
			this.get_paneTableVM().set_mapsSearchViewModel(new $tab_MapsSearchViewModel(this.get_paneTableVM().get_visualId()));
			this.get_paneTableVM().get_mapsSearchViewModel().add_onMoveMapToBounds(ss.mkdel(this, this.handleMoveMapToBounds));
			this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
				this.get_paneTableVM().get_mapsSearchViewModel().remove_onMoveMapToBounds(ss.mkdel(this, this.handleMoveMapToBounds));
			})));
		},
		buildMapsSearchView: function PaneTableView$BuildMapsSearchView() {
			this.mapsSearchView = tab.ObjectRegistry.newView($tab_MapsSearchView).call(null, [this.get_paneTableVM().get_mapsSearchViewModel()]);
			this.makeMapsSearchViewConnections();
			this.get_paneTableVM().get_mapsSearchViewModel().collapseSearchWidget();
			this.mapsSearchView.addClass(tab.Application.suppressVizTooltipsAndOverlays);
		},
		addMapsSearchViewToDomIfNeeded: function PaneTableView$AddMapsSearchViewToDomIfNeeded() {
			if (!this.$isMapsSearchViewInDom) {
				this.mapsSearchView.addToDom(this.dom.view);
				this.$isMapsSearchViewInDom = true;
			}
		},
		removeMapsSearchViewFromDomIfNeeded: function PaneTableView$RemoveMapsSearchViewFromDomIfNeeded() {
			if (ss.isValue(this.mapsSearchView)) {
				if (this.$isMapsSearchViewInDom) {
					var mapsSearchViewParent = this.mapsSearchView.element[0].parentNode;
					if (ss.isValue(mapsSearchViewParent)) {
						mapsSearchViewParent.removeChild(this.mapsSearchView.element[0]);
						this.$isMapsSearchViewInDom = false;
					}
				}
				this.get_paneTableVM().get_mapsSearchViewModel().collapseSearchWidget();
				this.get_paneTableVM().get_mapsSearchViewModel().setVisible(false);
			}
		},
		handlePropertyChanged: function PaneTableView$HandlePropertyChanged(sender, e) {
			switch (e.get_propertyName()) {
				case 'vizNavigationSetting': {
					this.$attachStaticEventHandlers();
					this.makeInputHandlers();
					break;
				}
				case 'borderHighlight': {
					this.dom.borders.toggleClass('tvBorderHighlight', this.get_paneTableVM().get_highlightBorder());
					break;
				}
				case 'images': {
					this.$redrawCorners();
					break;
				}
				default: {
					tab.Log.get(this).debug('Unhandled property change in PaneTableView for property: %s', [e.get_propertyName()]);
					break;
				}
			}
		},
		updateTooltipMode: function PaneTableView$UpdateTooltipMode(visualModel) {
			if (ss.isValue(this.vizTooltip) && visualModel.get_tooltipMode() !== this.vizTooltip.get_currentTooltipMode()) {
				this.vizTooltip.close();
				this.vizTooltip.dispose();
				this.vizTooltip = null;
			}
		},
		$updateTitle: function PaneTableView$UpdateTitle(visualModel) {
			if (this.get_paneTableVM().get_hasTitle()) {
				if (ss.isValue(this.$titleView)) {
					return;
				}
				this.dom.title.css('display', '');
				var $t1 = new tab.TextRegionViewModel(visualModel.get_titleModel());
				$t1.options = new tab.TextRegionOptions(!tsConfig.is_authoring);
				var trvm = $t1;
				this.$titleView = new tab.TextRegionView(trvm);
				this.$titleAreaId = 'title' + this.$getDashboardViewId();
				this.$titleView.element.attr('id', this.$titleAreaId);
				this.$titleView.addToDom(this.dom.title);
			}
			else if (ss.isValue(this.$titleView)) {
				this.dom.title.css('display', 'none');
				this.$titleView.get_viewModel().dispose();
				this.$titleView = null;
			}
		},
		$updateDebugInfo: function PaneTableView$UpdateDebugInfo(visualModel) {
			if (tab.FeatureParamsLookup.getBool(53)) {
				visualModel.get_runtimeStatusView().addDebugViewToElement(this.dom.enclosingDiv);
			}
		},
		$updateCaption: function PaneTableView$UpdateCaption(visualModel) {
			if (this.get_paneTableVM().get_hasCaption()) {
				if (ss.isValue(this.$captionView)) {
					return;
				}
				this.dom.caption.css('display', '');
				var $t1 = new tab.TextRegionViewModel(visualModel.get_captionModel());
				$t1.options = new tab.TextRegionOptions(!tsConfig.is_authoring);
				var trvm = $t1;
				this.$captionView = new tab.TextRegionView(trvm);
				this.$captionAreaId = 'caption' + this.$getDashboardViewId();
				this.$captionView.element.attr('id', this.$captionAreaId);
				this.$captionView.addToDom(this.dom.caption);
			}
			else if (ss.isValue(this.$captionView)) {
				this.dom.caption.css('display', 'none');
				this.$captionView.get_viewModel().dispose();
				this.$captionView = null;
				this.$captionAreaId = '';
			}
		},
		$updateAccessibilityViewDataInstructions: function PaneTableView$UpdateAccessibilityViewDataInstructions() {
			if (ss.isNullOrUndefined(this.$instructionsDiv)) {
				var instructionsId = 'instructions' + this.$getDashboardViewId();
				this.$instructionsDiv = $('<div/>').attr('id', instructionsId).css('display', 'none');
				this.$instructionsDiv.appendTo(this.dom.enclosingDiv);
			}
			var instructions = tab.Strings.AccessibilityClearSelectionInstructions + ' ' + ($tab_PaneTableView.isViewDataAccessEnabled() ? tab.Strings.AccessibilityViewDataInstructions : tab.Strings.AccessibilityViewDataDisabled);
			this.$instructionsDiv.text(instructions);
		},
		$updateAccessibilityBindingsForView: function PaneTableView$UpdateAccessibilityBindingsForView() {
			this.dom.view.attr('tabindex', '0').attr('role', 'img').attr('aria-describedby', ss.coalesce(this.$captionAreaId, '') + ' ' + (ss.isValue(this.$instructionsDiv) ? this.$instructionsDiv[0].id : ''));
			if (this.get_paneTableVM().get_hasTitle()) {
				this.dom.view.removeAttr('aria-label').attr('aria-labelledby', this.$titleAreaId);
			}
			else {
				this.dom.view.removeAttr('aria-labelledby').attr('aria-label', tab.Strings.AccessibilityDataVisualizationTitleAttr);
			}
		},
		$setupKeyboardAccessibility: function PaneTableView$SetupKeyboardAccessibility() {
			var view = this.dom.view;
			view.focus(ss.mkdel(this, function(e) {
				if (!tab.FeatureFlags.isEnabled('MultiSelect') || !spiff.FocusManager.wasFocusedByClick()) {
					tab.SelectionClientCommands.setActiveZone(this.get_paneTableVM().get_zonePresModel().zoneId, 'replace', null);
					this.$updateAccessibilityViewDataInstructions();
				}
			}));
			this.dom.domRoot.focus(ss.mkdel(this, function(e1) {
				if (!tab.FeatureFlags.isEnabled('MultiSelect') || !spiff.FocusManager.wasFocusedByClick()) {
					tab.SelectionClientCommands.setActiveZone(this.get_paneTableVM().get_zonePresModel().zoneId, 'replace', null);
				}
			}));
			view.keydown(ss.mkdel(this, function(e2) {
				if (e2.which === 13 && $tab_PaneTableView.isViewDataAccessEnabled() && ss.referenceEquals(e2.target, e2.currentTarget)) {
					e2.preventDefault();
					e2.stopPropagation();
					tab.ToolbarServerCommands.exportData();
				}
				else if (e2.which === 27) {
					e2.preventDefault();
					e2.stopPropagation();
					this.clearSelection();
				}
			}));
		},
		$getDashboardViewId: function PaneTableView$GetDashboardViewId() {
			return tab.ModelUtils.findContentDashboard(null).getViewId(this.get_sheetid());
		},
		$handleMapSourceChanged: function PaneTableView$HandleMapSourceChanged() {
			this.get_vizRegion().$setBackgroundMapSize(this.get_paneSize());
			this.get_vizRegion().$swapBackgroundMap();
		},
		$updateBackgroundMap: function PaneTableView$UpdateBackgroundMap() {
			var ms = this.get_paneTableVM().get_mapServerModel();
			var showMap = ms.get_hasPresModel() && ms.get_useFastMaps();
			this.get_vizRegion().$setBackgroundMapSize(this.get_paneSize());
			this.get_vizRegion().$setBackgroundMapVisibility(showMap);
		},
		$updateMapScale: function PaneTableView$UpdateMapScale() {
			if (this.get_paneTableVM().get_isMap()) {
				var mapScaleNeedsUpdate = ss.isNullOrUndefined(this.get_paneTableVM().get_mapScaleViewModel()) || ss.isNullOrUndefined(this.$mapScaleView);
				if (mapScaleNeedsUpdate && ss.isValue(this.get_paneTableVM().get_mapServerModel())) {
					this.get_paneTableVM().set_mapScaleViewModel(new tab.MapScaleViewModel(this.get_paneTableVM().get_mapServerModel().get_mapScaleInfoModel()));
					this.$mapScaleView = tab.ObjectRegistry.newView(ss.makeGenericType(spiff.ReactHostView$3, [tab.MapScaleViewModel, tab.MapScaleComponent, Object])).call(null, [this.get_paneTableVM().get_mapScaleViewModel()]);
					this.$mapScaleView.addToDom(this.dom.view);
				}
			}
			else if (ss.isValue(this.$mapScaleView)) {
				this.$mapScaleView.dispose();
				this.$mapScaleView = null;
			}
		},
		$updateMapAttribution: function PaneTableView$UpdateMapAttribution() {
			var ms = this.get_paneTableVM().get_mapServerModel();
			if (ss.isValue(ms) && ms.get_hasPresModel() && ms.get_isAttributionVisible()) {
				if (ss.isNullOrUndefined(this.$mapAttribution)) {
					this.$mapAttribution = new $tab_MapAttributionTemplate();
					this.$mapAttribution.attributionLink.attr('target', '_blank');
					this.$mapAttribution.attributionLink2.attr('target', '_blank');
					this.dom.view.append(this.$mapAttribution.domRoot);
				}
				this.$mapAttribution.attributionBackground.css('background-color', ms.get_attributionBGColor());
				this.$mapAttribution.attributionLink.text(ms.get_attributionText());
				this.$mapAttribution.attributionLink.css('color', ms.get_attributionTextColor());
				this.$mapAttribution.attributionLink.css('font-size', ms.get_attributionTextSize());
				this.$mapAttribution.attributionLink.css('margin-right', '5px');
				this.$mapAttribution.attributionLink.attr('href', ms.get_attributionUrl());
				this.$mapAttribution.attributionLink2.text(ms.get_attributionText2());
				this.$mapAttribution.attributionLink2.css('color', ms.get_attributionTextColor());
				this.$mapAttribution.attributionLink2.css('font-size', ms.get_attributionTextSize());
				this.$mapAttribution.attributionLink2.attr('href', ms.get_attributionUrl2());
				this.$updateMapAttributionPlacement();
			}
			else if (ss.isValue(this.$mapAttribution)) {
				this.$mapAttribution.dispose();
				this.$mapAttribution = null;
			}
		},
		$updateMapAttributionPlacement: function PaneTableView$UpdateMapAttributionPlacement() {
			if (ss.isValue(this.$mapAttribution)) {
				var BottomPadding = 2;
				var LeftPadding = 2;
				var viewSize = this.get_vizRegion().get_contentProvider().get_effectiveViewSize();
				var documentSize = this.get_vizRegion().get_contentProvider().get_docSize();
				var bottomPosition = Math.min(0, viewSize.h + this.$scrollPos.y - documentSize.h);
				bottomPosition += BottomPadding;
				var leftPosition = Math.min(0, -this.$scrollPos.x);
				leftPosition += LeftPadding;
				this.$mapAttribution.domRoot.css('bottom', bottomPosition + 'px');
				this.$mapAttribution.domRoot.css('left', leftPosition + 'px');
				this.$mapAttribution.domRoot.css('padding', '0 2px');
			}
		},
		$initialImageRefresh: function PaneTableView$InitialImageRefresh() {
			var tileCacheUrl = this.get_paneTableVM().get_tileCacheUrl();
			this.refreshImages(tileCacheUrl);
		},
		$runtimeAxisRegion: function PaneTableView$RuntimeAxisRegion(regionPart) {
			switch (regionPart) {
				case 'bottomaxis':
				case 'topaxis':
				case 'leftaxis': {
					return true;
				}
				default: {
					return false;
				}
			}
		},
		$runtimeHeaderRegion: function PaneTableView$RuntimeHeaderRegion(regionPart) {
			switch (regionPart) {
				case 'xheader': {
					return true;
				}
				default: {
					return false;
				}
			}
		},
		$runtimeRegionSupported: function PaneTableView$RuntimeRegionSupported(regionPart) {
			var visualLayout = this.get_paneTableVM().get_scene().get_runtimeData().get_finalDataStore().VisualLayout;
			if (ss.isNullOrUndefined(visualLayout) || ss.isNullOrUndefined(visualLayout.SceneMarginSupport) || !tab.FeatureFlags.isEnabled('RuntimeVizHeaderRefactor')) {
				return false;
			}
			switch (regionPart) {
				case 'bottomaxis':
				case 'topaxis':
				case 'leftaxis':
				case 'xheader': {
					var index = tab.AxisHolderViewModel.getSceneMarginLocation(regionPart);
					if (index > 0 && index < visualLayout.SceneMarginSupport.length) {
						return visualLayout.SceneMarginSupport[index];
					}
					return false;
				}
				default: {
					return false;
				}
			}
		},
		$updateRegionContentProviders: function PaneTableView$UpdateRegionContentProviders() {
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				this.get_vizRegion().$resetView();
				var $t1 = ss.getEnumerator(Object.keys(this.get_paneTableVM().get_vizRegionMap()));
				try {
					while ($t1.moveNext()) {
						var part = $t1.current();
						var regionPart = tab.ModelUtils.visualPartToRegionMap[part];
						if (ss.isValue(regionPart) && ss.isValue(this.regions[regionPart])) {
							if (this.$runtimeRegionSupported(regionPart)) {
								var contentProvider = null;
								var domNode = this.regionParts.getSelectorForRegion(regionPart);
								var regionNode = $(this.getDomNodeForContentRegion(domNode));
								if (this.$runtimeAxisRegion(regionPart)) {
									var avm = new tab.AxisHolderViewModel(this.get_paneTableVM().get_scene().get_runtimeData(), regionPart);
									contentProvider = new tab.AxisHolderElement(regionNode, avm);
								}
								else if (this.$runtimeHeaderRegion(regionPart)) {
									var hvm = new tab.HeaderHolderViewModel(this.get_paneTableVM().get_scene().get_runtimeData(), regionPart);
									contentProvider = new tab.HeaderHolderElement(regionNode, hvm);
								}
								this.updateRegionContentProvider(regionPart, contentProvider);
							}
							else {
								var contentProvider1 = ss.safeCast(this.regions[regionPart].get_contentProvider(), $tab_SimpleRegionCanvasView);
								if (ss.isValue(contentProvider1) && !ss.referenceEquals(contentProvider1.get_viewModel(), this.get_paneTableVM().get_vizRegionMap()[part])) {
									contentProvider1.destroy();
									contentProvider1 = null;
								}
								if (ss.isNullOrUndefined(contentProvider1)) {
									var domNode1 = this.regionParts.getSelectorForRegion(regionPart);
									if (ss.isValue(domNode1)) {
										var vlvm = this.get_paneTableVM().get_vizRegionMap()[part];
										var canvasView = new $tab_SimpleRegionCanvasView(vlvm, this.getDomNodeForContentRegion(domNode1), this.get_paneTableVM());
										domNode1.find('.tvimagesContainer').append(canvasView.element);
										this.updateRegionContentProvider(regionPart, canvasView);
										canvasView.invalidate(false);
										this.get_geometryArgCache().clear();
									}
								}
								else {
									this.regions[regionPart].$resetView();
								}
							}
						}
					}
				}
				finally {
					$t1.dispose();
				}
				var $t2 = ss.getEnumerator(Object.keys(tab.ModelUtils.visualPartToRegionMap));
				try {
					while ($t2.moveNext()) {
						var part1 = $t2.current();
						var regionPart1 = tab.ModelUtils.visualPartToRegionMap[part1];
						if (!ss.keyExists(this.get_paneTableVM().get_vizRegionMap(), part1) && ss.isValue(this.regions[regionPart1])) {
							this.regions[regionPart1].get_contentProvider().destroy();
							this.regions[regionPart1].set_contentProvider(new $tab_EmptyContentProvider());
						}
					}
				}
				finally {
					$t2.dispose();
				}
			}
		},
		$getRequestId: function PaneTableView$GetRequestId() {
			return this.$timestamp + 'Z' + this.$requestId;
		},
		handleMoveMapToBounds: function PaneTableView$HandleMoveMapToBounds(bounds) {
			if (ss.isValue(this.get_vizRegion()) && (tab.FeatureParamsLookup.getBool(19) || tab.FeatureFlags.isEnabled('MapboxVector'))) {
				this.get_vizRegion().moveMapToBounds(bounds);
			}
		},
		$attachStaticEventHandlers: function PaneTableView$AttachStaticEventHandlers() {
			var $t1 = new EventUtils.EventHandleSpec();
			$t1.tap = ss.mkdel(this, function(e) {
				e.stopPropagation();
				e.preventDefault();
				this.clearSelection();
			});
			var spec = $t1;
			var attachActiveZoneHandler = ss.mkdel(this, function(o) {
				this.disposables.add$1(new EventUtils.TableauEventHandler(o.get(0), spec));
			});
			for (var $t2 = 0; $t2 < $tab_PaneTableViewRegionParts.regionsThatClearSelectionOnTap.length; $t2++) {
				var regionPart = $tab_PaneTableViewRegionParts.regionsThatClearSelectionOnTap[$t2];
				attachActiveZoneHandler(this.regionParts.getSelectorForRegion(regionPart));
			}
		},
		$makeSubscriptions: function PaneTableView$MakeSubscriptions() {
			tab.ViewController.add_selectionChanged(ss.mkdel(this, this.$onSelectionChanged));
			this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
				tab.ViewController.remove_selectionChanged(ss.mkdel(this, this.$onSelectionChanged));
			})));
		},
		onAddedToDom: function PaneTableView$OnAddedToDom() {
			spiff.Widget.prototype.onAddedToDom.call(this);
			var css = ss.mkdict(['top', '0px', 'left', '0px', 'right', '0px', 'bottom', '0px']);
			this.get_template().domRoot.css(css);
			this.handleNewVisual();
			if (this.get_paneTableVM().get_visualModel().get_isVisualValidAndUpToDate()) {
				this.$initialImageRefresh();
			}
		},
		checkForSuppressTooltipsAndOverlays: function PaneTableView$CheckForSuppressTooltipsAndOverlays(element) {
			var queryObject = $(element);
			var hasSuppressClass = queryObject.hasClass(tab.Application.suppressVizTooltipsAndOverlays) || queryObject.parents('.tabSuppressVizTooltipsAndOverlays').length > 0;
			if (hasSuppressClass) {
				this.disposeOfOverlayImages();
				var tooltip = this.get_vizToolTip();
				tooltip.clearTooltipWithFakeHover();
			}
			this.get_vizToolTip().suppress(hasSuppressClass);
		},
		$ensureTooltip: function PaneTableView$EnsureTooltip() {
			if (ss.isNullOrUndefined(this.vizTooltip) || !this.get_isSameVisualID()) {
				this.vizTooltip = this.makeTooltip();
				this.connectTooltipEventHandlers();
			}
		},
		getVisualListViewModelForRegion: function PaneTableView$GetVisualListViewModelForRegion(regionPart) {
			var visualPart = tab.ModelUtils.regionToVisualPartMap[regionPart];
			return this.get_paneTableVM().get_vizRegionMap()[visualPart];
		}
	}, ss.makeGenericType(spiff.BaseView$1, [tab.IPaneTableViewModel]), [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [tab.IPaneTableViewModel]), tab.IPaneTableView, $tab_IZoomToolbarContainer]);
	ss.initClass($tab_PaneTableViewModel, $asm, {
		add_vizRegionMapChange: function PaneTableViewModel$add_VizRegionMapChange(value) {
			this.$2$VizRegionMapChangeField = ss.delegateCombine(this.$2$VizRegionMapChangeField, value);
		},
		remove_vizRegionMapChange: function PaneTableViewModel$remove_VizRegionMapChange(value) {
			this.$2$VizRegionMapChangeField = ss.delegateRemove(this.$2$VizRegionMapChangeField, value);
		},
		add_newPaneTable: function PaneTableViewModel$add_NewPaneTable(value) {
			this.$2$NewPaneTableField = ss.delegateCombine(this.$2$NewPaneTableField, value);
		},
		remove_newPaneTable: function PaneTableViewModel$remove_NewPaneTable(value) {
			this.$2$NewPaneTableField = ss.delegateRemove(this.$2$NewPaneTableField, value);
		},
		add_textUpdated: function PaneTableViewModel$add_TextUpdated(value) {
			this.$2$TextUpdatedField = ss.delegateCombine(this.$2$TextUpdatedField, value);
		},
		remove_textUpdated: function PaneTableViewModel$remove_TextUpdated(value) {
			this.$2$TextUpdatedField = ss.delegateRemove(this.$2$TextUpdatedField, value);
		},
		add_differentMarkBrushing: function PaneTableViewModel$add_DifferentMarkBrushing(value) {
			this.$2$DifferentMarkBrushingField = ss.delegateCombine(this.$2$DifferentMarkBrushingField, value);
		},
		remove_differentMarkBrushing: function PaneTableViewModel$remove_DifferentMarkBrushing(value) {
			this.$2$DifferentMarkBrushingField = ss.delegateRemove(this.$2$DifferentMarkBrushingField, value);
		},
		add_differentMarkSelection: function PaneTableViewModel$add_DifferentMarkSelection(value) {
			this.$2$DifferentMarkSelectionField = ss.delegateCombine(this.$2$DifferentMarkSelectionField, value);
		},
		remove_differentMarkSelection: function PaneTableViewModel$remove_DifferentMarkSelection(value) {
			this.$2$DifferentMarkSelectionField = ss.delegateRemove(this.$2$DifferentMarkSelectionField, value);
		},
		get_isMap: function PaneTableViewModel$get_IsMap() {
			return this.$visModel.get_isMap();
		},
		get_isMapWithBaseLayer: function PaneTableViewModel$get_IsMapWithBaseLayer() {
			return this.get_isMap() && this.get_mapServerModel().get_hasPresModel();
		},
		get_mapSearchEnabled: function PaneTableViewModel$get_MapSearchEnabled() {
			return tsConfig.allow_filter && this.get_isMap() && this.get_visualModel().get_geoSearchVisibility() === 'on' && !tab.ApplicationModel.get_instance().get_isOffline();
		},
		get_tooltipContextProvider: function PaneTableViewModel$get_TooltipContextProvider() {
			return (tab.ApplicationModel.get_instance().get_isLocalRenderMode() ? new tab.TooltipContextProvider(this.get_visualModel().get_selectionsModel()) : null);
		},
		get_scene: function PaneTableViewModel$get_Scene() {
			return this.$sceneInfo;
		},
		get_localRenderVizHitTester: function PaneTableViewModel$get_LocalRenderVizHitTester() {
			return this.$localRenderVizHitTester;
		},
		get_vizRegionMap: function PaneTableViewModel$get_VizRegionMap() {
			return this.$vizRegionViewModels;
		},
		get_refLineVisualLists: function PaneTableViewModel$get_RefLineVisualLists() {
			return this.get_$sceneModel().get_refLineVisualLists();
		},
		get_trendLineVisualLists: function PaneTableViewModel$get_TrendLineVisualLists() {
			return this.get_$sceneModel().get_trendLineVisualLists();
		},
		get_drawFirstParts: function PaneTableViewModel$get_DrawFirstParts() {
			return this.get_$sceneModel().get_drawFirstParts();
		},
		get_drawLastParts: function PaneTableViewModel$get_DrawLastParts() {
			return this.get_$sceneModel().get_drawLastParts();
		},
		get_zonePresModel: function PaneTableViewModel$get_ZonePresModel() {
			return this.$visModel.get_zone().pm;
		},
		get_viewController: function PaneTableViewModel$get_ViewController() {
			return this.$2$ViewControllerField;
		},
		set_viewController: function PaneTableViewModel$set_ViewController(value) {
			this.$2$ViewControllerField = value;
		},
		get_sheetId: function PaneTableViewModel$get_SheetId() {
			return this.get_visualModel().get_worksheetName();
		},
		get_sortIndicators: function PaneTableViewModel$get_SortIndicators() {
			return this.$visModel.get_sortIndicatorsModel().get_sortIndicatorsPresModel();
		},
		get_axisRegions: function PaneTableViewModel$get_AxisRegions() {
			return this.$visModel.get_axisRegionModel();
		},
		get_selectionsModel: function PaneTableViewModel$get_SelectionsModel() {
			return this.$visModel.get_selectionsModel();
		},
		get_tileCacheUrl: function PaneTableViewModel$get_TileCacheUrl() {
			return this.$visModel.get_tileCacheUrl();
		},
		get_hasTitle: function PaneTableViewModel$get_HasTitle() {
			return this.get_zonePresModel().zoneCommon.hasTitle;
		},
		get_hasCaption: function PaneTableViewModel$get_HasCaption() {
			return this.get_zonePresModel().hasCaption;
		},
		get_visualModel: function PaneTableViewModel$get_VisualModel() {
			return this.$visModel;
		},
		get_$sceneModel: function PaneTableViewModel$get_SceneModel() {
			return this.$visModel.get_sceneModel();
		},
		get_visualId: function PaneTableViewModel$get_VisualId() {
			return this.$visModel.get_visualId();
		},
		get_mapServerModel: function PaneTableViewModel$get_MapServerModel() {
			return this.get_visualModel().get_mapServerModel();
		},
		get_vizContextMenuViewModel: function PaneTableViewModel$get_VizContextMenuViewModel() {
			return this.$vizContextMenuViewModel;
		},
		get_annotationSelectionChromeViewModel: function PaneTableViewModel$get_AnnotationSelectionChromeViewModel() {
			return this.$annotationSelectionChromeViewModel;
		},
		get_mapsSearchViewModel: function PaneTableViewModel$get_MapsSearchViewModel() {
			return this.$mapsSearchViewModel;
		},
		set_mapsSearchViewModel: function PaneTableViewModel$set_MapsSearchViewModel(value) {
			this.$mapsSearchViewModel = value;
		},
		get_mapScaleViewModel: function PaneTableViewModel$get_MapScaleViewModel() {
			return this.$mapScaleViewModel;
		},
		set_mapScaleViewModel: function PaneTableViewModel$set_MapScaleViewModel(value) {
			this.$mapScaleViewModel = value;
		},
		get_vizRegionToolModeViewModel: function PaneTableViewModel$get_VizRegionToolModeViewModel() {
			return this.$vizRegionToolModeViewModel;
		},
		get_floatingToolbarContainerVM: function PaneTableViewModel$get_FloatingToolbarContainerVM() {
			return this.$2$FloatingToolbarContainerVMField;
		},
		set_floatingToolbarContainerVM: function PaneTableViewModel$set_FloatingToolbarContainerVM(value) {
			this.$2$FloatingToolbarContainerVMField = value;
		},
		get_smoothTooltipsOnboardingVM: function PaneTableViewModel$get_SmoothTooltipsOnboardingVM() {
			return this.$2$SmoothTooltipsOnboardingVMField;
		},
		set_smoothTooltipsOnboardingVM: function PaneTableViewModel$set_SmoothTooltipsOnboardingVM(value) {
			this.$2$SmoothTooltipsOnboardingVMField = value;
		},
		get_highlightBorder: function PaneTableViewModel$get_HighlightBorder() {
			return this.borderHighlighted;
		},
		set_highlightBorder: function PaneTableViewModel$set_HighlightBorder(value) {
			if (this.borderHighlighted === value) {
				return;
			}
			this.borderHighlighted = value;
			this.notifyPropertyChanged($tab_PaneTableViewModel.borderHighlightPropertyName);
		},
		get_annotationDictionary: function PaneTableViewModel$get_AnnotationDictionary() {
			var dict = {};
			var annotationList = this.get_visualModel().getAnnotationList();
			for (var $t1 = 0; $t1 < annotationList.length; $t1++) {
				var annotation = annotationList[$t1];
				dict[annotation.annotationId] = annotation;
			}
			return dict;
		},
		$loadResizeHeadersModule: function PaneTableViewModel$LoadResizeHeadersModule() {
			var deferredFactory = $.Deferred();
			this.deferredResizerFactory = deferredFactory.promise();
			if (tsConfig.is_authoring) {
				tab.ModuleManager.load(tab.IResizeHeadersModule).call(null, []).done(function(module) {
					deferredFactory.resolve(module);
				});
			}
		},
		$initializeHeaderResizerManagerViewModel: function PaneTableViewModel$InitializeHeaderResizerManagerViewModel() {
			if (tsConfig.is_authoring && ss.isValue(this.$visModel.resizeInfoModel)) {
				var deferredManager = $.Deferred();
				this.deferredHeaderResizerManagerViewModel = deferredManager.promise();
				this.deferredResizerFactory.done(ss.mkdel(this, function(factory) {
					deferredManager.resolve(factory.newHeaderResizerManagerViewModel(this.$visModel.resizeInfoModel, this.$visModel.get_visualId()));
				}));
			}
		},
		$initializeCellResizerManagerViewModel: function PaneTableViewModel$InitializeCellResizerManagerViewModel() {
			if (tsConfig.is_authoring && ss.isValue(this.$visModel.resizeInfoModel)) {
				var deferredManager = $.Deferred();
				this.deferredCellResizerManagerViewModel = deferredManager.promise();
				this.deferredResizerFactory.done(ss.mkdel(this, function(factory) {
					deferredManager.resolve(factory.newCellResizerManagerViewModel(this.$visModel.resizeInfoModel, this.$visModel.get_visualId()));
				}));
			}
		},
		$initializeVizContextMenuViewModel: function PaneTableViewModel$InitializeVizContextMenuViewModel() {
			if (tsConfig.is_authoring && !tsConfig.is_mobile && (tab.FeatureFlags.isEnabled('RichTextCreateBlankAreaAnnotation') || tab.FeatureFlags.isEnabled('RichTextCreateBlankPointAndMarkAnnotation') || tab.FeatureFlags.isEnabled('RichTextCreateAnnotationAndOpenEditor') || tab.FeatureFlags.isEnabled('RichTextDeleteAnnotation'))) {
				this.$vizContextMenuViewModel = new $tab_VizContextMenuViewModel(null);
			}
		},
		$initializeAnnotationSelectionChromeViewModel: function PaneTableViewModel$InitializeAnnotationSelectionChromeViewModel() {
			if (tsConfig.is_authoring && tsConfig.current_sheet_type !== 'story' && !tsConfig.is_mobile && (tab.FeatureFlags.isEnabled('RichTextSelectAnnotation') || tab.FeatureFlags.isEnabled('RichTextDeleteAnnotation'))) {
				var getDictionary = ss.mkdel(this, function() {
					return this.get_annotationDictionary();
				});
				this.$annotationSelectionChromeViewModel = new $tab_AnnotationSelectionChromeViewModel(this.get_visualId(), getDictionary);
				this.$annotationSelectionChromeViewModel.setContextMenuViewModel(this.$vizContextMenuViewModel);
				if (ss.isValue(this.get_vizRegionToolModeViewModel())) {
					this.get_vizRegionToolModeViewModel().add_toolbarToolModeUpdated(ss.mkdel(this, this.$handleToolbarUpdated));
					this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
						this.get_vizRegionToolModeViewModel().remove_toolbarToolModeUpdated(ss.mkdel(this, this.$handleToolbarUpdated));
					})));
				}
				if (ss.isValue(this.$visModel.get_zone()) && ss.isValue(this.$visModel.get_zone().get_dashboardModel())) {
					this.$visModel.get_zone().get_dashboardModel().add_activeZoneChanged(ss.mkdel(this, function() {
						if (this.$visModel.get_zone().get_dashboardModel().get_activeZoneID() !== this.$visModel.get_zone().get_zoneId() && this.$visModel.get_zone().get_dashboardModel().get_activeZoneID() !== 0) {
							this.$annotationSelectionChromeViewModel.clearSelection();
						}
					}));
				}
			}
		},
		$handleToolbarUpdated: function PaneTableViewModel$HandleToolbarUpdated(selection) {
			if (selection === 'area-zoom') {
				this.clearAnnotationSelection();
			}
		},
		handleRightClick: function PaneTableViewModel$HandleRightClick(result, p) {
			if (ss.isValue(this.$annotationSelectionChromeViewModel) && result.get_hitObjectType() === 2) {
				this.$annotationSelectionChromeViewModel.handleRightClick(result, p);
			}
			else if (tab.FeatureFlags.isEnabled('RichTextCreateBlankAreaAnnotation') || tab.FeatureFlags.isEnabled('RichTextCreateBlankPointAndMarkAnnotation') || tab.FeatureFlags.isEnabled('RichTextCreateAnnotationAndOpenEditor')) {
				if (ss.isValue(this.$annotationSelectionChromeViewModel)) {
					this.$annotationSelectionChromeViewModel.clearSelection();
				}
				var handler = new $tab_VizContextMenuItemsHandler(result, p, this.get_visualId());
				this.$vizContextMenuViewModel.show(p, [handler]);
			}
		},
		hideAnnotations: function PaneTableViewModel$HideAnnotations() {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				this.get_annotationSelectionChromeViewModel().hideAll();
			}
		},
		handleMouseWheelScroll: function PaneTableViewModel$HandleMouseWheelScroll() {
			if (this.$visModel.get_isMap()) {
				this.hideAnnotations();
			}
		},
		handleAnnotationDragStarted: function PaneTableViewModel$HandleAnnotationDragStarted(pt) {
			var htr = this.get_localRenderVizHitTester().onTapHitTest(pt);
			if (this.get_vizRegionToolModeViewModel().get_isZoomToolActive()) {
				this.hideAnnotations();
				return false;
			}
			else if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				if (this.get_annotationSelectionChromeViewModel().dragStarted(htr, pt)) {
					return true;
				}
				if (this.get_vizRegionToolModeViewModel().get_isPanToolActive()) {
					this.hideAnnotations();
				}
				else {
					this.clearAnnotationSelection();
				}
			}
			return false;
		},
		handleDrag: function PaneTableViewModel$HandleDrag(point) {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				this.get_annotationSelectionChromeViewModel().onDrag(point);
			}
		},
		handleDragEnded: function PaneTableViewModel$HandleDragEnded(endpoint) {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				if (this.get_vizRegionToolModeViewModel().get_isZoomToolActive()) {
					this.get_annotationSelectionChromeViewModel().hideAll();
				}
				this.get_annotationSelectionChromeViewModel().dragEnded(endpoint);
			}
		},
		vizContextMenuOpened: function PaneTableViewModel$VizContextMenuOpened() {
			return ss.isValue(this.$vizContextMenuViewModel) && !this.$vizContextMenuViewModel.isHidden || ss.isValue(this.get_annotationSelectionChromeViewModel()) && this.get_annotationSelectionChromeViewModel().isCaretMenuOpened();
		},
		canDeleteAnnotationWithKeystroke: function PaneTableViewModel$CanDeleteAnnotationWithKeystroke() {
			return ss.isValue(this.get_annotationSelectionChromeViewModel()) && tab.FeatureFlags.isEnabled('RichTextDeleteAnnotation') && tab.FeatureFlags.isEnabled('RichTextSelectAnnotation');
		},
		isAnnotationDragging: function PaneTableViewModel$IsAnnotationDragging() {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				return this.get_annotationSelectionChromeViewModel().isDragging();
			}
			return false;
		},
		dispose: function PaneTableViewModel$Dispose() {
			if (ss.isValue(this.$mapsSearchViewModel)) {
				this.$mapsSearchViewModel.dispose();
			}
			if (ss.isValue(this.$mapScaleViewModel)) {
				this.$mapScaleViewModel.dispose();
			}
			if (ss.isValue(this.$vizContextMenuViewModel)) {
				this.$vizContextMenuViewModel.dispose();
			}
			if (ss.isValue(this.$annotationSelectionChromeViewModel)) {
				this.$annotationSelectionChromeViewModel.dispose();
			}
			if (ss.isValue(this.$visModel)) {
				if (ss.isValue(this.$visModel.get_selectionsModel().tupleSelection)) {
					this.$visModel.get_selectionsModel().remove_newSelections(ss.mkdel(this, this.$handleSelectionChange));
				}
				this.$visModel.get_impliedSelectionModel().remove_newSelection(ss.mkdel(this, this.$handleSelectionChange));
				if (ss.isValue(this.$visModel.get_brushingsModel().tupleSelection)) {
					this.$visModel.get_brushingsModel().remove_newSelections(ss.mkdel(this, this.$handleBrushingChange));
				}
				if (ss.isValue(this.$visModel.get_sceneModel())) {
					this.$visModel.get_sceneModel().remove_newSceneModel(ss.mkdel(this, this.$handleSceneChange));
				}
				this.$visModel.remove_newHiddenTuples(ss.mkdel(this, this.$handleHiddenTuplesChange));
				this.$visModel.remove_newFilteredTuples(ss.mkdel(this, this.$handleFilteredTuplesChange));
				this.$visModel.remove_brushingFromActionChanged(ss.mkdel(this, this.$handleBrushingFromActionChanged));
				this.$visModel.remove_colorDictionaryChanged(ss.mkdel(this, this.$handleColorDictionaryChange));
				this.$visModel.remove_vizNavigationSettingChanged(ss.mkdel(this, this.$handleVizNavigationSettingChange));
				this.$visModel.remove_newVisual(ss.mkdel(this, this.$handleVisualChanged));
				this.$visModel.remove_newVisual(ss.mkdel(this, this.$handleNewPaneTable));
				this.$visModel.remove_emptyHighlightFogAllChanged(ss.mkdel(this, this.$handleEmptyHighlightFogAllChanged));
				this.$customShapesPending = tab.MiscUtil.dispose$1(this.$customShapesPending);
			}
			var $t1 = new ss.ObjectEnumerator(this.$vizRegionViewModels);
			try {
				while ($t1.moveNext()) {
					var pair = $t1.current();
					pair.value.dispose();
				}
			}
			finally {
				$t1.dispose();
			}
			this.$vizRegionToolModeViewModel.dispose();
			this.get_floatingToolbarContainerVM().dispose();
			this.get_smoothTooltipsOnboardingVM().dispose();
			spiff.BaseViewModel.prototype.dispose.call(this);
		},
		getAndClearInvalidationRects: function PaneTableViewModel$GetAndClearInvalidationRects() {
			var rects = this.$invalidationRects;
			this.$invalidationRects = [];
			return rects;
		},
		handleAnnotationDoubleClicked: function PaneTableViewModel$HandleAnnotationDoubleClicked(ids) {
			this.clearAnnotationSelection();
			tab.RichTextClientCommands.createAnnotationRichTextEditor(this.get_sheetId(), ids);
			tab.FormattingTelemetryClient.logRichTextEditorEvent(ss.mkdict([tab.FormattingTelemetryClient.richTextEditorOpenedBy, tab.FormattingTelemetryClient.richTextEditorOpenedByDoubleClick, tab.FormattingTelemetryClient.richTextEditorOpenedFrom, tab.FormattingTelemetryClient.annotation]));
		},
		handleAnnotationHover: function PaneTableViewModel$HandleAnnotationHover(coords) {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel()) && !this.get_vizRegionToolModeViewModel().get_isZoomToolActive()) {
				this.get_annotationSelectionChromeViewModel().onHover(this.get_localRenderVizHitTester().onHoverHitTest(coords));
			}
		},
		$handleImageLoaded: function PaneTableViewModel$HandleImageLoaded() {
			this.notifyPropertyChanged($tab_PaneTableViewModel.imageLoadedPropertyName);
		},
		$handleVizNavigationSettingChange: function PaneTableViewModel$HandleVizNavigationSettingChange() {
			this.notifyPropertyChanged($tab_PaneTableViewModel.vizNavigationSettingPropertyName);
		},
		$handleSelectionChange: function PaneTableViewModel$HandleSelectionChange() {
			var selectionsDiff = this.$visModel.get_selectionsModel().computeSelectionsDiff(this.$selectionsToken, this.$impliedSelectionsToken, this.$visModel.get_impliedSelectionModel());
			if (!ss.staticEquals(this.$2$DifferentMarkSelectionField, null) && $tab_PaneTableViewModel.$hasTupleDifference(selectionsDiff, this.$visModel.get_selectionsModel(), this.$visModel.get_impliedSelectionModel())) {
				this.$2$DifferentMarkSelectionField();
			}
			this.$selectionsToken = this.$visModel.get_selectionsModel().createSelectionsToken();
			this.$impliedSelectionsToken = this.$visModel.get_impliedSelectionModel().createSelectionToken();
			this.$selectionBrushingChangeHelper(selectionsDiff, 'selection');
		},
		$handleBrushingChange: function PaneTableViewModel$HandleBrushingChange() {
			var brushingDiff = this.$visModel.get_brushingsModel().computeSelectionsDiff(this.$brushingsToken, null, null);
			if (!ss.staticEquals(this.$2$DifferentMarkBrushingField, null) && $tab_PaneTableViewModel.$hasTupleDifference(brushingDiff, this.$visModel.get_brushingsModel(), null)) {
				this.$2$DifferentMarkBrushingField();
			}
			this.$brushingsToken = this.$visModel.get_brushingsModel().createSelectionsToken();
			this.$sceneInfo.setEmptyHighlightFogAll(this.$visModel.get_emptyHighlightFogAll());
			this.$selectionBrushingChangeHelper(brushingDiff, 'brushing');
		},
		$selectionBrushingChangeHelper: function PaneTableViewModel$SelectionBrushingChangeHelper(selectionsDiff, propertyThatChanged) {
			if (!selectionsDiff.get_invalidateViz()) {
				if (selectionsDiff.get_objectIds().length === 0) {
					return;
				}
				var invalRects = this.$sceneInfo.getMarksInvalidationRects(selectionsDiff.get_objectIds());
				this.$addInvalidationRects(invalRects);
			}
			this.notifyPropertyChanged(propertyThatChanged);
		},
		$handleBrushingFromActionChanged: function PaneTableViewModel$HandleBrushingFromActionChanged() {
			this.$sceneInfo.setIsTargetOfBrushingAction(this.$visModel.get_isBrushedFromAction());
			this.notifyPropertyChanged('brushing');
		},
		$handleEmptyHighlightFogAllChanged: function PaneTableViewModel$HandleEmptyHighlightFogAllChanged() {
			this.$sceneInfo.setEmptyHighlightFogAll(this.$visModel.get_emptyHighlightFogAll());
			this.$sceneDirty = true;
		},
		$handleHiddenTuplesChange: function PaneTableViewModel$HandleHiddenTuplesChange() {
			var delta = tab.SelectionsModel.computeTupleDictionaryDifference(this.$visModel.get_hiddenTuples(), this.$sceneInfo.get_hiddenTuples());
			if (delta.length === 0) {
				return;
			}
			var invalRects = this.$sceneInfo.getMarksInvalidationRects(delta);
			this.$addInvalidationRects(invalRects);
			this.$sceneInfo.set_hiddenTuples(this.$visModel.get_hiddenTuples());
			this.$notifySceneChanged();
		},
		$handleFilteredTuplesChange: function PaneTableViewModel$HandleFilteredTuplesChange() {
			var delta = tab.SelectionsModel.computeTupleDictionaryDifference(this.$visModel.get_filteredTuples(), this.$sceneInfo.get_filteredTuples());
			if (delta.length === 0) {
				return;
			}
			var invalRects = this.$sceneInfo.getMarksInvalidationRects(delta);
			this.$addInvalidationRects(invalRects);
			this.$sceneInfo.set_filteredTuples(this.$visModel.get_filteredTuples());
			this.$notifySceneChanged();
		},
		$handleColorDictionaryChange: function PaneTableViewModel$HandleColorDictionaryChange() {
			this.$sceneDirty = true;
		},
		$addInvalidationRects: function PaneTableViewModel$AddInvalidationRects(rects) {
			ss.arrayAddRange(this.$invalidationRects, rects);
		},
		$handleServerRenderedAnnotationChange: function PaneTableViewModel$HandleServerRenderedAnnotationChange() {
			this.$notifySceneChanged();
		},
		handleAnnotationSelection: function PaneTableViewModel$HandleAnnotationSelection(regionCoords, action, e) {
			this.handleAnnotationSelection$1(this.get_localRenderVizHitTester().onTapHitTest(regionCoords), action, e);
		},
		handleAnnotationSelection$1: function PaneTableViewModel$HandleAnnotationSelection(htr, action, e) {
			var current = this.get_vizRegionToolModeViewModel().get_currentToolbarToolMode();
			if (ss.isNullOrUndefined(this.get_annotationSelectionChromeViewModel()) || !tab.FeatureFlags.isEnabled('RichTextSelectAnnotation') || current === 'area-zoom') {
				return;
			}
			if (ss.isNullOrUndefined(htr) || htr.get_hitObjectType() !== 2) {
				this.clearAnnotationSelection();
			}
			else {
				this.get_annotationSelectionChromeViewModel().handleAnnotationClicked(htr.get_id(), e, action === 'toggle');
			}
		},
		deleteSelectedAnnotations: function PaneTableViewModel$DeleteSelectedAnnotations() {
			if (ss.isNullOrUndefined(this.get_annotationSelectionChromeViewModel())) {
				return;
			}
			this.get_annotationSelectionChromeViewModel().deleteSelectedAnnotationsFromKeystroke();
		},
		clearAnnotationSelection: function PaneTableViewModel$ClearAnnotationSelection() {
			if (ss.isNullOrUndefined(this.get_annotationSelectionChromeViewModel())) {
				return;
			}
			this.get_annotationSelectionChromeViewModel().clearSelection();
		},
		updateAnnotationSelection: function PaneTableViewModel$UpdateAnnotationSelection() {
			if (ss.isNullOrUndefined(this.get_annotationSelectionChromeViewModel())) {
				return;
			}
			this.get_annotationSelectionChromeViewModel().update();
		},
		scrollX: function PaneTableViewModel$ScrollX(offsetX) {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				this.get_annotationSelectionChromeViewModel().scrollX(offsetX);
			}
			if (ss.isValue(this.get_vizContextMenuViewModel())) {
				this.get_vizContextMenuViewModel().get_scrollOffset().x = offsetX;
			}
		},
		scrollY: function PaneTableViewModel$ScrollY(offsetY) {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				this.get_annotationSelectionChromeViewModel().scrollY(offsetY);
			}
			if (ss.isValue(this.get_vizContextMenuViewModel())) {
				this.get_vizContextMenuViewModel().get_scrollOffset().y = offsetY;
			}
		},
		updateGeometry: function PaneTableViewModel$UpdateGeometry(domRegion) {
			if (ss.isValue(this.get_annotationSelectionChromeViewModel())) {
				this.get_annotationSelectionChromeViewModel().setBounds(domRegion);
			}
		},
		$handleSceneChange: function PaneTableViewModel$HandleSceneChange() {
			if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				return;
			}
			var regionChange = false;
			var $t1 = ss.getEnumerator(Object.keys(this.get_$sceneModel().get_visualListModels()));
			try {
				while ($t1.moveNext()) {
					var vizPart = $t1.current();
					var vlm = this.get_$sceneModel().get_visualListModels()[vizPart];
					var currentPart = this.$vizRegionViewModels[vizPart];
					if (ss.isValue(currentPart) && ss.referenceEquals(currentPart.get_visualList(), vlm)) {
					}
					else {
						tab.MiscUtil.dispose$1(this.$vizRegionViewModels[vizPart]);
						delete this.$vizRegionViewModels[vizPart];
						if (ss.contains($tab_PaneTableViewModel.blackListVisualParts, vizPart)) {
							this.$vizRegionViewModels[vizPart] = new $tab_VisualListViewModel(vlm, this.get_visualId(), tab.ModelUtils.visualPartToRegionMap[vizPart], this.$visModel.get_selectionsModel(), this.$visModel.get_brushingsModel());
						}
						else {
							this.$vizRegionViewModels[vizPart] = new $tab_VisualListViewModel(vlm, this.get_visualId(), tab.ModelUtils.visualPartToRegionMap[vizPart], null, null);
						}
						regionChange = true;
					}
				}
			}
			finally {
				$t1.dispose();
			}
			var keys = Object.keys(this.$vizRegionViewModels);
			var $t2 = ss.getEnumerator(keys);
			try {
				while ($t2.moveNext()) {
					var vizPart1 = $t2.current();
					if (!ss.keyExists(this.get_$sceneModel().get_visualListModels(), vizPart1)) {
						tab.MiscUtil.dispose$1(this.$vizRegionViewModels[vizPart1]);
						delete this.$vizRegionViewModels[vizPart1];
						regionChange = true;
					}
				}
			}
			finally {
				$t2.dispose();
			}
			var defaultBackgroundColor = this.get_visualModel().get_backgroundColor().toString();
			var $t3 = ss.getEnumerator(Object.keys(this.$vizRegionViewModels));
			try {
				while ($t3.moveNext()) {
					var part = $t3.current();
					this.$vizRegionViewModels[part].set_defaultBackgroundColor(defaultBackgroundColor);
				}
			}
			finally {
				$t3.dispose();
			}
			if (regionChange) {
				this.$raiseVizRegionMapChange();
			}
			this.$sceneDirty = true;
		},
		$handleVisualChanged: function PaneTableViewModel$HandleVisualChanged() {
			if (tab.AnimationUtil.isUpdating() || this.$sceneDirty) {
				this.$updateSceneInfo();
				this.$notifySceneChanged();
			}
			this.$sceneDirty = false;
		},
		$raiseVizRegionMapChange: function PaneTableViewModel$RaiseVizRegionMapChange() {
			if (ss.isValue(this.$2$VizRegionMapChangeField)) {
				this.$2$VizRegionMapChangeField();
			}
		},
		$updateSceneInfo: function PaneTableViewModel$UpdateSceneInfo() {
			$tab_PaneTableViewModel.updateSceneInfoFromVisualModel(this.$sceneInfo, this.$visModel);
			if (this.$sceneInfo.customShapes.length > 0) {
				this.$customShapesPending = this.$customShapesPending || new $tab_ShapeDependencyManager(ss.mkdel(this, function() {
					this.notifyPropertyChanged($tab_PaneTableViewModel.imageLoadedPropertyName);
				}));
				this.$customShapesPending.initialize(this.$sceneInfo.customShapes);
			}
			if (ss.isValue(this.$visModel) && ss.isValue(this.$visModel.pm) && ss.isValue(this.$visModel.pm.imageDictionary)) {
				this.$sceneInfo.updateImageMap(this.$visModel.pm.imageDictionary, ss.mkdel(this, this.$handleImageLoaded));
			}
		},
		$notifySceneChanged: function PaneTableViewModel$NotifySceneChanged() {
			this.$localRenderVizHitTester.clearCache();
			this.notifyPropertyChanged($tab_PaneTableViewModel.sceneChangedPropertyName);
		},
		isInvalidSheet: function PaneTableViewModel$IsInvalidSheet() {
			return _.any(this.$visModel.get_invalidSheets(), ss.mkdel(this, function(model) {
				return _.isEqual(this.get_visualId(), model);
			}));
		},
		$handleNewPaneTable: function PaneTableViewModel$HandleNewPaneTable() {
			this.raiseActionEvent(this.$2$NewPaneTableField);
		},
		shouldEnableZoomHomeToolbar: function PaneTableViewModel$ShouldEnableZoomHomeToolbar() {
			return this.get_visualModel().get_hasModifiedAxes();
		},
		$notifyTextUpdated: function PaneTableViewModel$NotifyTextUpdated() {
			if (!ss.staticEquals(this.$2$TextUpdatedField, null)) {
				this.$2$TextUpdatedField();
			}
		}
	}, spiff.BaseViewModel, [ss.IDisposable, tab.IViewModel, tab.IPaneTableViewModel]);
	ss.initClass($tab_PaneTableViewRegionParts, $asm, {
		$createSelectorLookup: function PaneTableViewRegionParts$CreateSelectorLookup() {
			var regionToSelector = {};
			regionToSelector['uleft'] = this.$dom.topLeftSpacer;
			regionToSelector['uright'] = this.$dom.topRightSpacer;
			regionToSelector['lleft'] = this.$dom.bottomLeftSpacer;
			regionToSelector['lright'] = this.$dom.bottomRightSpacer;
			regionToSelector['title'] = this.$dom.title;
			regionToSelector['caption'] = this.$dom.caption;
			regionToSelector['xheader'] = this.$dom.xLabel;
			regionToSelector['yheader'] = this.$dom.yLabel;
			regionToSelector['leftaxis'] = this.$dom.leftAxis;
			regionToSelector['rightaxis'] = this.$dom.rightAxis;
			regionToSelector['bottomaxis'] = this.$dom.bottomAxis;
			regionToSelector['topaxis'] = this.$dom.topAxis;
			regionToSelector['viz'] = this.$dom.view;
			return regionToSelector;
		},
		getSelectorForRegion: function PaneTableViewRegionParts$GetSelectorForRegion(region) {
			return this.$regionSelectors[region];
		},
		getRegionForPoint: function PaneTableViewRegionParts$GetRegionForPoint(point) {
			var regions = this.$regionSelectors;
			var $t1 = new ss.ObjectEnumerator(regions);
			try {
				while ($t1.moveNext()) {
					var entry = $t1.current();
					if (ss.isNullOrUndefined(entry.value)) {
						continue;
					}
					var rect = tab.DomUtil.getMarginBoxJQ(entry.value);
					if (tab.RectUtil.inRect(rect, point)) {
						var $t2 = new $tab_RegionPositionPair();
						$t2.imageRegion = entry.key;
						$t2.position = rect;
						return $t2;
					}
				}
			}
			finally {
				$t1.dispose();
			}
			return null;
		}
	});
	ss.initClass($tab_PaneTableViewWebMetrics, $asm, {});
	ss.initClass($tab_PolyShapeSelector, $asm, {
		get_hitTestingBox: function PolyShapeSelector$get_HitTestingBox() {
			return ((this.$dragPoints.length === 0) ? { x: 0, y: 0, w: 1, h: 1 } : tab.RectXYUtil.nonemptyify(this.$getBoxHelper(true)));
		},
		get_autoScrollAdjustment: function PolyShapeSelector$get_AutoScrollAdjustment() {
			return ((tab.ApplicationModel.get_instance().get_isLocalRenderMode() || tsConfig.is_mobile) ? this.get_autoScrollOffset() : { x: 0, y: 0 });
		},
		isSingleSelect: function PolyShapeSelector$IsSingleSelect() {
			return this.$dragPoints.length === 0;
		},
		$getBoxHelper: function PolyShapeSelector$GetBoxHelper(isForHitTesting) {
			var correctList = (isForHitTesting ? this.$hitTestPoints : this.$dragPoints);
			var minX = correctList[0].x;
			var maxX = minX;
			var minY = correctList[0].y;
			var maxY = minY;
			for (var $t1 = 0; $t1 < correctList.length; $t1++) {
				var p = correctList[$t1];
				if (p.x < minX) {
					minX = p.x;
				}
				else if (p.x > maxX) {
					maxX = p.x;
				}
				if (p.y < minY) {
					minY = p.y;
				}
				else if (p.y > maxY) {
					maxY = p.y;
				}
			}
			return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
		},
		updateSpecificShape: function PolyShapeSelector$UpdateSpecificShape(lastPoint) {
			if (this.$dragPoints.length === 0) {
				var startX = this.get_dragStart().x - this.get_connectNodePos().x;
				var startY = this.get_dragStart().y - this.get_connectNodePos().y;
				this.$addToListOfPoints(startX, startY);
			}
			var currentX = lastPoint.x;
			var currentY = lastPoint.y;
			this.$addToListOfPoints(currentX, currentY);
		},
		renderShape: function PolyShapeSelector$RenderShape() {
			if (ss.isNullOrEmptyString(this.$trail)) {
				return;
			}
			this.get_dom().find('svg path').attr('d', this.$trail);
			this.$closePathEventId = tab.MiscUtil.clearTimeout(this.$closePathEventId);
			this.$closePathEventId = window.setTimeout(ss.mkdel(this, function() {
				this.$closeTrail();
			}), $tab_PolyShapeSelector.$pauseTimeMS);
			this.get_dom().css('display', '');
		},
		$closeTrail: function PolyShapeSelector$CloseTrail() {
			this.$closePathEventId = tab.MiscUtil.clearTimeout(this.$closePathEventId);
			this.get_dom().find('svg path').attr('d', this.$trail + $tab_PolyShapeSelector.$closePath);
		},
		show: function PolyShapeSelector$Show() {
			this.$clearShapeData();
			this.renderShape();
			this.get_dom().find('.selectionShape').show();
		},
		hide: function PolyShapeSelector$Hide() {
			this.get_dom().find('.selectionShape').hide();
		},
		shapeAreaHit: function PolyShapeSelector$ShapeAreaHit(clippedSelection, paneDrawInfo, markHitTargetNode, t) {
			var markIndex = markHitTargetNode.get_objectId();
			var markType = paneDrawInfo.markType;
			var hit = $tab_HitTester.rectangleAreaHit(paneDrawInfo, markHitTargetNode.get_boundingBox(), clippedSelection, markIndex, t, markType);
			if (!hit) {
				return false;
			}
			var offsetX = 0;
			var offsetY = 0;
			if (t.get_transformType() === 3) {
				offsetX = t.get_translateX();
				offsetY = t.get_translateY();
			}
			var offsetSelectionPts = this.$retrieveListOfPointsWithWorldOffset(offsetX, offsetY);
			return $tab_HitTester.polyAreaHit(paneDrawInfo, markHitTargetNode.get_boundingBox(), offsetSelectionPts, markIndex, t, markType);
		},
		sendSelectionCommand: function PolyShapeSelector$SendSelectionCommand(region, action, visualId, tooltipCallback) {
			tab.SelectionClientCommands.selectPolyRegionAndDoUbertip(region, this.get_hitTestingBox(), this.$hitTestPoints, action, visualId, tooltipCallback);
		},
		retrieveStateObject: function PolyShapeSelector$RetrieveStateObject(shapeState) {
			return (this.isStateObjectTypeCorrect(shapeState) ? shapeState : new $tab_PolyShapeState());
		},
		saveCurrentState: function PolyShapeSelector$SaveCurrentState(shapeState) {
			if (this.isStateObjectTypeCorrect(shapeState)) {
				var polyShapeState = ss.cast(shapeState, $tab_PolyShapeState);
				polyShapeState.saveCurrentState(this.$hitTestPoints);
			}
		},
		isStateObjectTypeCorrect: function PolyShapeSelector$IsStateObjectTypeCorrect(shapeState) {
			if (ss.isValue(shapeState)) {
				if (ss.referenceEquals(ss.getInstanceType(shapeState), $tab_PolyShapeState)) {
					return true;
				}
				tab.Log.get(this).warn('PolyShapeSelector expects to work on only PolyShapeState objects', []);
			}
			return false;
		},
		$clearShapeData: function PolyShapeSelector$ClearShapeData() {
			ss.clear(this.$dragPoints);
			ss.clear(this.$hitTestPoints);
			ss.clearKeys(this.$dictOfPointsWithWorldOffset);
			this.$trail = '';
			this.$prevX = null;
			this.$prevY = null;
		},
		$addToListOfPoints: function PolyShapeSelector$AddToListOfPoints(x, y) {
			var DeltaThreshold = 2;
			var CollinearThreshold = 1;
			if (this.$optimizeShape && ss.isValue(this.$prevX) && ss.isValue(this.$prevY)) {
				if (Math.abs(x - ss.unbox(this.$prevX)) < DeltaThreshold && Math.abs(y - ss.unbox(this.$prevY)) < DeltaThreshold) {
					return;
				}
			}
			var dragX = x + this.get_drawOffsets().x + this.get_autoScrollAdjustment().x;
			var dragY = y + this.get_drawOffsets().y + this.get_autoScrollAdjustment().y;
			var hitTestX = x + this.get_totalScrollOffset().x;
			var hitTestY = y + this.get_totalScrollOffset().y;
			var collinearHoriz = false;
			var collinearVert = false;
			var collinearDiag = false;
			var pointCnt = this.$hitTestPoints.length;
			if (this.$optimizeShape) {
				if (pointCnt > 1) {
					var prev1 = this.$hitTestPoints[pointCnt - 1];
					var prev2 = this.$hitTestPoints[pointCnt - 2];
					var deltaX = Math.abs(hitTestX - prev2.x);
					var deltaXPrev = Math.abs(hitTestX - prev1.x);
					var deltaY = Math.abs(hitTestY - prev2.y);
					var deltaYPrev = Math.abs(hitTestY - prev1.y);
					collinearHoriz = deltaY <= CollinearThreshold && deltaYPrev <= CollinearThreshold;
					if (collinearHoriz) {
						collinearHoriz = $tab_PolyShapeSelector.$isTrioOrdered(hitTestX, prev1.x, prev2.x);
					}
					else {
						collinearVert = deltaX <= CollinearThreshold && deltaXPrev <= CollinearThreshold;
						if (collinearVert) {
							collinearVert = $tab_PolyShapeSelector.$isTrioOrdered(hitTestY, prev1.y, prev2.y);
						}
						else {
							collinearDiag = deltaX * deltaYPrev === deltaY * deltaXPrev && $tab_PolyShapeSelector.$isTrioOrdered(hitTestX, prev1.x, prev2.x);
						}
					}
				}
			}
			var prevIndex = pointCnt - 1;
			if (collinearHoriz) {
				this.$dragPoints[prevIndex].x = dragX;
				this.$hitTestPoints[prevIndex].x = hitTestX;
			}
			else if (collinearVert) {
				this.$dragPoints[prevIndex].y = dragY;
				this.$hitTestPoints[prevIndex].y = hitTestY;
			}
			else if (collinearDiag) {
				this.$dragPoints[prevIndex].x = dragX;
				this.$dragPoints[prevIndex].y = dragY;
				this.$hitTestPoints[prevIndex].x = hitTestX;
				this.$hitTestPoints[prevIndex].y = hitTestY;
			}
			else {
				this.$dragPoints.push({ x: dragX, y: dragY });
				this.$hitTestPoints.push({ x: hitTestX, y: hitTestY });
			}
			this.$trail = '';
			var autoScrollAdjustment = this.get_autoScrollAdjustment();
			var pathChar = $tab_PolyShapeSelector.$moveTo;
			for (var $t1 = 0; $t1 < this.$dragPoints.length; $t1++) {
				var p = this.$dragPoints[$t1];
				this.$trail += pathChar + (p.x - autoScrollAdjustment.x) + ',' + (p.y - autoScrollAdjustment.y);
				pathChar = $tab_PolyShapeSelector.$lineTo;
			}
			this.$prevX = x;
			this.$prevY = y;
		},
		$retrieveListOfPointsWithWorldOffset: function PolyShapeSelector$RetrieveListOfPointsWithWorldOffset(offsetX, offsetY) {
			var prevCount = 0;
			var currCount = this.$hitTestPoints.length;
			var key = offsetX.toString() + ':' + offsetY.toString();
			var offsetPoints = this.$dictOfPointsWithWorldOffset[key];
			if (ss.isNullOrUndefined(offsetPoints)) {
				offsetPoints = new Array(currCount * 2);
				this.$dictOfPointsWithWorldOffset[key] = offsetPoints;
			}
			else {
				prevCount = ss.Int32.div(offsetPoints.length, 2);
				if (this.$optimizeShape) {
					prevCount -= 1;
				}
				offsetPoints.length = currCount * 2;
			}
			var intOffsetX = Math.round(offsetX);
			var intOffsetY = Math.round(offsetY);
			for (var i = prevCount, idx = prevCount * 2; i < currCount; i++, idx += 2) {
				var origPt = this.$hitTestPoints[i];
				offsetPoints[idx] = origPt.x - intOffsetX;
				offsetPoints[idx + 1] = origPt.y - intOffsetY;
			}
			return offsetPoints;
		}
	}, $tab_ShapeSelectorBase);
	ss.initClass($tab_PolyShapeState, $asm, {
		saveCurrentState: function PolyShapeState$SaveCurrentState(listOfPoints) {
			if (listOfPoints.length < this.$lastState) {
				tab.Log.get(this).warn('Current state of PolyShapeState should not have fewer points than last state.', []);
			}
			this.$currentState = ss.arrayClone(listOfPoints);
		},
		updateLastState: function PolyShapeState$UpdateLastState() {
			this.$lastState = Math.max(0, this.$currentState.length - 1);
		},
		getStateDiff: function PolyShapeState$GetStateDiff() {
			if (this.$currentState.length === 0) {
				return [];
			}
			var top = this.$currentState[0].y;
			var bottom = top;
			var left = this.$currentState[0].x;
			var right = left;
			for (var i = this.$lastState, l = this.$currentState.length; i < l; i++) {
				top = Math.min(top, this.$currentState[i].y);
				bottom = Math.max(bottom, this.$currentState[i].y);
				left = Math.min(left, this.$currentState[i].x);
				right = Math.max(right, this.$currentState[i].x);
			}
			var changedArea = new Array(1);
			changedArea[0] = tab.RectXYUtil.nonemptyify({ x: left, y: top, w: right - left, h: bottom - top });
			return changedArea;
		}
	}, $tab_ShapeStateBase);
	ss.initClass($tab_RectShapeSelector, $asm, {
		get_hitTestingBox: function RectShapeSelector$get_HitTestingBox() {
			return tab.RectXYUtil.nonemptyify(this.$hitTestRect);
		},
		isSingleSelect: function RectShapeSelector$IsSingleSelect() {
			return this.$dragRect.w <= 1 && this.$dragRect.h <= 1;
		},
		updateSpecificShape: function RectShapeSelector$UpdateSpecificShape(lastPoint) {
			var originX = this.get_dragStart().x - this.get_connectNodePos().x;
			var originY = this.get_dragStart().y - this.get_connectNodePos().y;
			var left = Math.round(Math.min(lastPoint.x, originX));
			var right = Math.round(Math.max(lastPoint.x, originX));
			var top = Math.round(Math.min(lastPoint.y, originY));
			var bottom = Math.round(Math.max(lastPoint.y, originY));
			var width = right - left;
			var height = bottom - top;
			this.$dragRect = { x: left + this.get_drawOffsets().x, y: top + this.get_drawOffsets().y, w: width, h: height };
			this.$hitTestRect = { x: left + this.get_totalScrollOffset().x, y: top + this.get_totalScrollOffset().y, w: width, h: height };
		},
		renderShape: function RectShapeSelector$RenderShape() {
			var rect = { l: this.$dragRect.x, t: this.$dragRect.y, w: this.$dragRect.w, h: this.$dragRect.h };
			tab.DomUtil.setMarginBoxJQ(this.get_dom(), rect);
			this.get_dom().css('display', '');
		},
		show: function RectShapeSelector$Show() {
			this.get_dom().addClass($tab_RectShapeSelector.$visibleShapeClassName);
		},
		hide: function RectShapeSelector$Hide() {
			this.get_dom().removeClass($tab_RectShapeSelector.$visibleShapeClassName);
		},
		shapeAreaHit: function RectShapeSelector$ShapeAreaHit(clippedSelection, paneDrawInfo, markHitTargetNode, t) {
			return $tab_HitTester.rectangleAreaHit(paneDrawInfo, markHitTargetNode.get_boundingBox(), clippedSelection, markHitTargetNode.get_objectId(), t, paneDrawInfo.markType);
		},
		sendSelectionCommand: function RectShapeSelector$SendSelectionCommand(region, action, visualId, tooltipCallback) {
			tab.SelectionClientCommands.selectRectRegionAndDoUbertip(region, this.get_hitTestingBox(), action, visualId, tooltipCallback, 'default', null);
		},
		retrieveStateObject: function RectShapeSelector$RetrieveStateObject(shapeState) {
			return (this.isStateObjectTypeCorrect(shapeState) ? shapeState : new $tab_RectShapeState());
		},
		saveCurrentState: function RectShapeSelector$SaveCurrentState(shapeState) {
			if (this.isStateObjectTypeCorrect(shapeState)) {
				var rectShapeState = ss.cast(shapeState, $tab_RectShapeState);
				rectShapeState.saveCurrentState(this.get_hitTestingBox());
			}
		},
		isStateObjectTypeCorrect: function RectShapeSelector$IsStateObjectTypeCorrect(shapeState) {
			if (ss.isValue(shapeState)) {
				if (ss.referenceEquals(ss.getInstanceType(shapeState), $tab_RectShapeState)) {
					return true;
				}
				tab.Log.get(this).warn('RectShapeSelector expects to work on only RectShapeState objects', []);
			}
			return false;
		}
	}, $tab_ShapeSelectorBase);
	ss.initClass($tab_RectShapeState, $asm, {
		saveCurrentState: function RectShapeState$SaveCurrentState(dragRect) {
			this.$currentState = tab.RectXYUtil.clone(dragRect);
		},
		updateLastState: function RectShapeState$UpdateLastState() {
			this.$lastState = this.$currentState;
		},
		getStateDiff: function RectShapeState$GetStateDiff() {
			if (!tab.RectXYUtil.isEmpty(this.$lastState)) {
				return tab.RectXYUtil.getChangedRects(this.$lastState, this.$currentState);
			}
			var changedArea = new Array(1);
			changedArea[0] = this.$currentState;
			return changedArea;
		}
	}, $tab_ShapeStateBase);
	ss.initClass($tab_ReferenceLinesRenderer, $asm, {
		renderReferenceLines: function ReferenceLinesRenderer$RenderReferenceLines(refLine, getVisualState, paneDrawInfo, renderPass, role) {
			switch (renderPass) {
				case 'normalUnderPass': {
					if (role === 'background' && refLine.get_hasFill()) {
						this.$drawFills(refLine, getVisualState(refLine), paneDrawInfo);
					}
					break;
				}
				case 'selectedOnPass': {
					if (role === 'underLabel' && refLine.get_hasLine()) {
						this.$drawRefLines(refLine, getVisualState(refLine), paneDrawInfo);
					}
					if (role === 'foreground' && refLine.get_hasLabel()) {
						this.$drawLabels(refLine, getVisualState(refLine), paneDrawInfo);
					}
					break;
				}
			}
		},
		renderOverlay: function ReferenceLinesRenderer$RenderOverlay(refLine, paneDrawInfo) {
			this.$drawRefLines(refLine, 'hover', paneDrawInfo);
		},
		$configurePen: function ReferenceLinesRenderer$ConfigurePen(refLine) {
			var context = this.get_currentContext();
			context.set_lineJoin(tab.CanvasRenderer.toCanvasLineJoin(refLine.get_lineJoin()));
			context.set_lineCap($tab_DisplayList2DRenderer.resolveLineCap(refLine.get_linePattern(), refLine.get_lineCap()));
			context.set_linePattern(refLine.get_linePattern());
			context.set_lineWidth(refLine.get_lineWidth());
			context.set_shouldAntialias(false);
			context.set_strokeStyle($tab_PaneTable2DRenderer.calculateColorForState(refLine.get_lineColor(), this.$currentVisualState, true, this.$currentFogging).toString());
		},
		$drawRefLines: function ReferenceLinesRenderer$DrawRefLines(refLineData, targetState, paneDrawInfo) {
			this.$drawItems(refLineData, targetState, paneDrawInfo, ss.mkdel(this, function(index) {
				this.$configurePen(refLineData);
			}), ss.mkdel(this, function(index1, refLineBound) {
				var screenPoint = refLineData.getLinePixelPosition(ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelX), ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelY), index1);
				var endPoints = refLineData.getEndPoints(refLineBound, screenPoint);
				tab.CanvasRenderer.strokePath(this.get_currentContext(), endPoints, false, true);
			}));
		},
		$drawLabels: function ReferenceLinesRenderer$DrawLabels(refLineData, targetState, paneDrawInfo) {
			this.$drawItems(refLineData, targetState, paneDrawInfo, ss.mkdel(this, function(index) {
				this.$configureTextProperties(refLineData, index);
			}), ss.mkdel(this, function(index1, refLineBound) {
				var screenPoint = refLineData.getLinePixelPosition(ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelX), ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelY), index1);
				var pos = refLineData.computeLabelBoxPosition(refLineBound, screenPoint, index1);
				this.$drawLabelImpl(refLineData, index1, pos);
			}));
		},
		$drawFills: function ReferenceLinesRenderer$DrawFills(refLineData, targetState, paneDrawInfo) {
			this.$drawItems(refLineData, targetState, paneDrawInfo, null, ss.mkdel(this, function(index, refLineBound) {
				var screenPoint = refLineData.getLinePixelPosition(ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelX), ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelY), index);
				if (refLineData.get_hasFillBelow()) {
					this.$drawFillForLevel(refLineData, refLineBound, screenPoint, 0);
				}
				if (refLineData.get_hasFillAbove()) {
					this.$drawFillForLevel(refLineData, refLineBound, screenPoint, 1);
				}
			}));
		},
		$drawItems: function ReferenceLinesRenderer$DrawItems(refLineData, visualState, paneDrawInfo, forAllElements, forEachElement) {
			var paneIndex = paneDrawInfo.get_paneIndex();
			var range = refLineData.getRange(paneIndex);
			if (range.item2 <= range.item1) {
				return;
			}
			this.get_currentContext().save();
			this.get_currentContext().setClip(paneDrawInfo.paneRect);
			var refLineBound = this.$getBound(refLineData, paneDrawInfo);
			this.$currentVisualState = visualState;
			if (visualState === 'fogged') {
				this.$currentFogging = $tab_PaneTable2DRenderer.getFogBlendFactorAndBackgroundColor(paneDrawInfo);
			}
			if (!ss.staticEquals(forAllElements, null)) {
				forAllElements(range.item1);
			}
			for (var index = range.item1; index < range.item2; index++) {
				var clipInfo = refLineData.getCellClipInfo(index);
				if (clipInfo.item1 !== 0) {
					this.get_currentContext().save();
					refLineBound = this.$clipToCell(clipInfo, paneDrawInfo);
				}
				forEachElement(index, refLineBound);
				if (clipInfo.item1 !== 0) {
					this.get_currentContext().restore();
				}
			}
			this.$currentFogging = null;
			this.get_currentContext().restore();
		},
		$configureTextProperties: function ReferenceLinesRenderer$ConfigureTextProperties(refLine, labelIndex) {
			var textStyle = refLine.getTextStyle(labelIndex);
			if (ss.isValue(textStyle)) {
				var styleTable = textStyle.item1;
				var styleId = textStyle.item2;
				var textFillStyle = tab.ColorModel.fromArgbInt(styleTable.text_style_color[styleId]);
				this.get_currentContext().set_textFillStyle($tab_PaneTable2DRenderer.calculateColorForState(textFillStyle, this.$currentVisualState, false, this.$currentFogging).toString());
				this.get_currentContext().set_textAngle($tab_PaneDrawInfo.getTextAngleInRad(styleTable.text_orientation[styleId]));
				this.get_currentContext().set_shouldUnderlineText(styleTable.text_decoration[styleId] === 1);
				this.get_currentContext().set_font(this.$buildFont(styleTable, styleId));
			}
		},
		$buildFont: function ReferenceLinesRenderer$BuildFont(styleTable, id) {
			var fontDescription = new ss.StringBuilder();
			if (tab.EnumConversions.tableauFontStyleFromInt(styleTable.font_style[id]) === 'font-style-italic') {
				fontDescription.append('italic ');
			}
			if (tab.EnumConversions.fontWeightFromInt(styleTable.font_weight[id]) === 'font-weight-bold') {
				fontDescription.append('bold ');
			}
			var fontName = styleTable.font[id];
			fontName = tab.FontUtil.createFallbackCanvasFontName(fontName);
			var fontSize = styleTable.font_size[id];
			fontDescription.append(fontSize + 'pt ' + fontName);
			return fontDescription.toString();
		},
		$resolveTextAlign: function ReferenceLinesRenderer$ResolveTextAlign(refLine, labelIndex) {
			return (refLine.isTextAlignEnd(labelIndex) ? 'end' : tab.TabRenderContext2D.defaultTextAlign);
		},
		$drawLabelImpl: function ReferenceLinesRenderer$DrawLabelImpl(refLineData, labelIndex, pos) {
			this.get_currentContext().translate(pos.x, pos.y);
			if (!this.get_currentContext().get_isTextAngleHorizontal()) {
				this.get_currentContext().rotate(this.get_currentContext().get_textAngle());
				this.get_currentContext().set_textAngle(0);
			}
			this.get_currentContext().set_shouldAntialias(false);
			var computedShapeFillColor = $tab_PaneTable2DRenderer.calculateColorForState(refLineData.get_labelBackgroundColor(), this.$currentVisualState, false, this.$currentFogging);
			this.get_currentContext().set_shapeFillStyle(computedShapeFillColor.toString());
			this.get_currentContext().fillRect(0, 0, Math.ceil(refLineData.getLabelWidth(labelIndex)), Math.ceil(refLineData.getLabelHeight(labelIndex)));
			this.get_currentContext().set_shouldAntialias(true);
			this.get_currentContext().set_textAlign(this.$resolveTextAlign(refLineData, labelIndex));
			var textRunOffset = refLineData.getTextRunOffset(labelIndex);
			var textRunCount = refLineData.getTextRunCount(labelIndex);
			var maxWidth = refLineData.getLabelWidth(labelIndex);
			var multipleRuns = textRunCount > 1;
			for (var i = textRunOffset; i < textRunOffset + textRunCount; i++) {
				var runPosition = refLineData.getTextRunPosition(i);
				this.renderText(refLineData.getTextRun(i), runPosition.x, runPosition.y, maxWidth, this.get_currentContext().get_textFillStyle(), multipleRuns);
			}
		},
		$clipToCell: function ReferenceLinesRenderer$ClipToCell(clipInfo, paneDrawInfo) {
			this.clipRect(clipInfo.item1, paneDrawInfo.thisDomainToPixelX(clipInfo.item2), paneDrawInfo.thisDomainToPixelY(clipInfo.item3), paneDrawInfo.thisDomainToPixelWidth(1), paneDrawInfo.thisDomainToPixelHeight(1));
			return this.get_currentContext().get_currentClipRect();
		},
		$getBound: function ReferenceLinesRenderer$GetBound(refLineData, paneDrawInfo) {
			var ret = paneDrawInfo.paneRect;
			if (refLineData.get_scope() === 2 && ss.isValue(paneDrawInfo.get_$sceneRect())) {
				ret = paneDrawInfo.get_$sceneRect();
			}
			return ret;
		},
		$drawFillForLevel: function ReferenceLinesRenderer$DrawFillForLevel(refLineData, refLineBound, screenPoint, level) {
			if (refLineData.get_fillColorCount() > level && refLineData.getFillColor(level).get_a() > 0) {
				var computedShapeFillColor = $tab_PaneTable2DRenderer.calculateColorForState(refLineData.getFillColor(level), this.$currentVisualState, false, this.$currentFogging);
				this.get_currentContext().set_shapeFillStyle(computedShapeFillColor.toString());
				var rect = refLineData.getFillRect(refLineBound, screenPoint, level);
				this.get_currentContext().fillRect(rect.x, rect.y, rect.w, rect.h);
			}
		}
	}, $tab_MarksRenderer);
	ss.initClass($tab_RefLineHitTestLink, $asm, {
		hitTest: function RefLineHitTestLink$HitTest(p, isSingleSelect) {
			var selectionRect = (ss.isValue(p) ? { x: p.x, y: p.y, w: 1, h: 1 } : null);
			var bestSingleHitResult = $tab_HitTestResult.createEmptyHitTestResult();
			var multiSelectResults = [];
			if (ss.isValue(this.$sceneInfo.get_referenceLines())) {
				var hitTestResults = this.hitTestRefLinesModel(this.$sceneInfo.get_referenceLines(), p, isSingleSelect);
				if (isSingleSelect) {
					bestSingleHitResult = hitTestResults[0];
				}
				else {
					multiSelectResults = hitTestResults;
				}
			}
			var results = $tab_RefLineHitTestLink.hitTestRefLines(this.paneTableVM.get_refLineVisualLists(), selectionRect, isSingleSelect);
			if (isSingleSelect) {
				bestSingleHitResult = $tab_HitTestResult.tieBreak(results[0], bestSingleHitResult);
			}
			return $tab_RefLineHitTestLink.$resolveHitTestReults(isSingleSelect, bestSingleHitResult, multiSelectResults.concat.apply(multiSelectResults, results));
		},
		hitTestRefLinesModel: function RefLineHitTestLink$HitTestRefLinesModel(refLines, p, isSingleSelect) {
			this.$buildHitTestStructure(refLines);
			if (isSingleSelect) {
				return [this.$singleHitTestRefLinesModel(p)];
			}
			else {
				return this.$multiHitTestRefLinesModel(p);
			}
		},
		clearCache: function RefLineHitTestLink$ClearCache() {
			this.$hitTestStructureList = null;
		},
		$buildHitTestStructure: function RefLineHitTestLink$BuildHitTestStructure(refLinesModel) {
			if (ss.isValue(this.$hitTestStructureList)) {
				return;
			}
			this.$hitTestStructureList = [];
			var paneDrawInfos = this.$gatherPaneDrawInfos();
			for (var $t1 = 0; $t1 < paneDrawInfos.length; $t1++) {
				var paneDrawInfo = paneDrawInfos[$t1];
				var refLines = refLinesModel.getRefLines(paneDrawInfo.get_paneDescriptorKey());
				var paneNodeForRefLine = this.$buildRefLineNodesForPane(refLines, paneDrawInfo);
				this.$hitTestStructureList.push(paneNodeForRefLine);
				var instantRefLines = refLinesModel.getInstantRefLines(paneDrawInfo.get_paneDescriptorKey());
				if (ss.isValue(instantRefLines) && instantRefLines.length > 0) {
					var paneNodeForInstantRefLine = this.$buildRefLineNodesForPane(instantRefLines, paneDrawInfo);
					this.$hitTestStructureList.push(paneNodeForInstantRefLine);
				}
			}
		},
		$buildRefLineNodesForPane: function RefLineHitTestLink$BuildRefLineNodesForPane(refLines, paneDrawInfo) {
			var root = new $tab_HitTargetNode(paneDrawInfo.paneRect, 1, -1, null, 0);
			for (var $t1 = 0; $t1 < refLines.length; $t1++) {
				var refLine = refLines[$t1];
				if (refLine.get_hasFill()) {
					continue;
				}
				var paneIndex = paneDrawInfo.get_paneIndex();
				var range = refLine.getRange(paneIndex);
				var refLineBound = ((refLine.get_scope() === 2 && ss.isValue(this.$sceneInfo.get_$sceneRect())) ? this.$sceneInfo.get_$sceneRect() : paneDrawInfo.paneRect);
				for (var index = range.item1; index < range.item2; index++) {
					var clipInfo = refLine.getCellClipInfo(index);
					var clipCase = clipInfo.item1;
					if (clipCase !== 0) {
						refLineBound = $tab_MarksRenderer.$getClipRect(clipCase, paneDrawInfo.thisDomainToPixelX(clipInfo.item2), paneDrawInfo.thisDomainToPixelY(clipInfo.item3), paneDrawInfo.thisDomainToPixelWidth(1), paneDrawInfo.thisDomainToPixelHeight(1));
					}
					var screenPoint = refLine.getLinePixelPosition(ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelX), ss.mkdel(paneDrawInfo, paneDrawInfo.thisDomainToPixelY), index);
					var rect = refLine.getHitTestBound(screenPoint, refLineBound, $tab_RefLineHitTestLink.$exactHitTestExpansion);
					var refLineNode = new $tab_HitTargetNode(rect, 8, refLine.get_id(), null, 0);
					root.addNode(refLineNode);
					if (refLine.get_hasLabel()) {
						var pos = refLine.computeLabelBoxPosition(refLineBound, screenPoint, index);
						var labelBound = { x: pos.x, y: pos.y, w: Math.ceil(refLine.getLabelWidth(index)), h: Math.ceil(refLine.getLabelHeight(index)) };
						var labelBoundClipped = tab.RectXYUtil.intersect(labelBound, refLineBound);
						var refLineLabelNode = new $tab_HitTargetNode(labelBoundClipped, 9, refLine.get_id(), null, 0);
						root.addNode(refLineLabelNode);
					}
				}
			}
			return root;
		},
		$singleHitTestRefLinesModel: function RefLineHitTestLink$SingleHitTestRefLinesModel(p) {
			var bestSingleHitResult = $tab_HitTestResult.createEmptyHitTestResult();
			for (var i = this.$hitTestStructureList.length - 1; i >= 0; i--) {
				var paneNode = this.$hitTestStructureList[i];
				if (paneNode.get_nodeType() !== 1 || !tab.RectXYUtil.inRect(paneNode.get_boundingBox(), p)) {
					continue;
				}
				for (var j = paneNode.get_children().length - 1; j >= 0; j--) {
					var refLineNode = paneNode.get_children()[j];
					if (refLineNode.get_nodeType() !== 8 && refLineNode.get_nodeType() !== 9) {
						continue;
					}
					var hitTestResult = $tab_RefLineHitTestLink.$singleHitTestRefLine(refLineNode, p);
					bestSingleHitResult = $tab_RefLineHitTestLink.$updateBestSingleHitTestResult(bestSingleHitResult, hitTestResult);
					if (bestSingleHitResult.get_hitType() === 3) {
						return bestSingleHitResult;
					}
				}
			}
			return bestSingleHitResult;
		},
		$multiHitTestRefLinesModel: function RefLineHitTestLink$MultiHitTestRefLinesModel(p) {
			var multiSelectResults = [];
			for (var i = this.$hitTestStructureList.length - 1; i >= 0; i--) {
				var paneNode = this.$hitTestStructureList[i];
				if (paneNode.get_nodeType() !== 1 || !tab.RectXYUtil.inRect(paneNode.get_boundingBox(), p)) {
					continue;
				}
				for (var j = paneNode.get_children().length - 1; j >= 0; j--) {
					var refLineNode = paneNode.get_children()[j];
					if (refLineNode.get_nodeType() !== 8 && refLineNode.get_nodeType() !== 9) {
						continue;
					}
					var hitTestResult = $tab_RefLineHitTestLink.$doExactHitTest(refLineNode, p);
					if (hitTestResult.get_hitType() === 3) {
						multiSelectResults.push(hitTestResult);
					}
				}
			}
			return multiSelectResults;
		},
		$gatherPaneDrawInfos: function RefLineHitTestLink$GatherPaneDrawInfos() {
			var paneDrawInfos = [];
			var panes = this.$sceneInfo.get_runtimeData().safeFetchMarkPanes();
			for (var $t1 = 0; $t1 < panes.length; $t1++) {
				var pane = panes[$t1];
				var paneMarkInfos = $tab_HitTestStructureBuilder.$getChildPaneMarkInfos(this.$sceneInfo, pane);
				for (var $t2 = 0; $t2 < paneMarkInfos.length; $t2++) {
					var paneMarkInfo = paneMarkInfos[$t2];
					var paneDrawInfo = this.$sceneInfo.getPaneDrawInfo(paneMarkInfo);
					if (ss.isValue(paneDrawInfo)) {
						paneDrawInfos.push(paneDrawInfo);
					}
				}
			}
			return paneDrawInfos;
		}
	}, $tab_HitTestLink, [ss.IDisposable, $tab_IHitTestLink]);
	ss.initClass($tab_RegionGeometry, $asm, {
		get_neededWidth: function RegionGeometry$get_NeededWidth() {
			return this.$neededWidth;
		},
		get_neededHeight: function RegionGeometry$get_NeededHeight() {
			return this.$neededHeight;
		},
		get_scrollableWidth: function RegionGeometry$get_ScrollableWidth() {
			return this.$scrollableWidth;
		},
		get_scrollableHeight: function RegionGeometry$get_ScrollableHeight() {
			return this.$scrollableHeight;
		},
		get_scrollXLeft: function RegionGeometry$get_ScrollXLeft() {
			return this.$scrollXLeft;
		},
		get_scrollYTop: function RegionGeometry$get_ScrollYTop() {
			return this.$scrollYTop;
		},
		get_widthScrollOffset: function RegionGeometry$get_WidthScrollOffset() {
			return this.$widthScrollOffset;
		},
		get_heightScrollOffset: function RegionGeometry$get_HeightScrollOffset() {
			return this.$heightScrollOffset;
		},
		get_viewWidth: function RegionGeometry$get_ViewWidth() {
			return this.$viewWidth;
		},
		get_viewHeight: function RegionGeometry$get_ViewHeight() {
			return this.$viewHeight;
		},
		get_scrollWidth: function RegionGeometry$get_ScrollWidth() {
			return this.$scrollWidth;
		},
		get_scrollHeight: function RegionGeometry$get_ScrollHeight() {
			return this.$scrollHeight;
		},
		get_overallWidth: function RegionGeometry$get_OverallWidth() {
			return this.$overallWidth;
		},
		get_overallHeight: function RegionGeometry$get_OverallHeight() {
			return this.$overallHeight;
		},
		getVisibleGeometry: function RegionGeometry$GetVisibleGeometry(geo, containerWidth) {
			var visibleGeometry = {};
			visibleGeometry.uleftArea = null;
			if (ss.isValue(geo.uleft)) {
				visibleGeometry.uleftArea = { l: geo.uleft.x, t: geo.uleft.y, w: Math.min(geo.uleft.w, containerWidth - this.get_scrollWidth()), h: geo.uleft.h };
			}
			visibleGeometry.yheaderArea = null;
			if (ss.isValue(geo.yheader)) {
				visibleGeometry.yheaderArea = { l: geo.yheader.x, t: geo.yheader.y, w: Math.min(geo.yheader.w, containerWidth - this.get_scrollWidth()), h: this.get_viewHeight() };
			}
			visibleGeometry.leftaxisArea = null;
			if (ss.isValue(geo.leftaxis)) {
				visibleGeometry.leftaxisArea = { l: geo.leftaxis.x, t: geo.leftaxis.y, w: geo.leftaxis.w, h: this.get_viewHeight() };
			}
			visibleGeometry.rightaxisArea = null;
			if (ss.isValue(geo.rightaxis)) {
				visibleGeometry.rightaxisArea = { l: geo.rightaxis.x - this.get_widthScrollOffset(), t: geo.rightaxis.y, w: geo.rightaxis.w, h: this.get_viewHeight() };
			}
			visibleGeometry.xheaderArea = null;
			if (ss.isValue(geo.xheader)) {
				visibleGeometry.xheaderArea = { l: geo.xheader.x, t: geo.xheader.y, w: this.get_viewWidth(), h: geo.xheader.h };
			}
			visibleGeometry.bottomaxisArea = null;
			if (ss.isValue(geo.bottomaxis)) {
				visibleGeometry.bottomaxisArea = { l: geo.bottomaxis.x, t: geo.bottomaxis.y - this.get_heightScrollOffset(), w: this.get_viewWidth(), h: geo.bottomaxis.h };
			}
			visibleGeometry.topaxisArea = null;
			if (ss.isValue(geo.topaxis)) {
				visibleGeometry.topaxisArea = { l: geo.topaxis.x, t: geo.topaxis.y, w: this.get_viewWidth(), h: geo.topaxis.h };
			}
			visibleGeometry.urightArea = null;
			if (ss.isValue(geo.uright)) {
				visibleGeometry.urightArea = { l: geo.uright.x - this.get_widthScrollOffset(), t: geo.uright.y, w: Math.min(geo.uright.w, containerWidth - this.get_scrollWidth()), h: geo.uright.h };
			}
			visibleGeometry.lleftArea = null;
			if (ss.isValue(geo.lleft)) {
				visibleGeometry.lleftArea = { l: geo.lleft.x, t: geo.lleft.y - this.get_heightScrollOffset(), w: geo.lleft.w, h: geo.lleft.h };
			}
			visibleGeometry.lrightArea = null;
			if (ss.isValue(geo.lright)) {
				visibleGeometry.lrightArea = { l: geo.lright.x - this.get_widthScrollOffset(), t: geo.lright.y - this.get_heightScrollOffset(), w: geo.lright.w, h: geo.lright.h };
			}
			visibleGeometry.vizArea = null;
			if (ss.isValue(geo.viz)) {
				visibleGeometry.vizArea = { l: geo.viz.x, t: geo.viz.y, w: this.get_viewWidth(), h: this.get_viewHeight() };
			}
			return visibleGeometry;
		}
	});
	ss.initClass($tab_RegionPositionPair, $asm, {});
	ss.initClass($tab_RuntimeUIModule, $asm, {});
	ss.initClass($tab_SceneInfo, $asm, {
		get_hasSelection: function SceneInfo$get_HasSelection() {
			return ss.isValue(this.selections) && this.selections.get_hasPaneTableObjectSelection();
		},
		get_hasBrushing: function SceneInfo$get_HasBrushing() {
			return this.$isTargetOfBrushingAction || ss.isValue(this.brushings) && this.brushings.get_hasPaneTableObjectSelection() || ss.isValue(this.$impliedSelection) && !this.$impliedSelection.isEmpty || this.$emptyHighlightFogAll;
		},
		get_imageDictionary: function SceneInfo$get_ImageDictionary() {
			return this.$hashToImageEltMap;
		},
		get_hiddenTuples: function SceneInfo$get_HiddenTuples() {
			return this.$hiddenTuples;
		},
		set_hiddenTuples: function SceneInfo$set_HiddenTuples(value) {
			this.$hiddenTuples = value || new Map();
		},
		get_isSingleUserPane: function SceneInfo$get_IsSingleUserPane() {
			return this.scene.panes.length === 1 && ss.isNullOrUndefined(this.sceneUserPaneInfo);
		},
		get_filteredTuples: function SceneInfo$get_FilteredTuples() {
			return this.$filteredTuples;
		},
		set_filteredTuples: function SceneInfo$set_FilteredTuples(value) {
			this.$filteredTuples = value || new Map();
		},
		get_referenceLines: function SceneInfo$get_ReferenceLines() {
			return this.$1$ReferenceLinesField;
		},
		set_referenceLines: function SceneInfo$set_ReferenceLines(value) {
			this.$1$ReferenceLinesField = value;
		},
		get_runtimeData: function SceneInfo$get_RuntimeData() {
			return this.$runtimeData;
		},
		set_runtimeData: function SceneInfo$set_RuntimeData(value) {
			this.$runtimeData = value;
		},
		get_$sceneRect: function SceneInfo$get_SceneRect() {
			return this.$1$SceneRectField;
		},
		set_$sceneRect: function SceneInfo$set_SceneRect(value) {
			this.$1$SceneRectField = value;
		},
		setSceneData: function SceneInfo$SetSceneData(scenePM, selectionsModel, impliedSelectionModel, brushingsModel, colorDict, newHiddenTuples, newFilteredTuples, runtimeDataIn, refLinesModel, sceneRect) {
			this.$markBoundingBoxes.clear();
			this.$fullMarkBoundingBoxes.clear();
			this.$labelBoundingBoxes.clear();
			this.$paneDrawInfoMap.clear();
			this.$markGeometries.clear();
			this.sceneUserPaneInfo = null;
			this.scene = scenePM;
			this.$runtimeData = runtimeDataIn;
			this.set_referenceLines(refLinesModel);
			this.set_$sceneRect(sceneRect);
			this.set_hiddenTuples(newHiddenTuples);
			this.set_filteredTuples(newFilteredTuples);
			if (ss.isValue(scenePM) && (ss.isValue(scenePM.pdMarksMap) || ss.isValue(scenePM.runtimeRenderInputDatastore))) {
				this.customShapes = $tab_SceneInfo.extractCustomShapes(runtimeDataIn);
				if (ss.isValue(runtimeDataIn.get_annexedData().Panes)) {
					var paneMarksArray = runtimeDataIn.get_annexedData().Panes;
					if (ss.isValue(scenePM.userPaneInfo)) {
						this.sceneUserPaneInfo = new $tab_SceneUserPaneInfo(scenePM.userPaneInfo);
						ss.Debug.assert(this.sceneUserPaneInfo.$hasPanesX || this.sceneUserPaneInfo.$hasPanesY, 'Tell Yevgen that the fix for TFSID:486810 is incomplete, see source code comments');
					}
					this.$parseGeometries(runtimeDataIn);
					for (var $t1 = 0; $t1 < paneMarksArray.length; $t1++) {
						var paneMarks = paneMarksArray[$t1];
						var drawPanes = paneMarks.DrawPanes;
						for (var i = 0; i < drawPanes.length; ++i) {
							var panePartArray = drawPanes[i];
							var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
							var paneIndex = panePartArray[1];
							if (visualPart === 'marks') {
								var paneMarksInfo = new tab.PaneMarksInfo.$ctor1(runtimeDataIn.get_finalDataStore().Viewpoint.PerPaneExtents, runtimeDataIn.get_paneStoreTable(), paneIndex, scenePM.currentPage, paneMarks.Row, paneMarks.Column);
								var pdMarksKey = paneMarksInfo.get_paneKey();
								var key = $tab_SceneInfo.getPaneMarksKey$1(pdMarksKey, paneMarksInfo.get_paneId(), paneIndex);
								var paneDrawInfo = new $tab_PaneDrawInfo.$ctor1(pdMarksKey, this, paneMarks, paneMarksInfo, colorDict, key, runtimeDataIn.get_finalDataStore(), paneIndex);
								ss.Debug.assert(!this.$paneDrawInfoMap.has(key) || paneMarksInfo.get_startIndex() === paneMarksInfo.get_endIndex(), 'The key should not be in the dictionary yet, or the pane has no marks.');
								this.$paneDrawInfoMap.set(key, paneDrawInfo);
							}
						}
					}
				}
			}
			if (ss.isValue(selectionsModel)) {
				this.selections = selectionsModel;
				this.$impliedSelection = impliedSelectionModel;
			}
			if (ss.isValue(brushingsModel)) {
				this.brushings = brushingsModel;
			}
			this.colorModel = $tab_InteractionColorModel.extractInteractionColors(this.scene);
		},
		getMarkBoundingBox: function SceneInfo$GetMarkBoundingBox(tupleId) {
			if (this.$markBoundingBoxes.has(tupleId)) {
				return this.$markBoundingBoxes.get(tupleId);
			}
			else {
				return $tab_SceneInfo.$emptyRect;
			}
		},
		$getMarkGeometry: function SceneInfo$GetMarkGeometry(pdMarkKey, geometryIndex) {
			if (this.$markGeometries.has(pdMarkKey) && geometryIndex >= 0 && geometryIndex < this.$markGeometries.get(pdMarkKey).length) {
				return this.$markGeometries.get(pdMarkKey)[geometryIndex];
			}
			return null;
		},
		computeFilteredMarks: function SceneInfo$ComputeFilteredMarks(tuples) {
			var filteredMarks = new Set();
			var filteredCount = this.$filteredTuples.size;
			if (filteredCount === 0) {
				return filteredMarks;
			}
			var tupleCount = 0;
			if (!ss.isNullOrUndefined(tuples)) {
				tupleCount = tuples.length;
			}
			for (var i = 0; i < tupleCount; i++) {
				var tupleId = tuples.v[(tuples.c ? 0 : i)];
				if (this.$filteredTuples.has(tupleId.toString())) {
					filteredMarks.add(i);
					if (filteredMarks.size === filteredCount) {
						break;
					}
				}
			}
			return filteredMarks;
		},
		computeTupleStates: function SceneInfo$ComputeTupleStates(tuples) {
			var hasSelection = this.get_hasSelection();
			var selectionsModel = this.selections;
			var tupleSelection = (ss.isValue(selectionsModel) ? selectionsModel.tupleSelection : null);
			var selectedTuples = new Set();
			if (ss.isValue(tupleSelection)) {
				tab.SetUtilities.addAll(ss.Int32).call(null, selectedTuples, tupleSelection.get_ids());
			}
			var hasBrushing = this.get_hasBrushing();
			var brushingsModel = this.brushings;
			var tupleBrushing = (ss.isValue(brushingsModel) ? brushingsModel.tupleSelection : null);
			var brushedTuples = new Set();
			if (ss.isValue(tupleBrushing)) {
				tab.SetUtilities.addAll(ss.Int32).call(null, brushedTuples, tupleBrushing.get_ids());
			}
			var impliedSelectedTuples = new Set();
			if (ss.isValue(this.$impliedSelection)) {
				tab.SetUtilities.addAll(ss.Int32).call(null, impliedSelectedTuples, this.$impliedSelection.get_ids());
			}
			var tupleCount = 0;
			if (!ss.isNullOrUndefined(tuples)) {
				tupleCount = tuples.length;
			}
			var tupleStates = new Array(tupleCount);
			for (var i = 0; i < tupleCount; i++) {
				var tupleId = tuples.v[(tuples.c ? 0 : i)];
				var state = 'markStateNormal';
				if (this.$hiddenTuples.has(tupleId.toString())) {
					state = 'markStateInvisible';
				}
				else if (hasSelection && selectedTuples.has(tupleId)) {
					state = 'markStateSelected';
				}
				else if (hasBrushing && (brushedTuples.has(tupleId) || impliedSelectedTuples.has(tupleId))) {
					state = 'markStateHighlighted';
				}
				tupleStates[i] = state;
			}
			return tupleStates;
		},
		prepareForDraw: function SceneInfo$PrepareForDraw(dirtyRect) {
			this.$computeDirtyMarks(dirtyRect);
			this.$refreshMarkState();
		},
		cleanupFromDraw: function SceneInfo$CleanupFromDraw() {
			this.$clearDirtyMarks();
		},
		$getLabelBoundingBox: function SceneInfo$GetLabelBoundingBox(tupleId) {
			if (this.$labelBoundingBoxes.has(tupleId)) {
				return this.$labelBoundingBoxes.get(tupleId);
			}
			else {
				return $tab_SceneInfo.$emptyRect;
			}
		},
		getMarksInvalidationRects: function SceneInfo$GetMarksInvalidationRects(tupleIDs) {
			var rects = [];
			for (var $t1 = 0; $t1 < tupleIDs.length; $t1++) {
				var tupleId = tupleIDs[$t1];
				var markInvalRects = this.$getMarkInvalidationRects(tupleId);
				for (var $t2 = 0; $t2 < markInvalRects.length; $t2++) {
					var rect = markInvalRects[$t2];
					rects.push(rect);
				}
			}
			return rects;
		},
		$getMarkInvalidationRects: function SceneInfo$GetMarkInvalidationRects(tupleId) {
			var invalAll = false;
			var invalRects = [];
			var panes = this.$runtimeData.get_panes();
			for (var $t1 = 0; $t1 < panes.length; $t1++) {
				var ppm = panes[$t1];
				if (_.isArray(ppm.renderNodes) && ppm.renderNodes.length > 0) {
					invalAll = true;
					break;
				}
			}
			var paneDrawInfo = this.getPaneDrawInfoFromTupleId(tupleId);
			if (ss.isNullOrUndefined(paneDrawInfo)) {
				return invalRects;
			}
			var markType = paneDrawInfo.markType;
			if (invalAll) {
				invalRects.push(paneDrawInfo.paneRect);
			}
			else if (markType === 'area' || markType === 'line') {
				invalRects.push(paneDrawInfo.paneRect);
			}
			else {
				var markRect = this.$getFullMarkBounds(tupleId);
				var boundingBoxes = paneDrawInfo.getWorldOffsetBounds(markRect);
				for (var $t2 = 0; $t2 < boundingBoxes.length; $t2++) {
					var box = boundingBoxes[$t2];
					invalRects.push(box);
				}
				var labelRect = this.$getLabelBoundingBox(tupleId);
				if (!tab.RectXYUtil.isNull(labelRect)) {
					var labelBoxes = paneDrawInfo.getWorldOffsetBounds(labelRect);
					for (var $t3 = 0; $t3 < labelBoxes.length; $t3++) {
						var box1 = labelBoxes[$t3];
						invalRects.push(box1);
					}
				}
			}
			return invalRects;
		},
		updateImageMap: function SceneInfo$UpdateImageMap(imageDictPM, imageLoadedCallback) {
			if (ss.isValue(imageDictPM) && ss.isValue(imageDictPM.imageMap)) {
				var $t1 = new ss.ObjectEnumerator(imageDictPM.imageMap);
				try {
					while ($t1.moveNext()) {
						var hashImagePair = $t1.current();
						var imageKey = hashImagePair.key;
						if (!this.$hashToImageEltMap.has(imageKey)) {
							var imageData = hashImagePair.value;
							var $t2 = document.createElement('img');
							var imgElt = { $: ss.cast($t2, ss.isValue($t2) && (ss.isInstanceOfType($t2, Element) && $t2.tagName === 'IMG')) };
							imgElt.$.src = 'data:image/jpeg;base64,' + imageData;
							this.$hashToImageEltMap.set(imageKey, imgElt.$);
							var imageFinishedLoad = { $: null };
							imageFinishedLoad.$ = ss.mkdel({ imgElt: imgElt, imageFinishedLoad: imageFinishedLoad }, function() {
								if (ss.isValue(imageLoadedCallback)) {
									imageLoadedCallback();
								}
								this.imgElt.$.removeEventListener('load', this.imageFinishedLoad.$, false);
							});
							imgElt.$.addEventListener('load', imageFinishedLoad.$, false);
						}
					}
				}
				finally {
					$t1.dispose();
				}
				this.$hashToImageEltMap.forEach(ss.mkdel(this, function(element, imgHash) {
					if (!ss.keyExists(imageDictPM.imageMap, imgHash)) {
						this.$hashToImageEltMap.delete(imgHash);
					}
				}));
			}
		},
		$isMarkSelected: function SceneInfo$IsMarkSelected(tupleId) {
			return this.get_hasSelection() && this.selections.tupleSelection.isObjectSelected(tupleId);
		},
		$isMarkBrushed: function SceneInfo$IsMarkBrushed(tupleId) {
			return this.get_hasBrushing() && (ss.isValue(this.brushings) && this.brushings.tupleSelection.isObjectSelected(tupleId) || this.$isMarkImpliedSelected(tupleId));
		},
		$isMarkImpliedSelected: function SceneInfo$IsMarkImpliedSelected(tupleId) {
			return ss.isValue(this.$impliedSelection) && this.$impliedSelection.isObjectSelected(tupleId);
		},
		$isMarkVisible: function SceneInfo$IsMarkVisible(tupleId) {
			return !this.$hiddenTuples.has(tupleId.toString());
		},
		isMarkFiltered: function SceneInfo$IsMarkFiltered(tupleId) {
			return this.$filteredTuples.has(tupleId.toString());
		},
		setLabelInfo: function SceneInfo$SetLabelInfo(runtimeDataIn, currentPage) {
			var labelStore = runtimeDataIn.get_annexedData().LabelStore;
			if (ss.isValue(labelStore) && ss.isValue(labelStore.Panes)) {
				for (var $t1 = 0; $t1 < labelStore.Panes.length; $t1++) {
					var pane = labelStore.Panes[$t1];
					var drawPanes = pane.DrawPanes;
					for (var i = 0; i < drawPanes.length; ++i) {
						var panePartArray = drawPanes[i];
						var visualPart = tab.EnumConversions.visualPartFromInt(panePartArray[0]);
						var paneIndex = panePartArray[1];
						var paneMarksInfo = new tab.PaneMarksInfo.$ctor1(runtimeDataIn.get_finalDataStore().Viewpoint.PerPaneExtents, runtimeDataIn.get_labelsPaneStoreTable(), paneIndex, currentPage, pane.Row, pane.Column);
						if (visualPart === 'marks') {
							var key = $tab_SceneInfo.getPaneMarksKey$1(paneMarksInfo.get_paneKey(), paneMarksInfo.get_paneId(), paneIndex);
							if (this.$paneDrawInfoMap.has(key)) {
								var paneDrawInfo = this.$paneDrawInfoMap.get(key);
								var markLayoutOutput = labelStore.PDMarks[paneMarksInfo.get_paneKey()];
								tab.FontNotificationUtil.notifyFontsFromMarkLayoutOutput(markLayoutOutput);
								paneDrawInfo.addLabelInfo(markLayoutOutput, paneMarksInfo.get_startIndex(), paneMarksInfo.get_endIndex());
							}
						}
					}
				}
			}
		},
		getPaneDrawInfo: function SceneInfo$GetPaneDrawInfo(paneMarksInfo) {
			var toRet = null;
			if (ss.isValue(paneMarksInfo)) {
				toRet = this.$paneDrawInfoMap.get($tab_SceneInfo.getPaneMarksKey(paneMarksInfo));
			}
			return toRet;
		},
		getPaneDrawInfo$1: function SceneInfo$GetPaneDrawInfo(paneIndex, row, column) {
			var paneMarksInfo = new tab.PaneMarksInfo.$ctor1(this.$runtimeData.get_finalDataStore().Viewpoint.PerPaneExtents, this.$runtimeData.get_paneStoreTable(), paneIndex, this.$currentPage, row, column);
			return this.$paneDrawInfoMap.get($tab_SceneInfo.getPaneMarksKey(paneMarksInfo));
		},
		getPaneDrawInfoFromKey: function SceneInfo$GetPaneDrawInfoFromKey(paneMarksKey) {
			return this.$paneDrawInfoMap.get(paneMarksKey);
		},
		getPaneDrawInfoFromTupleId: function SceneInfo$GetPaneDrawInfoFromTupleId(tupleId) {
			var result = null;
			tab.MapUtility.forEachWithInterrupt(String, $tab_PaneDrawInfo).call(null, this.$paneDrawInfoMap, function(paneDrawInfo) {
				if (paneDrawInfo.containsTuple(tupleId)) {
					result = paneDrawInfo;
					throw new tab.LoopBreakException();
				}
			});
			return result;
		},
		getPaneDrawInfoAssociatedWithPane: function SceneInfo$GetPaneDrawInfoAssociatedWithPane(pane) {
			var drawPanes = pane.DrawPanes;
			for (var $t1 = 0; $t1 < drawPanes.length; $t1++) {
				var drawPane = drawPanes[$t1];
				var visualList = drawPane;
				var visualPart = tab.EnumConversions.visualPartFromInt(visualList[0]);
				if (visualPart === 'marks') {
					var paneIndex = visualList[1];
					return this.getPaneDrawInfo$1(paneIndex, pane.Row, pane.Column);
				}
			}
			return null;
		},
		setIsTargetOfBrushingAction: function SceneInfo$SetIsTargetOfBrushingAction(isTarget) {
			this.$isTargetOfBrushingAction = isTarget;
		},
		setEmptyHighlightFogAll: function SceneInfo$SetEmptyHighlightFogAll(emptyHighlight) {
			this.$emptyHighlightFogAll = emptyHighlight;
		},
		$addMarkBoundingBoxes: function SceneInfo$AddMarkBoundingBoxes(paneDrawInfo, bboxes) {
			$tab_SceneInfo.$addBoundingBoxesForPane(paneDrawInfo, bboxes, this.$markBoundingBoxes);
		},
		$addLabelBoundingBoxes: function SceneInfo$AddLabelBoundingBoxes(paneDrawInfo, bboxes) {
			$tab_SceneInfo.$addBoundingBoxesForPane(paneDrawInfo, bboxes, this.$labelBoundingBoxes);
		},
		$addFullMarkBoundingBoxes: function SceneInfo$AddFullMarkBoundingBoxes(paneDrawInfo, bbox, tupleIDs) {
			tab.RectXYUtil.offsetRectXYInPlace(bbox, paneDrawInfo.paneRect.x, paneDrawInfo.paneRect.y);
			for (var $t1 = 0; $t1 < tupleIDs.length; $t1++) {
				var tuple = tupleIDs[$t1];
				this.$fullMarkBoundingBoxes.set(tuple, bbox);
			}
		},
		$isEncodedGeometryData: function SceneInfo$IsEncodedGeometryData(source) {
			return ss.isInstanceOfType(source, Float32Array) || ss.isInstanceOfType(source, Array);
		},
		$parseGeometries: function SceneInfo$ParseGeometries(runtimeDataIn) {
			if (!ss.isValue(runtimeDataIn)) {
				return;
			}
			var dataStore = runtimeDataIn.get_finalDataStore();
			var paneExtents = dataStore.Viewpoint.PerPaneExtents;
			var pdMarks = dataStore.PDMarks;
			var geometriesDictionary = runtimeDataIn.get_geometries();
			var $t1 = _.keys(pdMarks);
			for (var $t2 = 0; $t2 < $t1.length; $t2++) {
				var pdMarksKey = $t1[$t2];
				if (!ss.keyExists(geometriesDictionary, pdMarksKey)) {
					continue;
				}
				var geometries = geometriesDictionary[pdMarksKey];
				var markLayoutOutput = pdMarks[pdMarksKey];
				var paneFlags = markLayoutOutput.MarkLayoutData.Parameters.pane_flags;
				var scaleMarks = tab.SceneDataUtil.isPaneFlagSet(paneFlags, 'enable-scale-x') && tab.SceneDataUtil.isPaneFlagSet(paneFlags, 'enable-scale-y');
				var domainRect = null;
				var paneRect = null;
				var paneFound = false;
				if (scaleMarks) {
					var paneMarksArray = runtimeDataIn.get_annexedData().Panes;
					for (var $t3 = 0; $t3 < paneMarksArray.length; $t3++) {
						var paneMarks = paneMarksArray[$t3];
						for (var $t4 = 0; $t4 < paneMarks.DrawPanes.length; $t4++) {
							var visualList = paneMarks.DrawPanes[$t4];
							var panePartArray = visualList;
							var paneIndex = panePartArray[1];
							if (ss.referenceEquals(paneExtents.PaneKey[paneIndex], pdMarksKey)) {
								domainRect = tab.DoubleRectXYUtil.constructDoubleRectXY(paneExtents.DomainLeft[paneIndex], paneExtents.DomainTop[paneIndex], paneExtents.DomainRight[paneIndex], paneExtents.DomainBottom[paneIndex]);
								paneRect = { x: 0, y: 0, w: paneExtents.pane_px_right[paneIndex] - paneExtents.pane_px_left[paneIndex], h: paneExtents.pane_px_bottom[paneIndex] - paneExtents.pane_px_top[paneIndex] };
								paneFound = true;
								break;
							}
						}
						if (paneFound) {
							break;
						}
					}
				}
				var geometryCount = geometries.length;
				var parsedGeometries = new Array(geometryCount);
				for (var i = 0; i < geometryCount; i++) {
					var geometryPM;
					parsedGeometries[i] = null;
					if (this.$isEncodedGeometryData(geometries[i])) {
						if (geometries[i].length < 1) {
							continue;
						}
						var decoder = new tab.LinearFloatGeometryDecoder(geometries[i]);
						geometryPM = decoder.processEncodedGeometry();
					}
					else {
						var strGeometry;
						if (ss.isInstanceOfType(geometries[i], Uint8Array)) {
							strGeometry = tab.Utf8TextDecoder.decode(geometries[i]);
						}
						else {
							strGeometry = geometries[i];
						}
						if (tab.MiscUtil.isNullOrEmpty$3(strGeometry)) {
							continue;
						}
						geometryPM = JSON.parse(strGeometry);
					}
					if ($tab_GeometryUtil.isGeometryPresModelFeatureEmpty(geometryPM)) {
						continue;
					}
					if (scaleMarks && paneFound) {
						$tab_GeometryUtil.domainToPixelGeometry(geometryPM, domainRect, paneRect, true);
					}
					parsedGeometries[i] = geometryPM;
				}
				this.$markGeometries.set(pdMarksKey, parsedGeometries);
			}
		},
		$getFullMarkBounds: function SceneInfo$GetFullMarkBounds(tupleId) {
			var bbox = this.$fullMarkBoundingBoxes.get(tupleId);
			if (ss.isNullOrUndefined(bbox)) {
				bbox = this.getMarkBoundingBox(tupleId);
			}
			return bbox;
		},
		$computeDirtyMarks: function SceneInfo$ComputeDirtyMarks(dirtyRect) {
			this.$paneDrawInfoMap.forEach(function(paneDrawInfo) {
				paneDrawInfo.computeDirtyMarks(dirtyRect);
			});
		},
		$clearDirtyMarks: function SceneInfo$ClearDirtyMarks() {
			this.$paneDrawInfoMap.forEach(function(paneDrawInfo) {
				paneDrawInfo.clearDirtyMarks();
			});
		},
		$refreshMarkState: function SceneInfo$RefreshMarkState() {
			this.$paneDrawInfoMap.forEach(function(paneDrawInfo) {
				paneDrawInfo.refreshMarkState();
			});
		}
	});
	ss.initClass($tab_SceneUserPaneInfo, $asm, {});
	$tab_SceneUserPaneInfo.$ctor1.prototype = $tab_SceneUserPaneInfo.prototype;
	ss.initClass($tab_ServerRenderVizHitTestDebouncer, $asm, {
		hitTest: function ServerRenderVizHitTestDebouncer$HitTest(regionCoordinates, pageCoordinates) {
			tab.Log.get(this).debug('ServerRenderVizHitTestDebouncer.HitTest', []);
			ss.Debug.assert(!tab.ApplicationModel.get_instance().get_isLocalRenderMode(), 'should not use when local rendering');
			var $t1 = new tab.HitTestSceneCmd();
			$t1.cmdParams['pt1'] = tab.PointUtil.toPresModel(regionCoordinates);
			$t1.cmdParams['visualIdPresModel'] = this.region.get_visualId();
			$t1.invoke().done(ss.mkdel(this, function(response) {
				var hits = response.$$cmdParams['sceneElements'];
				if (ss.isValue(hits) && hits.length > 0 && ss.isValue(this.paneTable)) {
					var sceneElement = new tab.SceneElementModel(hits[0]);
					var paneId = sceneElement.get_paneId();
					var paneSpecId = this.makePaneSpecId(paneId.get_columnIndex(), paneId.get_rowIndex());
					var hitResult = new $tab_HitTestResult(sceneElement);
					this.setCurrent(new $tab_VizHitInfo(this.region, paneSpecId, paneId.get_columnIndex(), paneId.get_rowIndex(), regionCoordinates, pageCoordinates, hitResult));
				}
				else {
					this.setCurrent(null);
				}
			}));
		}
	}, $tab_VizHitTestDebouncer, [ss.IDisposable, tab.IVizHitTestDebouncer]);
	ss.initClass($tab_ShapeDependencyManager, $asm, {
		dispose: function ShapeDependencyManager$Dispose() {
			this.$shapeLoadedCallback = null;
			tab.ApplicationModel.get_instance().get_shapeManager().remove_shapeLoaded(ss.mkdel(this, this.onShapeLoaded));
		},
		initialize: function ShapeDependencyManager$Initialize(ids) {
			this.$shapes.clear();
			for (var $t1 = 0; $t1 < ids.length; $t1++) {
				var id = ids[$t1];
				this.$add(id);
			}
			this.$callbackIfAllShapesAreLoaded();
		},
		$add: function ShapeDependencyManager$Add(id) {
			if (tab.SceneDataUtil.isCustomShape(id) && !tab.ApplicationModel.get_instance().get_shapeManager().hasShape(id)) {
				this.$shapes.add(id);
			}
		},
		onShapeLoaded: function ShapeDependencyManager$OnShapeLoaded(id) {
			if (!this.$shapes.has(id)) {
				return;
			}
			this.$shapes.delete(id);
			this.$callbackIfAllShapesAreLoaded();
		},
		$callbackIfAllShapesAreLoaded: function ShapeDependencyManager$CallbackIfAllShapesAreLoaded() {
			if (this.$shapes.size === 0 && ss.isValue(this.$shapeLoadedCallback)) {
				this.$shapeLoadedCallback();
			}
		}
	}, null, [ss.IDisposable]);
	ss.initClass($tab_ShapeUtil, $asm, {});
	ss.initClass($tab_SimpleRegionCanvasView, $asm, {
		get_displayListRenderer: function SimpleRegionCanvasView$get_DisplayListRenderer() {
			return ss.cast(this.renderer, $tab_DisplayList2DRenderer);
		},
		get_visualListVM: function SimpleRegionCanvasView$get_VisualListVM() {
			return this.get_viewModel();
		},
		get_backgroundFillColor: function SimpleRegionCanvasView$get_BackgroundFillColor() {
			return this.$paneTableVM.get_visualModel().get_backgroundColor();
		},
		$handleImageLoadedChanged: function SimpleRegionCanvasView$HandleImageLoadedChanged(sender, e) {
			if (ss.referenceEquals(e.get_propertyName(), $tab_PaneTableViewModel.imageLoadedPropertyName)) {
				this.invalidate(false);
			}
		},
		performRender: function SimpleRegionCanvasView$PerformRender() {
			var mc = tabBootstrap.MetricsController.createContext('RNDRRG'.toString(), 32, null);
			try {
				this.get_displayListRenderer().clear();
				this.get_displayListRenderer().renderVisualList(this.get_visualListVM(), this.$paneTableVM.get_scene().get_imageDictionary());
			}
			finally {
				if (ss.isValue(mc)) {
					mc.dispose();
				}
			}
		},
		postRenderFinalPass: function SimpleRegionCanvasView$PostRenderFinalPass() {
			this.get_displayListRenderer().renderCanvasBorders(this.get_visualListVM());
		},
		onViewModelPropertyChanged: function SimpleRegionCanvasView$OnViewModelPropertyChanged(sender, e) {
			if (ss.referenceEquals(e.get_propertyName(), $tab_VisualListViewModel.propertyHoverNode)) {
				var offset = { x: -this.get_scrollPos().x, y: -this.get_scrollPos().y };
				this.invalidateRect(this.get_visualListVM().dirtyRect(offset), true);
			}
			else {
				ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_VisualListViewModel]).prototype.onViewModelPropertyChanged.call(this, sender, e);
			}
		}
	}, ss.makeGenericType($tab_VisualRegionCanvasView$1, [$tab_VisualListViewModel]), [tab.IWidget, tab.IAppendableView, ss.IDisposable, ss.makeGenericType(tab.IView$1, [$tab_VisualListViewModel]), spiff.IScrollable, tab.IRegionContentProvider]);
	ss.initClass($tab_SmoothTooltipsOnboardingComponent, $asm, {
		$onTransitionEnd: function SmoothTooltipsOnboardingComponent$OnTransitionEnd() {
			this.$animationIsInProgress = false;
			window.clearTimeout(this.$forceTransitionEndTimeoutId);
			if (ss.isValue(this.$pendingProps)) {
				this.$updateStateFromProps(this.$pendingProps);
				this.$pendingProps = null;
			}
		},
		$updateStateFromProps: function SmoothTooltipsOnboardingComponent$UpdateStateFromProps(nextProps) {
			this.setState({ visible: nextProps.visible, transitionDurationMs: nextProps.transitionDurationMs, transitionDelayMs: nextProps.transitionDelayMs, animationId: this.state.animationId + 1 });
		},
		componentWillReceiveProps: function SmoothTooltipsOnboardingComponent$ComponentWillReceiveProps(nextProps) {
			var nextAnimationHasDelay = nextProps.transitionDelayMs > 0;
			var shouldDeferNextAnimation = this.$animationIsInProgress && nextAnimationHasDelay;
			if (shouldDeferNextAnimation) {
				this.$pendingProps = nextProps;
			}
			else {
				this.$pendingProps = null;
				this.$updateStateFromProps(nextProps);
			}
		},
		shouldComponentUpdate: function SmoothTooltipsOnboardingComponent$ShouldComponentUpdate(nextProps, nextState) {
			var stateRepresentsNewAnimation = this.state.animationId !== nextState.animationId;
			return stateRepresentsNewAnimation;
		},
		componentWillUpdate: function SmoothTooltipsOnboardingComponent$ComponentWillUpdate(nextProps, nextState) {
			this.$animationIsInProgress = true;
			var forceTransitionEndTimeoutMs = nextState.transitionDelayMs + nextState.transitionDurationMs + $tab_SmoothTooltipsOnboardingComponent.transitionEndFailSafeTimeoutMs;
			this.$forceTransitionEndTimeoutId = window.setTimeout(ss.mkdel(this, this.$onTransitionEnd), forceTransitionEndTimeoutMs);
		},
		componentWillUnmount: function SmoothTooltipsOnboardingComponent$ComponentWillUnmount() {
			window.clearTimeout(this.$forceTransitionEndTimeoutId);
		},
		render: function SmoothTooltipsOnboardingComponent$Render() {
			var properties = { opacity: (this.state.visible ? 1 : 0), transitionDuration: tab.DomUtil.toMsString(this.state.transitionDurationMs), transitionDelay: tab.DomUtil.toMsString(this.state.transitionDelayMs) };
			return spiff.DOMElements.div({ className: $tab_SmoothTooltipsOnboardingComponent.rootElementClass, style: properties, onTransitionEnd: this.$boundOnTransitionEnd }, spiff.DOMElements.p({ className: $tab_SmoothTooltipsOnboardingComponent.textClass, children: tab.Strings.SmoothTooltipsOnboardingText }));
		}
	}, React.Component);
	ss.initClass($tab_SmoothTooltipsOnboardingViewModel, $asm, {
		$showTip: function SmoothTooltipsOnboardingViewModel$ShowTip(delayFadeIn) {
			this.$visible = true;
			this.$transitionDurationMs = $tab_SmoothTooltipsOnboardingViewModel.fadeInDurationMs;
			this.$transitionDelayMs = (delayFadeIn ? $tab_SmoothTooltipsOnboardingViewModel.fadeInDelayMs : 0);
			this.incrementProps();
		},
		$hideTip: function SmoothTooltipsOnboardingViewModel$HideTip(delayFadeOut) {
			this.$visible = false;
			this.$transitionDurationMs = $tab_SmoothTooltipsOnboardingViewModel.fadeOutDurationMs;
			this.$transitionDelayMs = (delayFadeOut ? $tab_SmoothTooltipsOnboardingViewModel.fadeOutDelayMs : 0);
			this.incrementProps();
		},
		createSuppressTipCookie: function SmoothTooltipsOnboardingViewModel$CreateSuppressTipCookie() {
			tab.CookieHelper.setCookie($tab_SmoothTooltipsOnboardingViewModel.twoFingerScrollOnboardingTipWasAcknowledgedCookie, true.toString(), '/', null);
		},
		$onboardingTipEnabled: function SmoothTooltipsOnboardingViewModel$OnboardingTipEnabled() {
			var cookieValue = tab.CookieHelper.getValueForCookie($tab_SmoothTooltipsOnboardingViewModel.twoFingerScrollOnboardingTipWasAcknowledgedCookie);
			var wasTwoFingerScrollTipAcknowledged = tab.MiscUtil.toBoolean(cookieValue, false);
			return tab.GestureModelSettings.get_onboardingEnabled() && tsConfig.is_mobile && !wasTwoFingerScrollTipAcknowledged;
		},
		showTipImmediatelyIfNotSuppressed: function SmoothTooltipsOnboardingViewModel$ShowTipImmediatelyIfNotSuppressed() {
			if (this.$onboardingTipEnabled()) {
				this.$showTip(false);
			}
		},
		hideTipWithDelayIfNotSuppressed: function SmoothTooltipsOnboardingViewModel$HideTipWithDelayIfNotSuppressed() {
			if (this.$visible) {
				this.$hideTip(true);
			}
		},
		hideTipImmediatelyIfNotSuppressed: function SmoothTooltipsOnboardingViewModel$HideTipImmediatelyIfNotSuppressed() {
			this.$hideTip(false);
		},
		suppressTip: function SmoothTooltipsOnboardingViewModel$SuppressTip() {
			if (this.$onboardingTipEnabled()) {
				this.$hideTip(false);
				this.createSuppressTipCookie();
			}
		},
		createUpdatedProps: function SmoothTooltipsOnboardingViewModel$CreateUpdatedProps() {
			return { visible: this.$visible, transitionDurationMs: this.$transitionDurationMs, transitionDelayMs: this.$transitionDelayMs };
		}
	}, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [ss.IDisposable, tab.IViewModel, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
	ss.initClass($tab_TiledViewerRegion, $asm, {
		get_isDragTracking: function TiledViewerRegion$get_IsDragTracking() {
			return false;
		},
		get_isScrollable: function TiledViewerRegion$get_IsScrollable() {
			return this.get_contentProvider().get_canScrollX() || this.get_contentProvider().get_canScrollY();
		},
		get_name: function TiledViewerRegion$get_Name() {
			return this.get_regionPart().toString();
		},
		get_regionPart: function TiledViewerRegion$get_RegionPart() {
			return this.$regionPart;
		},
		get_visualId: function TiledViewerRegion$get_VisualId() {
			return this.paneTableViewModel.get_visualId();
		},
		get_sheetid: function TiledViewerRegion$get_Sheetid() {
			return this.$sheetid;
		},
		get_contentProvider: function TiledViewerRegion$get_ContentProvider() {
			return this.regionContent;
		},
		set_contentProvider: function TiledViewerRegion$set_ContentProvider(value) {
			this.regionContent.remove_loadComplete(ss.mkdel(this, this.onRegionContentLoadComplete));
			this.regionContent = value;
			this.regionContent.add_loadComplete(ss.mkdel(this, this.onRegionContentLoadComplete));
		},
		get_shapeSelector: function TiledViewerRegion$get_ShapeSelector() {
			return this.$shapeSelector;
		},
		get_visualObjectBoundsComputerAndHitTester: function TiledViewerRegion$get_VisualObjectBoundsComputerAndHitTester() {
			return this.$visualObjectBoundsComputerAndHitTester;
		},
		get_toolModeViewModel: function TiledViewerRegion$get_ToolModeViewModel() {
			return this.$toolModeViewModel;
		},
		sendSelectionCommand: function TiledViewerRegion$SendSelectionCommand(region, action, visualId, tooltipCallback) {
			this.get_shapeSelector().sendSelectionCommand(region, action, visualId, tooltipCallback);
		},
		turnOnWindowLogging: function TiledViewerRegion$TurnOnWindowLogging() {
			if (!ss.isValue($tab_TiledViewerRegion.windowLog)) {
				$tab_TiledViewerRegion.windowLog = tab.Logger.getLoggerWithName('WindowAppender');
			}
		},
		reset: function TiledViewerRegion$Reset() {
			this.get_toolModeViewModel().handleDeferredModeChangeIfNeeded();
			if (this.shouldResetVisualState()) {
				return;
			}
			this.resetVisualState();
		},
		resetVisualState: function TiledViewerRegion$ResetVisualState() {
			var marksCanvas = $tab_TiledViewerRegion.getCanvasElement(this.connectNode);
			if (ss.isValue(marksCanvas)) {
				marksCanvas.style.visibility = 'visible';
			}
			this.setViewportBorderVisibility(false);
			this.backgroundMap.removeMarkOverlay();
			this.hideDomDragImage();
			this.zoomAnimationProtectionGlass = tab.MiscUtil.dispose$1(this.zoomAnimationProtectionGlass);
		},
		destroy: function TiledViewerRegion$Destroy() {
			tab.Log.get(this).debug('Destroy', []);
			this.disposables.dispose();
			this.allowPanZoomActions = null;
			this.regionContent.remove_loadComplete(ss.mkdel(this, this.onRegionContentLoadComplete));
			this.regionContent.destroy();
			this.backgroundMap.destroyMap();
			this.backgroundMap.dispose();
			this.get_toolModeViewModel().remove_toolbarToolModeUpdated(ss.mkdel(this, this.updateForToolMode));
			this.zoomAnimationProtectionGlass = tab.MiscUtil.dispose$1(this.zoomAnimationProtectionGlass);
		},
		setGeometry: function TiledViewerRegion$SetGeometry(regionGeometry, viewSize, tileSize) {
			if (this.regionContent.get_hasContent()) {
				this.regionContent.set_actualViewSize({ w: viewSize.w, h: viewSize.h });
				this.regionContent.reset(regionGeometry, tileSize);
				this.$regionSize = { x: 0, y: 0, w: regionGeometry.w, h: regionGeometry.h };
				this.updateSelectorShape(this.get_toolModeViewModel().get_currentPointerToolMode());
			}
		},
		refreshImages: function TiledViewerRegion$RefreshImages(tileCacheUrl) {
			this.regionContent.refreshImages(tileCacheUrl);
		},
		onZoomBoxMouseMove: function TiledViewerRegion$OnZoomBoxMouseMove(e) {
			this.onSelectorMouseMove(e, this.domPanZoomRect);
		},
		onMarqueeMouseMove: function TiledViewerRegion$OnMarqueeMouseMove(e) {
			this.onSelectorMouseMove(e, this.$shapeSelector);
		},
		onSelectorMouseMove: function TiledViewerRegion$OnSelectorMouseMove(e, selector) {
			e.preventDefault();
			var xOffset = (tab.FeatureFlags.isEnabled('ScrollingTables') ? 0 : this.scroller.get_scrollPos().x);
			selector.recordScrollingOffsets({ x: xOffset, y: this.scroller.get_scrollPos().y });
			var posNode = selector.get_connectNodePos();
			var vizX = e.get_GestureInfo().pageX - posNode.x;
			var vizY = e.get_GestureInfo().pageY - posNode.y;
			var outsideVizX = ((vizX < 0) ? vizX : ((vizX > posNode.w) ? (vizX - posNode.w) : 0));
			var outsideVizY = ((vizY < 0) ? vizY : ((vizY > posNode.h) ? (vizY - posNode.h) : 0));
			var scrollX = this.determineScrollDirection(0, outsideVizX);
			var scrollY = this.determineScrollDirection(1, outsideVizY);
			var scrollInterval = ((Math.max(Math.abs(outsideVizX), Math.abs(outsideVizY)) > 15) ? 'fast' : 'slow');
			if (scrollX !== 0 || scrollY !== 0) {
				this.startScrolling(scrollX, scrollY, scrollInterval);
				selector.constrainShape(e.get_GestureInfo());
			}
			else {
				this.stopScrolling();
				selector.updateAndRenderShape(e.get_GestureInfo());
			}
		},
		$isValidLocallyRenderedAxis: function TiledViewerRegion$IsValidLocallyRenderedAxis(drawGroup) {
			var isQAxis = true;
			if (ss.isNullOrUndefined(drawGroup)) {
				return false;
			}
			if (this.get_regionPart() === 'bottomaxis') {
				isQAxis = tab.SelectionUtils.isQuantitative(drawGroup);
			}
			if (isQAxis) {
				return true;
			}
			return false;
		},
		onRightClickAxis: function TiledViewerRegion$OnRightClickAxis(pseudoEvent) {
			var regionCoordinates = this.toLocalCoordsEvent(pseudoEvent, false);
			var visualPart = tab.ModelUtils.regionToVisualPartMap[this.get_regionPart()];
			var visualListVM = this.paneTableViewModel.get_vizRegionMap()[visualPart];
			if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode() || ss.isNullOrUndefined(visualListVM)) {
				tab.AxisAuthoringTelemetry.logRightClickAxisEvent();
				return;
			}
			var drawGroup = visualListVM.hitTestNodes(regionCoordinates);
			if (this.$isValidLocallyRenderedAxis(drawGroup)) {
				tab.AxisAuthoringTelemetry.logRightClickAxisEvent();
			}
		},
		onDoubleTapAxis: function TiledViewerRegion$OnDoubleTapAxis(pseudoEvent) {
			var regionCoordinates = this.toLocalCoordsEvent(pseudoEvent, false);
			var visualPart = tab.ModelUtils.regionToVisualPartMap[this.get_regionPart()];
			var visualListVM = this.paneTableViewModel.get_vizRegionMap()[visualPart];
			if (!tab.ApplicationModel.get_instance().get_isLocalRenderMode() || ss.isNullOrUndefined(visualListVM)) {
				tab.EditAxisDialogCommands.showEditAxisDialogInServerRenderedMode(this.get_visualId(), regionCoordinates, this.get_regionPart());
				return;
			}
			var drawGroup = visualListVM.hitTestNodes(regionCoordinates);
			if (this.$isValidLocallyRenderedAxis(drawGroup)) {
				tab.EditAxisDialogCommands.showEditAxisDialogInBrowserRenderedMode(drawGroup.node);
			}
		},
		debugWindowLog: function TiledViewerRegion$DebugWindowLog(a) {
			if (ss.isValue($tab_TiledViewerRegion.windowLog)) {
				$tab_TiledViewerRegion.windowLog.debug(a(), []);
			}
		},
		toLocalCoords: function TiledViewerRegion$ToLocalCoords(position, doNotIncludeScroll) {
			var localOffset = this.getLocalOffsetPoint(doNotIncludeScroll);
			var ret = { x: position.x - localOffset.x, y: position.y - localOffset.y };
			return ret;
		},
		toLocalCoordsRect: function TiledViewerRegion$ToLocalCoordsRect(rect, doNotIncludeScroll) {
			var localRect = this.getLocalOffset(doNotIncludeScroll);
			var localOffset = { x: localRect.x, y: localRect.y };
			var ret = { x: rect.x - localOffset.x, y: rect.y - localOffset.y, w: rect.w, h: rect.h };
			return ret;
		},
		toLocalCoordsEvent: function TiledViewerRegion$ToLocalCoordsEvent(ev, doNotIncludeScroll) {
			var position = { x: ev.get_GestureInfo().pageX, y: ev.get_GestureInfo().pageY };
			return this.toLocalCoords(position, doNotIncludeScroll);
		},
		getLocalOffset: function TiledViewerRegion$GetLocalOffset(doNotIncludeScroll) {
			var posOrigin = tab.DomUtil.getRectXY(this.connectNode);
			if (doNotIncludeScroll) {
				return posOrigin;
			}
			posOrigin.x -= this.regionContent.get_scrollPos().x;
			posOrigin.y -= this.regionContent.get_scrollPos().y;
			return posOrigin;
		},
		getLocalOffsetPoint: function TiledViewerRegion$GetLocalOffsetPoint(doNotIncludeScroll) {
			var localRect = this.getLocalOffset(doNotIncludeScroll);
			var localOffsetPoint = { x: localRect.x, y: localRect.y };
			return localOffsetPoint;
		},
		moveMapToBounds: function TiledViewerRegion$MoveMapToBounds(bounds) {
			if (this.paneTableViewModel.get_visualModel().get_shouldUpdate()) {
				this.setViewportBorderVisibility(true);
				this.backgroundMap.splatOverlayToMapForTransition($tab_TiledViewerRegion.getCanvasElement(this.connectNode));
				this.backgroundMap.moveToBounds(bounds);
			}
		},
		isExistingSelection: function TiledViewerRegion$IsExistingSelection() {
			var tupleSelection = tab.ModelUtils.getVisualModelFromVisualId(this.get_visualId(), null).get_selectionsModel().tupleSelection;
			return tupleSelection.get_ids().length !== 0;
		},
		$resetView: function TiledViewerRegion$ResetView() {
			this.get_contentProvider().set_scrollPos({ x: 0, y: 0 });
		},
		suppressTooltips: function TiledViewerRegion$SuppressTooltips() {
		},
		anchorZoomStart: function TiledViewerRegion$AnchorZoomStart() {
			if (this.isWaitingOnPanZoomServerResponse()) {
				return;
			}
			this.setWaitingOnPanZoomServerResponseState();
			if (this.mapIsBrowserRendered()) {
				this.setViewportBorderVisibility(true);
				this.backgroundMap.splatOverlayToMapForTransition($tab_TiledViewerRegion.getCanvasElement(this.connectNode));
			}
		},
		anchorZoom: function TiledViewerRegion$AnchorZoom(paneInfo, anchorPoint, zoomLevel, zoomFactor, animate) {
			if (this.mapIsBrowserRendered()) {
				this.animateAnchorZoomMap(paneInfo, anchorPoint, zoomLevel, animate);
			}
			else {
				this.animateAnchorZoomImage(paneInfo, anchorPoint, zoomFactor);
			}
		},
		anchorZoomEnd: function TiledViewerRegion$AnchorZoomEnd(paneInfo, anchorPoint, zoomLevel, zoomFactor, metricContext) {
			if (this.mapIsBrowserRendered()) {
				this.backgroundMap.updateLocalMapDataForZoomAround(anchorPoint, zoomLevel);
			}
			var onLocalWorkCompleted = ss.mkdel(this, function() {
				if (this.paneTableViewModel.get_visualModel().get_runtimeReady()) {
					this.reset();
				}
			});
			var onZoomCompleted = ss.mkdel(this, function(result) {
				if (ss.isValue(metricContext) && result === 'success') {
					metricContext.dispose();
				}
				if (result === 'failure') {
					this.reset();
				}
				this.clearWaitingOnPanZoomServerResponseState();
			});
			tab.PanZoomCommands.zoomWithAnchorPoint(this.get_regionPart(), anchorPoint, 1 / zoomFactor, onLocalWorkCompleted, onZoomCompleted, this.get_sheetid());
		},
		zoomPoint: function TiledViewerRegion$ZoomPoint(paneInfo, point, scale, isDoubleClick, deferAPIforDoubleClick) {
			if (this.resetIsWaitingOnTransition) {
				return;
			}
			if (this.isWaitingOnPanZoomServerResponse()) {
				return;
			}
			var mapZoomLocalWorkCompleteMetricsContext = $tab_TiledViewerRegionMetrics.createMapZoomLocalWorkCompleteContext();
			var mapZoomFullyCompleteMetricsContext = $tab_TiledViewerRegionMetrics.createMapZoomFullyCompleteContext();
			this.setWaitingOnPanZoomServerResponseState();
			var paneResolverPoint = point || $tab_TiledViewerRegion.getCenterPoint(paneInfo);
			this.suppressTooltips();
			this.zoomAnimationProtectionGlass = new spiff.Glass(null, false);
			this.zoomAnimationProtectionGlass.show();
			var onLocalWorkCompleted = ss.mkdel(this, function() {
				mapZoomLocalWorkCompleteMetricsContext.dispose();
				if (this.paneTableViewModel.get_visualModel().get_runtimeReady()) {
					this.reset();
				}
			});
			var onZoomCompleted = ss.mkdel(this, function(result) {
				if (result === 'failure') {
					this.reset();
				}
				this.zoomAnimationProtectionGlass = tab.MiscUtil.dispose$1(this.zoomAnimationProtectionGlass);
				if (result === 'success') {
					mapZoomFullyCompleteMetricsContext.dispose();
				}
				this.clearWaitingOnPanZoomServerResponseState();
			});
			var doZoom = ss.mkdel(this, function() {
				var zoomFactor = 1 / scale;
				if (isDoubleClick) {
					tab.PanZoomCommands.zoomDoubleClick(paneResolverPoint, scale > 1, deferAPIforDoubleClick, zoomFactor, onLocalWorkCompleted, onZoomCompleted, this.$sheetid);
				}
				else if (scale > 1) {
					tab.PanZoomCommands.zoomIn(paneResolverPoint, paneResolverPoint, zoomFactor, onLocalWorkCompleted, onZoomCompleted, this.$sheetid);
				}
				else {
					tab.PanZoomCommands.zoomOut(paneResolverPoint, zoomFactor, onLocalWorkCompleted, onZoomCompleted, this.$sheetid);
				}
			});
			if (this.mapIsBrowserRendered()) {
				var zoomDelta = ((scale > 1) ? 1 : -1);
				this.animateZoomOnPointMap(paneInfo, point, zoomDelta, doZoom);
			}
			else {
				var tileCacheUrl = this.paneTableViewModel.get_visualModel().get_tileCacheUrl();
				if (tab.ApplicationModel.get_instance().get_isLocalRenderMode() || tab.ViewSession.canUseTileCacheUrl(tileCacheUrl)) {
					var scaleX = (paneInfo.canDragH ? scale : 1);
					var scaleY = (paneInfo.canDragV ? scale : 1);
					this.animateZoomOnPointImage(paneInfo, paneResolverPoint, scaleX, scaleY);
				}
				doZoom();
			}
		},
		makeDomDragImage: function TiledViewerRegion$MakeDomDragImage() {
			this.domPanZoomRect.createDomAndAppend(this.connectNode);
			this.domDragImage = $('<div></div>');
			this.addHiddenDiv(this.domDragImage, 'tvdrag_image', this.domPanZoomRect.get_dom());
			this.domDragMask = $('<div></div>');
			this.addHiddenDiv(this.domDragMask, 'tvdrag_mask', this.domPanZoomRect.get_dom());
		},
		hideDomDragImage: function TiledViewerRegion$HideDomDragImage() {
			if (this.$regionPart !== 'viz' || !this.$domDragShown) {
				return;
			}
			this.$domDragShown = false;
			tab.Log.get(this).debug('Hiding domDragImage', []);
			this.domDragMask.css('display', 'none');
			this.domDragImage.css('display', 'none');
			this.domPanZoomRect.get_dom().css('display', 'none');
			this.get_shapeSelector().get_dom().css('display', 'none');
			this.domDragImage.html('');
		},
		showDomDragImage: function TiledViewerRegion$ShowDomDragImage(paneInfo) {
			this.$domDragShown = true;
			var scrollPos = (tab.ApplicationModel.get_instance().get_isLocalRenderMode() ? this.scroller.get_scrollPos() : { x: 0, y: 0 });
			var box = { l: paneInfo.x - scrollPos.x + $tab_TiledViewerRegion.canvasBorderPixels, t: paneInfo.y - scrollPos.y + $tab_TiledViewerRegion.canvasBorderPixels, w: paneInfo.w + 1 - 2, h: paneInfo.h + 1 - 2 };
			var container = this.$imagesContainer.clone();
			if (ss.isInstanceOfType(this.regionContent, $tab_PaneTableCanvasView)) {
				var newCanvas = $tab_TiledViewerRegion.getCanvasElement(container);
				var context = tab.CanvasRenderer.getRenderContext(newCanvas, 'transparent');
				ss.cast(this.regionContent, $tab_PaneTableCanvasView).copyContent(context);
			}
			container.removeClass();
			container.addClass('tvdrag_imageContainer');
			this.domDragImage.append(container);
			this.domDragImage.css('display', '');
			var AdditionalOffset = 1;
			tab.DomUtil.setMarginBoxJQ(container, { l: -box.l - AdditionalOffset, t: -box.t - AdditionalOffset, w: tab.DoubleUtil.roundToInt(container.width()) - 2, h: tab.DoubleUtil.roundToInt(container.height()) - 2 });
			tab.DomUtil.setMarginBoxJQ(this.domDragImage, { l: scrollPos.x + AdditionalOffset, t: scrollPos.y + AdditionalOffset, w: box.w - 2, h: box.h - 2 });
			this.domDragMask.css('background-color', this.getPanZoomFillColor());
			this.domDragMask.css('display', '');
			tab.DomUtil.setMarginBoxJQ(this.domPanZoomRect.get_dom(), box);
			this.domPanZoomRect.get_dom().css('display', '');
		},
		addHiddenDiv: function TiledViewerRegion$AddHiddenDiv(newDiv, klass, parentNode) {
			newDiv.addClass(klass);
			newDiv.css('display', 'none');
			parentNode.append(newDiv);
		},
		mapIsBrowserRendered: function TiledViewerRegion$MapIsBrowserRendered() {
			return this.backgroundMap.get_enabled();
		},
		animateAnchorZoomMap: function TiledViewerRegion$AnimateAnchorZoomMap(paneInfo, anchorPoint, newZoomLevel, animate) {
			this.backgroundMap.anchorZoom(newZoomLevel, anchorPoint, animate);
		},
		animateAnchorZoomImage: function TiledViewerRegion$AnimateAnchorZoomImage(paneInfo, anchorPoint, zoomFactor) {
			var transform = $tab_TiledViewerRegion.$createAnchorZoomTransform(paneInfo, anchorPoint, 1 / zoomFactor);
			this.$animateZoomWithCSSTransitions(paneInfo, transform);
		},
		animateZoomOnPointMap: function TiledViewerRegion$AnimateZoomOnPointMap(paneInfo, point, zoomDelta, onComplete) {
			this.setViewportBorderVisibility(true);
			this.backgroundMap.splatOverlayToMapForTransition($tab_TiledViewerRegion.getCanvasElement(this.connectNode));
			this.backgroundMap.zoomOnPoint(point, zoomDelta).done(function(animated) {
				onComplete();
			});
		},
		animateZoomOnPointImage: function TiledViewerRegion$AnimateZoomOnPointImage(paneInfo, point, scaleX, scaleY) {
			var transform = $tab_TiledViewerRegion.$createZoomOnPointTransform(paneInfo, point, scaleX, scaleY);
			this.$animateZoomWithCSSTransitions(paneInfo, transform);
		},
		animateZoomRectMap: function TiledViewerRegion$AnimateZoomRectMap(paneInfo, rect, onComplete) {
			this.setViewportBorderVisibility(true);
			this.backgroundMap.splatOverlayToMapForTransition($tab_TiledViewerRegion.getCanvasElement(this.connectNode));
			this.backgroundMap.zoomRect(rect).done(function(animated) {
				onComplete();
			});
		},
		animateZoomRectImage: function TiledViewerRegion$AnimateZoomRectImage(paneInfo, paneCenter, rect) {
			var zoomPoint = $tab_TiledViewerRegion.getCenterPointFromRectXY(rect);
			var rectWidth = rect.w;
			var rectHeight = rect.h;
			var scaleX = paneInfo.w / rectWidth;
			var scaleY = paneInfo.h / rectHeight;
			if (paneInfo.canDragH && paneInfo.canDragV) {
				var scale = Math.min(scaleX, scaleY);
				var mapData = this.paneTableViewModel.get_mapServerModel();
				if (mapData.get_hasPresModel()) {
					scale = $tab_ZoomComputer.resolveDesiredScale(mapData, scale);
				}
				scaleX = scaleY = scale;
			}
			else if (!paneInfo.canDragV) {
				scaleY = 1;
				zoomPoint.y = paneCenter.y;
			}
			else if (!paneInfo.canDragH) {
				scaleX = 1;
				zoomPoint.x = paneCenter.x;
			}
			else {
				return;
			}
			var transform = $tab_TiledViewerRegion.$createZoomOnPointTransform(paneInfo, zoomPoint, scaleX, scaleY);
			this.$animateZoomWithCSSTransitions(paneInfo, transform);
		},
		$animateZoomWithCSSTransitions: function TiledViewerRegion$AnimateZoomWithCSSTransitions(paneInfo, transform) {
			this.showDomDragImage(paneInfo);
			this.setViewportBorderVisibility(true);
			var domDragImageEl = this.domDragImage.get(0);
			this.get_toolModeViewModel().deferModeChanges();
			this.resetIsWaitingOnTransition = true;
			window.setTimeout(ss.mkdel(this, function() {
				tableau.util.transform(domDragImageEl, transform);
				this.$domDragTransformed = true;
				var MinTimeBeforeReset = $tab_TiledViewerRegion.minZoomAnimationTime;
				window.setTimeout(ss.mkdel(this, function() {
					this.resetIsWaitingOnTransition = false;
					if (!this.get_toolModeViewModel().isDeferringModeChanges) {
						this.reset();
					}
				}), MinTimeBeforeReset);
			}), 50);
		},
		stopScrolling: null,
		startScrolling: null,
		determineScrollDirection: null,
		onRegionContentLoadComplete: function TiledViewerRegion$OnRegionContentLoadComplete(sender, e) {
			if (this.$regionPart === 'viz') {
				if (!this.isScrolling && this.$domDragShown) {
					this.hideDomDragImage();
				}
				if (this.$domDragTransformed) {
					tableau.util.transform(this.domDragImage.get(0), null);
					this.$domDragTransformed = false;
				}
			}
		},
		getPanZoomFillColor: function TiledViewerRegion$GetPanZoomFillColor() {
			var toRet = 'rgb(255,255,255)';
			if (this.$regionPart === 'viz') {
				if (this.paneTableViewModel.get_mapServerModel().get_hasPresModel()) {
					toRet = this.paneTableViewModel.get_mapServerModel().get_mapBGFillColor();
				}
				else if (ss.isValue(this.paneTableViewModel.get_scene().scene)) {
					toRet = this.paneTableViewModel.get_scene().scene.bgColor;
				}
			}
			return toRet;
		},
		$swapBackgroundMap: function TiledViewerRegion$SwapBackgroundMap() {
			if (this.backgroundMap.get_enabled()) {
				this.backgroundMap.destroyMap();
				this.$setBackgroundMapVisibility(true);
			}
		},
		$setBackgroundMapVisibility: function TiledViewerRegion$SetBackgroundMapVisibility(visible) {
			if (this.$regionPart !== 'viz') {
				return;
			}
			this.setViewportBorderVisibility(false);
			if (visible) {
				if (!this.backgroundMap.get_enabled()) {
					this.backgroundMap.createMap(this.backgroundDiv, this.paneTableViewModel.get_mapServerModel());
				}
			}
			else {
				this.backgroundMap.destroyMap();
			}
		},
		$setBackgroundMapSize: function TiledViewerRegion$SetBackgroundMapSize(size) {
			if (this.$regionPart !== 'viz') {
				return;
			}
			this.backgroundMap.resize(size.w, size.h);
		},
		setViewportBorderVisibility: function TiledViewerRegion$SetViewportBorderVisibility(visible) {
			this.paneTableViewModel.set_highlightBorder(visible);
		},
		updateForToolMode: function TiledViewerRegion$UpdateForToolMode(mode) {
			this.updateSelectorShape(mode);
		},
		updateSelectorShape: function TiledViewerRegion$UpdateSelectorShape(mode) {
			if (ss.isValue(this.$shapeSelector)) {
				if (ss.isValue(this.$shapeSelector.get_dom())) {
					this.$shapeSelector.get_dom().remove();
				}
				this.$shapeSelector = null;
			}
			switch (mode) {
				case 'lasso-selection': {
					this.$shapeSelector = new $tab_PolyShapeSelector(this.$regionSize, tab.ApplicationModel.get_instance().get_isLocalRenderMode());
					break;
				}
				case 'radial-selection': {
					var mapServerModel = this.paneTableViewModel.get_mapServerModel();
					this.$shapeSelector = new $tab_CircleShapeSelector(this.$regionSize, mapServerModel.get_radialSelectionDistanceInfoModel());
					break;
				}
				case 'rectangular-selection':
				default: {
					this.$shapeSelector = new $tab_RectShapeSelector();
					break;
				}
			}
			this.$shapeSelector.createDomAndAppend(this.connectNode);
		},
		shouldResetVisualState: function TiledViewerRegion$ShouldResetVisualState() {
			return !tsConfig.is_mobile && this.resetIsWaitingOnTransition;
		},
		setWaitingOnPanZoomServerResponseState: function TiledViewerRegion$SetWaitingOnPanZoomServerResponseState() {
			var visualModel = this.paneTableViewModel.get_visualModel();
			if (visualModel.shouldDoLocalCommand() && visualModel.get_runtimeReady()) {
				this.waitingOnPanZoomServerResponse = 'waitingOnLocal';
			}
			else {
				this.waitingOnPanZoomServerResponse = 'waitingOnServer';
			}
		},
		clearWaitingOnPanZoomServerResponseState: function TiledViewerRegion$ClearWaitingOnPanZoomServerResponseState() {
			this.waitingOnPanZoomServerResponse = 'normal';
		},
		isWaitingOnPanZoomServerResponse: function TiledViewerRegion$IsWaitingOnPanZoomServerResponse() {
			return this.waitingOnPanZoomServerResponse !== 'normal';
		},
		allowMapZoomAtCurrentLevel: function TiledViewerRegion$AllowMapZoomAtCurrentLevel(scale) {
			if (scale < 1) {
				var mapServerModel = this.paneTableViewModel.get_mapServerModel();
				var zoom = (mapServerModel.get_hasPresModel() ? mapServerModel.get_zoom() : 1);
				return tab.MapUtil.allowZoomAtCurrentLevel(zoom, 1 / scale);
			}
			return true;
		},
		handleRightClickHitTestServerWithCallback: function TiledViewerRegion$HandleRightClickHitTestServerWithCallback(p, callback) {
			var $t1 = new tab.HitTestSceneCmd();
			$t1.cmdParams['pt1'] = tab.PointUtil.toPresModel(p);
			$t1.cmdParams['visualIdPresModel'] = this.get_visualId();
			$t1.invoke().done(function(response) {
				var hits = response.$$cmdParams['sceneElements'];
				if (ss.isValue(hits) && hits.length > 0) {
					var sceneElement = new tab.SceneElementModel(hits[0]);
					var hitResult = new $tab_HitTestResult(sceneElement);
					callback(hitResult);
				}
			});
		}
	});
	ss.initClass($tab_TiledViewerRegionMetrics, $asm, {});
	ss.initClass($tab_TiledViewerRegionWebMetrics, $asm, {});
	ss.initClass($tab_TiledWindow, $asm, {
		add_loadComplete: function TiledWindow$add_LoadComplete(value) {
			this.$1$LoadCompleteField = ss.delegateCombine(this.$1$LoadCompleteField, value);
		},
		remove_loadComplete: function TiledWindow$remove_LoadComplete(value) {
			this.$1$LoadCompleteField = ss.delegateRemove(this.$1$LoadCompleteField, value);
		},
		get_actualViewSize: function TiledWindow$get_ActualViewSize() {
			return { w: this.$domNode.clientWidth, h: this.$domNode.clientHeight };
		},
		set_actualViewSize: function TiledWindow$set_ActualViewSize(value) {
		},
		get_effectiveViewSize: function TiledWindow$get_EffectiveViewSize() {
			return this.get_actualViewSize();
		},
		get_scrollPos: function TiledWindow$get_ScrollPos() {
			return { x: this.get_left(), y: this.get_top() };
		},
		set_scrollPos: function TiledWindow$set_ScrollPos(value) {
			this.set_left(value.x);
			this.set_top(value.y);
			this.$loadImages(false);
		},
		get_canScrollX: function TiledWindow$get_CanScrollX() {
			return this.get_docSize().w > this.get_effectiveViewSize().w;
		},
		get_canScrollY: function TiledWindow$get_CanScrollY() {
			return this.get_docSize().h > this.get_effectiveViewSize().h;
		},
		get_docSize: function TiledWindow$get_DocSize() {
			return { w: this.$geometry.w, h: this.$geometry.h };
		},
		get_hasContent: function TiledWindow$get_HasContent() {
			return true;
		},
		get_left: function TiledWindow$get_Left() {
			return this.$leftOffset;
		},
		set_left: function TiledWindow$set_Left(value) {
			this.$leftOffset = value;
			if (this.$shouldScrollDomNode) {
				this.$domNode.scrollLeft = value;
			}
		},
		get_top: function TiledWindow$get_Top() {
			return this.$topOffset;
		},
		set_top: function TiledWindow$set_Top(value) {
			this.$topOffset = value;
			if (this.$shouldScrollDomNode) {
				this.$domNode.scrollTop = value;
			}
		},
		destroy: function TiledWindow$Destroy() {
			this.$downloadQueue.destroy();
			if (this.$tilesNeedingReload > 0) {
				this.$session.decrementWait();
				tab.ImageTileTracker.decrementPendingCount();
				this.$tilesNeedingReload = 0;
			}
			this.$getRequestID = null;
			this.$viewController = null;
		},
		refreshImages: function TiledWindow$RefreshImages(tileCacheUrl) {
			if (this.$geometryHasNoSize()) {
				return;
			}
			if (ss.isNullOrUndefined(tileCacheUrl)) {
				return;
			}
			this.$cacheUrl = tileCacheUrl;
			this.$deferredClearAllImages();
			this.$loadImages(!tab.ProgressiveLoader.get_progressiveLoadEnabled() || !this.$firstTileLoad);
			this.$firstTileLoad = false;
		},
		reset: function TiledWindow$Reset(newGeometry, newTileSize) {
			var oldGeometry = this.$geometry;
			this.$geometry = newGeometry;
			var oldTileSize = this.$tileSize;
			this.$tileSize = newTileSize;
			if (this.$geometryHasNoSize()) {
				return;
			}
			if (this.$noChangeInGeometryOrTileSize(oldGeometry, oldTileSize)) {
				return;
			}
			this.$tilesX = Math.ceil(this.$geometry.w / this.$tileSize.w);
			this.$tilesY = Math.ceil(this.$geometry.h / this.$tileSize.h);
			this.$resizeRegionContentContainer();
			this.$updateScrollPosition();
		},
		$resizeRegionContentContainer: function TiledWindow$ResizeRegionContentContainer() {
			this.$imageContainers.width(this.$geometry.w);
			this.$imageContainers.height(this.$geometry.h);
		},
		$updateScrollPosition: function TiledWindow$UpdateScrollPosition() {
			var maxScrollY = this.$geometry.h - this.$domNode.offsetHeight;
			var maxScrollX = this.$geometry.w - this.$domNode.offsetWidth;
			maxScrollY = Math.max(0, maxScrollY);
			maxScrollX = Math.max(0, maxScrollX);
			this.set_top(Math.min(this.get_top(), maxScrollY));
			this.set_left(Math.min(this.get_left(), maxScrollX));
		},
		$noChangeInGeometryOrTileSize: function TiledWindow$NoChangeInGeometryOrTileSize(oldGeometry, oldTileSize) {
			return tab.RegionRectUtil.sizesAreEqual(oldGeometry, this.$geometry) && tab.SizeUtil.equals(oldTileSize, this.$tileSize);
		},
		$geometryHasNoSize: function TiledWindow$GeometryHasNoSize() {
			if (ss.isNullOrUndefined(this.$geometry)) {
				return true;
			}
			return this.$geometry.w === 0 && this.$geometry.h === 0;
		},
		setXPos: function TiledWindow$SetXPos(xPos) {
			this.set_scrollPos({ x: xPos, y: this.get_scrollPos().y });
		},
		setYPos: function TiledWindow$SetYPos(yPos) {
			this.set_scrollPos({ x: this.get_scrollPos().x, y: yPos });
		},
		$clearElementIfMarked: function TiledWindow$ClearElementIfMarked(element) {
			var obj = $(element);
			if (!!obj.prop('_deferredClear')) {
				obj.prop('_deferredClear', null);
				obj.empty();
			}
		},
		$loadImages: function TiledWindow$LoadImages(showWaitCursor) {
			if (!ss.isValue(showWaitCursor)) {
				showWaitCursor = false;
			}
			if (this.$geometryHasNoSize()) {
				return;
			}
			if (!ss.isValue(this.$cacheUrl)) {
				return;
			}
			this.$downloadQueue.clear();
			if (!ss.isValue(this.$session)) {
				return;
			}
			var left = this.get_left();
			var right = left + this.$domNode.clientWidth;
			var top = this.get_top();
			var bottom = top + this.$domNode.clientHeight;
			var loX = Math.max(Math.floor(left / this.$tileSize.w), 0);
			var hiX = Math.min(Math.ceil(right / this.$tileSize.w), this.$tilesX);
			var loY = Math.max(Math.floor(top / this.$tileSize.h), 0);
			var hiY = Math.min(Math.ceil(bottom / this.$tileSize.h), this.$tilesY);
			var tilesPreviouslyRemaining = this.$tilesNeedingReload;
			this.$tilesNeedingReload = Math.max((hiX - loX) * (hiY - loY), 0);
			if (tilesPreviouslyRemaining <= 0 && this.$tilesNeedingReload > 0) {
				if (showWaitCursor) {
					this.$session.incrementWait(false, true);
				}
				tab.ImageTileTracker.incrementPendingCount();
			}
			var requestID = '';
			var cacheVersion = 0;
			if (ss.isValue(this.$getRequestID)) {
				requestID = this.$getRequestID();
			}
			if (ss.isValue(this.$viewController)) {
				cacheVersion = this.$viewController.get_cacheVersion();
			}
			var requestedImages = false;
			for (var x = loX; x < hiX; x++) {
				var tileWidth = Math.min(this.$tileSize.w, this.$geometry.w - x * this.$tileSize.w);
				for (var y = loY; y < hiY; ++y) {
					var tileHeight = Math.min(this.$tileSize.h, this.$geometry.h - y * this.$tileSize.h);
					var idx = y * this.$tilesX + x;
					var bounds = { l: x * this.$tileSize.w, t: y * this.$tileSize.h, w: tileWidth, h: tileHeight };
					var src = this.$session.formatTileURL(this.$cacheUrl, this.$geometry.r, x, y, '', requestID);
					if (ss.isValue(this.$imageNodes[idx]) && this.$imageNodes[idx].$isSame(src, cacheVersion)) {
						if (showWaitCursor) {
							this.$stopWaitingForImage();
						}
						var imgElt = this.$imageNodes[idx].get_$imageElt();
						var setBounds = imgElt.width !== bounds.w || imgElt.height !== bounds.h;
						if (setBounds) {
							$(imgElt).css(ss.mkdict(['left', bounds.l + 'px', 'top', bounds.t + 'px']));
							tab.RenderUtil.ensureImageEltSize(imgElt, bounds);
						}
					}
					else {
						requestedImages = true;
						this.$imageNodes[idx] = this.$imageNodes[idx] || new $tab_$VersionedImageElement();
						var imgData = new $tab_ImageDownloaderImageData(this.$imageNodes[idx].get_$imageElt(), idx, src, bounds, cacheVersion);
						this.$downloadQueue.addImage(imgData);
					}
				}
			}
			if (!requestedImages) {
				this.$imageContainers.each(ss.mkdel(this, function(index, element) {
					this.$clearElementIfMarked(element);
				}));
			}
		},
		$deferredClearAllImages: function TiledWindow$DeferredClearAllImages() {
			this.$imageNodes = [];
			this.$imageContainers.prop('_deferredClear', true);
		},
		$stopWaitingForImage: function TiledWindow$StopWaitingForImage() {
			if (this.$tilesNeedingReload > 0) {
				this.$tilesNeedingReload--;
				if (this.$tilesNeedingReload === 0) {
					this.$session.decrementWait();
					tab.ImageTileTracker.decrementPendingCount();
				}
			}
		},
		$onImageLoaded: function TiledWindow$OnImageLoaded(sender, e) {
			this.$stopWaitingForImage();
			if (ss.isValue(e.get_image().get_imageNode())) {
				var imgNode = e.get_image().get_imageNode();
				tab.RenderUtil.ensureImageEltSize(imgNode, e.get_image().get_bounds());
				var idx = e.get_image().get_index();
				var cacheVersion = this.$viewController.get_cacheVersion();
				if (!ss.isValue(this.$imageNodes[idx])) {
					tab.Log.get(this).debug('Image of index ' + idx + ' loaded before array initalized.', []);
					return;
				}
				if ((!ss.isValue(this.$imageNodes[idx].get_$imageElt()) || !ss.referenceEquals($(this.$imageNodes[idx].get_$imageElt()).attr('src'), $(imgNode).attr('src'))) && e.get_image().get_version() === cacheVersion) {
					this.$imageNodes[idx].set_$imageElt(ss.cast(imgNode, ss.isValue(imgNode) && (ss.isInstanceOfType(imgNode, Element) && imgNode.tagName === 'IMG')));
					this.$imageNodes[idx].$cacheVersion = cacheVersion;
					var clonedImgNode = imgNode;
					var counter = 0;
					var arrLength = this.$imageContainers.length;
					this.$imageContainers.each(ss.mkdel(this, function(index, element) {
						this.$clearElementIfMarked(element);
						element.appendChild(clonedImgNode);
						if (counter < arrLength - 1) {
							clonedImgNode = clonedImgNode.cloneNode(false);
						}
						counter++;
					}));
				}
			}
		},
		$onImageTimedOut: function TiledWindow$OnImageTimedOut(sender, e) {
			this.$stopWaitingForImage();
		},
		$onQueueComplete: function TiledWindow$OnQueueComplete(sender, e) {
			tab.Log.get(this).debug('LoadComplete', []);
			if (ss.isValue(this.$1$LoadCompleteField)) {
				this.$1$LoadCompleteField(this, ss.EventArgs.Empty);
			}
		}
	}, null, [spiff.IScrollable, tab.IRegionContentProvider]);
	ss.initClass($tab_ToolModeViewModel, $asm, {
		add_toolbarToolModeUpdated: function ToolModeViewModel$add_ToolbarToolModeUpdated(value) {
			this.$2$ToolbarToolModeUpdatedField = ss.delegateCombine(this.$2$ToolbarToolModeUpdatedField, value);
		},
		remove_toolbarToolModeUpdated: function ToolModeViewModel$remove_ToolbarToolModeUpdated(value) {
			this.$2$ToolbarToolModeUpdatedField = ss.delegateRemove(this.$2$ToolbarToolModeUpdatedField, value);
		},
		add_appendModeUpdated: function ToolModeViewModel$add_AppendModeUpdated(value) {
			this.$2$AppendModeUpdatedField = ss.delegateCombine(this.$2$AppendModeUpdatedField, value);
		},
		remove_appendModeUpdated: function ToolModeViewModel$remove_AppendModeUpdated(value) {
			this.$2$AppendModeUpdatedField = ss.delegateRemove(this.$2$AppendModeUpdatedField, value);
		},
		get_isAppendMode: function ToolModeViewModel$get_IsAppendMode() {
			return this.$isAppendMode;
		},
		set_isAppendMode: function ToolModeViewModel$set_IsAppendMode(value) {
			if (this.$isAppendMode !== value) {
				this.$isAppendMode = value;
				this.raiseActionEvent$1(Boolean).call(this, this.$2$AppendModeUpdatedField, this.$isAppendMode);
			}
		},
		get_currentToolbarToolMode: function ToolModeViewModel$get_CurrentToolbarToolMode() {
			return this.$currentToolbarToolMode;
		},
		set_currentToolbarToolMode: function ToolModeViewModel$set_CurrentToolbarToolMode(value) {
			if (tsConfig.allow_filter) {
				this.$currentToolbarToolMode = value;
			}
		},
		get_currentPointerToolMode: function ToolModeViewModel$get_CurrentPointerToolMode() {
			return ((this.currentModifierKeyToolMode === 'no-tools') ? this.get_currentToolbarToolMode() : this.currentModifierKeyToolMode);
		},
		get_isPanToolActive: function ToolModeViewModel$get_IsPanToolActive() {
			return this.get_currentPointerToolMode() === 'pan-map';
		},
		get_isSelectingToolActive: function ToolModeViewModel$get_IsSelectingToolActive() {
			return this.get_currentPointerToolMode() === 'rectangular-selection' || this.get_currentPointerToolMode() === 'lasso-selection' || this.get_currentPointerToolMode() === 'radial-selection';
		},
		get_isZoomToolActive: function ToolModeViewModel$get_IsZoomToolActive() {
			return this.get_currentPointerToolMode() === 'area-zoom' || this.get_currentPointerToolMode() === 'zoom-out';
		},
		initializeToolModesForVizRegion: function ToolModeViewModel$InitializeToolModesForVizRegion(isPanToolShown) {
			this.defaultPointerToolMode = this.$determineDefaultToolMode(isPanToolShown);
			this.$currentToolbarToolMode = this.defaultPointerToolMode;
			this.resetPointerToolMode();
		},
		setPointerToolMode: function ToolModeViewModel$SetPointerToolMode(mode) {
			if (ss.isNullOrUndefined(mode)) {
				mode = this.defaultPointerToolMode;
			}
			this.$setMode(mode);
		},
		$determineDefaultToolMode: function ToolModeViewModel$DetermineDefaultToolMode(isPanToolShown) {
			if (tsConfig.is_mobile) {
				var tool = 'pan-map';
				if (isPanToolShown || tab.GestureModelSettings.get_newModelEnabled()) {
					if (isPanToolShown && tab.GestureModelSettings.get_newModelEnabled()) {
						tool = 'pan-map';
					}
					else {
						tool = this.$lockedPointerToolMode;
						if (tool === 'area-zoom') {
							tool = 'rectangular-selection';
						}
					}
				}
				return tool;
			}
			else {
				return this.$lockedPointerToolMode;
			}
		},
		updateDefaultToolMode: function ToolModeViewModel$UpdateDefaultToolMode(isPanToolShown) {
			this.defaultPointerToolMode = this.$determineDefaultToolMode(isPanToolShown);
		},
		setLockedPointerToolMode: function ToolModeViewModel$SetLockedPointerToolMode(tool) {
			this.$lockedPointerToolMode = tool;
		},
		resetPointerToolMode: function ToolModeViewModel$ResetPointerToolMode() {
			this.setPointerToolMode(this.defaultPointerToolMode);
		},
		$setMode: function ToolModeViewModel$SetMode(mode) {
			if (!tsConfig.is_mobile) {
				if (this.$deferModeChangeIfNeeded(mode)) {
					return;
				}
			}
			this.set_currentToolbarToolMode(mode);
			this.raiseActionEvent$1(Object).call(this, this.$2$ToolbarToolModeUpdatedField, mode);
		},
		deferModeChanges: function ToolModeViewModel$DeferModeChanges() {
			this.isDeferringModeChanges = true;
		},
		handleDeferredModeChangeIfNeeded: function ToolModeViewModel$HandleDeferredModeChangeIfNeeded() {
			if (tsConfig.is_mobile) {
				return;
			}
			this.isDeferringModeChanges = false;
			if (ss.isValue(this.$deferredModeChange)) {
				var newToolMode = ss.unbox(this.$deferredModeChange);
				this.$deferredModeChange = null;
				this.currentModifierKeyToolMode = 'no-tools';
				this.$setMode(newToolMode);
			}
		},
		$deferModeChangeIfNeeded: function ToolModeViewModel$DeferModeChangeIfNeeded(mode) {
			if (this.isDeferringModeChanges) {
				this.$deferredModeChange = mode;
				return true;
			}
			return false;
		}
	}, spiff.BaseViewModel, [ss.IDisposable, tab.IViewModel]);
	ss.initClass($tab_TooltipDisabledMode, $asm, {
		get_multiSelectCompleteBehavior: function TooltipDisabledMode$get_MultiSelectCompleteBehavior() {
			return 'disabled';
		},
		get_currentTooltipMode: function TooltipDisabledMode$get_CurrentTooltipMode() {
			return 'none';
		},
		getSingleSelectBehaviorCallback: function TooltipDisabledMode$GetSingleSelectBehaviorCallback(pageCoords) {
			return function() {
			};
		},
		buildBehaviorsDictionary: function TooltipDisabledMode$BuildBehaviorsDictionary() {
			var disabledTooltipBehavior = new tab.DisabledTooltipBehavior();
			this.tooltipBehaviors['disabled'] = disabledTooltipBehavior;
		},
		suppressHoverIfNecesary: function TooltipDisabledMode$SuppressHoverIfNecesary() {
		},
		shouldForceRemoteTooltipForObject: function TooltipDisabledMode$ShouldForceRemoteTooltipForObject(targetType, interactedObject) {
			var affectedObjects = this.getAffectedObjects(targetType, interactedObject);
			return targetType === 'mark' && ss.isValue(affectedObjects) && affectedObjects.length > 1 || tab.ActionUtils.doesWorksheetContainHoverActionsThatInvalidateVisualPresModelAndRunRemotely(this.get_visualIDPresModel().worksheet);
		}
	}, tab.TooltipBaseMode);
	ss.initClass($tab_TooltipResponsiveMode, $asm, {
		get_ubertipShouldEnforceButtonOrdering: function TooltipResponsiveMode$get_UbertipShouldEnforceButtonOrdering() {
			return true;
		},
		get_currentTooltipMode: function TooltipResponsiveMode$get_CurrentTooltipMode() {
			return 'smooth';
		},
		dispose: function TooltipResponsiveMode$Dispose() {
			var smoothTooltipBehavior = ss.cast(this.tooltipBehaviors['smooth'], tab.SmoothTooltipBehavior);
			smoothTooltipBehavior.remove_onMouseStop(ss.mkdel(this, this.$onMouseStop));
			this.get_tooltip().remove_prePosition(ss.mkdel(this, this.prepareForPositioning));
			this.get_tooltip().remove_positionCalculated(ss.mkdel(this, this.handleUbertipButtons));
			this.get_tooltip().remove_showed(ss.mkdel(this, this.$onTooltipShowed));
			this.get_tooltip().remove_closed(ss.mkdel(this, this.$onTooltipClosed));
			this.$detachMouseHandler();
			tab.TooltipBaseMode.prototype.dispose.call(this);
		},
		buildBehaviorsDictionary: function TooltipResponsiveMode$BuildBehaviorsDictionary() {
			var legacyTooltipBehavior = tab.ObjectRegistry.newLegacyTooltipBehavior(tab.ITooltipBehavior).call(null, tab.ITooltipBehavior, this.get_tooltip());
			var smoothTooltipBehavior = new tab.SmoothTooltipBehavior(this.get_tooltip());
			this.tooltipBehaviors['sticky'] = legacyTooltipBehavior;
			this.tooltipBehaviors['smooth'] = smoothTooltipBehavior;
		},
		getSingleSelectBehaviorCallback: function TooltipResponsiveMode$GetSingleSelectBehaviorCallback(pageCoords) {
			return ss.mkdel(this, function(ubertipModel) {
				this.$singleSelectBehavior(pageCoords, ubertipModel);
			});
		},
		$singleSelectBehavior: function TooltipResponsiveMode$SingleSelectBehavior(pageCoords, ubertipModel) {
			this.get_currentBehavior().singleSelectComplete(pageCoords);
			if (this.get_tooltip().get_isShown()) {
				this.triggerUbertipButtonUpdate();
			}
			if (!this.isUbertipObjectSelected(ubertipModel)) {
				this.switchTooltipMode('smooth');
				this.$doShowHide();
				if (tab.GestureModelSettings.get_newModelEnabled() && tsConfig.is_mobile && this.get_tooltip().get_isShown()) {
					this.get_tooltip().close();
				}
			}
		},
		shouldShowCommandButtons: function TooltipResponsiveMode$ShouldShowCommandButtons() {
			var show = tab.TooltipBaseMode.prototype.shouldShowCommandButtons.call(this);
			var ubertipModel = this.get_ubertip().get_model();
			if (!show || ss.isNullOrUndefined(ubertipModel)) {
				return show;
			}
			var isMultiSelect = ubertipModel.tupleId === tab.VizDataUtils.invalidTupleId;
			if (!isMultiSelect) {
				show = this.isUbertipObjectSelected(ubertipModel);
			}
			return show;
		},
		getSingleSelectBehavior: function TooltipResponsiveMode$GetSingleSelectBehavior(targetType) {
			return 'sticky';
		},
		getHoverBehavior: function TooltipResponsiveMode$GetHoverBehavior(targetType) {
			var behavior = this.get_defaultBehaviorType();
			if (tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				if (targetType === 'header' || targetType === 'visualparts') {
					behavior = 'sticky';
				}
				else if (targetType === 'mark') {
					behavior = 'smooth';
				}
				else {
					tab.Log.get(this).debug('unsupported target type: {0}', [targetType.toString()]);
				}
			}
			else if (targetType === 'header') {
				behavior = 'sticky';
			}
			else {
				behavior = 'smooth';
			}
			return behavior;
		},
		onPanOrDragStart: function TooltipResponsiveMode$OnPanOrDragStart(regionDimension) {
			this.$detachMouseHandler();
			tab.TooltipBaseMode.prototype.onPanOrDragStart.call(this, regionDimension);
		},
		onDragEnd: function TooltipResponsiveMode$OnDragEnd(regionDimension) {
			this.get_tooltip().close();
			this.$attachMouseHandler();
			tab.TooltipBaseMode.prototype.onDragEnd.call(this, regionDimension);
		},
		onBehaviorSwitch: function TooltipResponsiveMode$OnBehaviorSwitch() {
			if (this.get_currentBehaviorType() === 'smooth') {
				this.$attachMouseHandler();
				this.get_tooltip().allowMouseEventPassthrough(true);
			}
			else {
				this.$detachMouseHandler();
				this.get_tooltip().allowMouseEventPassthrough(false);
			}
		},
		shouldForceRemoteTooltipForObject: function TooltipResponsiveMode$ShouldForceRemoteTooltipForObject(targetType, interactedObject) {
			var affectedObjects = this.getAffectedObjects(targetType, interactedObject);
			return targetType === 'mark' && ss.isValue(affectedObjects) && affectedObjects.length > 1 || tab.ActionUtils.doesWorksheetContainHoverActionsThatInvalidateVisualPresModelAndRunRemotely(this.get_visualIDPresModel().worksheet);
		},
		$onTooltipShowed: function TooltipResponsiveMode$OnTooltipShowed() {
			this.handleUbertipButtons();
			this.get_tooltip().allowMouseEventPassthrough(this.get_currentBehaviorType() === 'smooth');
		},
		$onTooltipClosed: function TooltipResponsiveMode$OnTooltipClosed() {
			this.get_ubertip().hideMenuActionsAndCommandButtons(true);
			this.get_tooltip().allowMouseEventPassthrough(false);
		},
		$onMouseMove: function TooltipResponsiveMode$OnMouseMove(e) {
			if (this.readyForHover && this.get_currentBehaviorType() === 'smooth' && this.get_isTooltipShown()) {
				ss.cast(this.get_currentBehavior(), tab.SmoothTooltipBehavior).onMouseMove(e);
			}
		},
		$onMouseOut: function TooltipResponsiveMode$OnMouseOut(e) {
			this.get_tooltip().allowMouseEventPassthrough(false);
			if (this.get_currentBehaviorType() === 'sticky' && this.get_tooltip().isInSafeZone({ x: e.pageX, y: e.pageY }, false)) {
				return;
			}
			if (this.get_isTooltipShown()) {
				this.get_tooltip().close();
			}
		},
		$onMouseStop: function TooltipResponsiveMode$OnMouseStop(position) {
			if (ss.isNullOrUndefined(this.get_ubertip().get_model())) {
				return;
			}
			if (!this.$changeBehaviorOnMouseStop) {
				return;
			}
			var switched = false;
			var isSelected = this.isUbertipObjectSelected(this.get_ubertip().get_model());
			if (isSelected) {
				switched = this.switchTooltipMode('sticky');
			}
			this.$doShowHide();
			if (switched && this.get_tooltip().get_isShown()) {
				this.triggerUbertipButtonUpdate();
			}
		},
		$doShowHide: function TooltipResponsiveMode$DoShowHide() {
			if (!this.get_tooltip().get_isShown() && ss.isValue(this.get_tooltip().get_lastLocation()) && this.get_currentBehaviorType() === 'sticky' && tab.TooltipBaseMode.isUbertipHtmlEmpty(this.get_ubertip().get_model()) && this.get_ubertip().hasActionsOrSummaryOrCommands()) {
				this.get_tooltip().show(this.get_tooltip().get_body().children()[0], this.get_tooltip().get_lastLocation());
			}
			else if (this.get_tooltip().get_isShown() && this.get_currentBehaviorType() === 'smooth' && tab.TooltipBaseMode.isUbertipHtmlEmpty(this.get_ubertip().get_model())) {
				this.get_tooltip().close();
			}
		},
		$attachMouseHandler: function TooltipResponsiveMode$AttachMouseHandler() {
			if (this.$mouseHandlerAttached) {
				return;
			}
			if (tsConfig.is_mobile) {
				this.$tooltipRegion.on(this.$uniqueTouchMoveEventType, ss.mkdel(this, this.$onMouseMove));
			}
			else {
				this.$tooltipRegion.on(this.$uniqueMouseMoveEventType, ss.mkdel(this, this.$onMouseMove));
			}
			this.$tooltipRegion.on(this.$uniqueMouseOutEventType, ss.mkdel(this, this.$onMouseOut));
			tab.Log.get(this).debug('Unique mouse event type bound: ' + this.$uniqueMouseMoveEventType, []);
			tab.Log.get(this).debug('Unique mouse event type bound: ' + this.$uniqueMouseOutEventType, []);
			this.$mouseHandlerAttached = true;
		},
		$detachMouseHandler: function TooltipResponsiveMode$DetachMouseHandler() {
			if (!this.$mouseHandlerAttached) {
				return;
			}
			tab.Log.get(this).debug('Unique mouse event type unbound: ' + this.$uniqueMouseMoveEventType, []);
			tab.Log.get(this).debug('Unique mouse event type unbound: ' + this.$uniqueMouseOutEventType, []);
			if (tsConfig.is_mobile) {
				this.$tooltipRegion.off(this.$uniqueTouchMoveEventType);
			}
			else {
				this.$tooltipRegion.off(this.$uniqueMouseMoveEventType);
			}
			this.$tooltipRegion.off(this.$uniqueMouseOutEventType);
			this.$mouseHandlerAttached = false;
		}
	}, tab.TooltipBaseMode);
	ss.initClass($tab_TooltipOfflineResponsiveMode, $asm, {
		shouldShowCommandButtons: function TooltipOfflineResponsiveMode$ShouldShowCommandButtons() {
			return false;
		},
		needRemoteCommand: function TooltipOfflineResponsiveMode$NeedRemoteCommand(regionPart, targetType, activationMethod, interactedObjectId, paneDescriptorKey) {
			return 0;
		},
		shouldAddCommandButtonsAndActions: function TooltipOfflineResponsiveMode$ShouldAddCommandButtonsAndActions() {
			return false;
		}
	}, $tab_TooltipResponsiveMode);
	ss.initClass($tab_TrendLineHitTestLink, $asm, {
		get_hitTestStructures: function TrendLineHitTestLink$get_HitTestStructures() {
			if (ss.isValue(this.$hitTestStructureList)) {
				return this.$hitTestStructureList;
			}
			this.$hitTestStructureList = [];
			var trendLineVLPMs = this.paneTableVM.get_trendLineVisualLists();
			if (!ss.isValue(trendLineVLPMs)) {
				return this.$hitTestStructureList;
			}
			for (var $t1 = 0; $t1 < trendLineVLPMs.length; $t1++) {
				var trendLineVLPM = trendLineVLPMs[$t1];
				this.$buildTrendLineHitTestStructure(trendLineVLPM);
			}
			return this.$hitTestStructureList;
		},
		$buildTrendLineHitTestStructure: function TrendLineHitTestLink$BuildTrendLineHitTestStructure(trendLineVLPM) {
			var trendLines = trendLineVLPM.drawItems;
			var lineWidth = 1;
			for (var $t1 = 0; $t1 < trendLines.length; $t1++) {
				var trendLine = trendLines[$t1];
				if (trendLine.type === 'draw-group') {
					var trendLineGroup = trendLine;
					for (var $t2 = 0; $t2 < trendLineGroup.drawItems.length; $t2++) {
						var part = trendLineGroup.drawItems[$t2];
						switch (part.type) {
							case 'draw-pen': {
								var drawPen = part;
								if (ss.isValue(drawPen.strokeWidth)) {
									lineWidth = drawPen.strokeWidth;
								}
								break;
							}
							case 'draw-path': {
								var drawPath = part;
								var root = $tab_HitTestStructureBuilder.buildTrendLineHitTestStructure(drawPath, lineWidth, trendLineGroup.objectId);
								this.$hitTestStructureList.push(root);
								break;
							}
							default: {
								break;
							}
						}
					}
				}
			}
		},
		hitTest: function TrendLineHitTestLink$HitTest(p, isSingleSelect) {
			return $tab_TrendLineHitTestLink.hitTestTrendLines(this.get_hitTestStructures(), { x: p.x, y: p.y, w: 1, h: 1 }, isSingleSelect);
		},
		clearCache: function TrendLineHitTestLink$ClearCache() {
			this.$hitTestStructureList = null;
		}
	}, $tab_HitTestLink, [ss.IDisposable, $tab_IHitTestLink]);
	ss.initClass($tab_UserPaneInfo, $asm, {
		$computeUserPaneRect: function UserPaneInfo$ComputeUserPaneRect(wholePane, col, row) {
			var rect = { x: 0, y: 0, w: wholePane.w, h: wholePane.h };
			if (col >= 0 && this.$sceneUserPaneInfo.$hasPanesX) {
				var left = this.$sceneUserPaneInfo.$pixelsX[col];
				var nextLeft = this.$sceneUserPaneInfo.$pixelsX[col + 1];
				rect.x += Math.round(left);
				rect.w = Math.round(nextLeft - left);
			}
			if (row >= 0 && this.$sceneUserPaneInfo.$hasPanesY) {
				var top = this.$sceneUserPaneInfo.$pixelsY[row];
				var nextTop = this.$sceneUserPaneInfo.$pixelsY[row + 1];
				rect.y += Math.round(top);
				rect.h = Math.round(nextTop - top);
			}
			return rect;
		},
		$getUserPaneRectByIndex: function UserPaneInfo$GetUserPaneRectByIndex(userPaneIndex) {
			ss.Debug.assert(ss.isValue(this.$userPaneRectangles[userPaneIndex]), 'Invalid user pane index or broken UserPaneInfo data');
			return this.$userPaneRectangles[userPaneIndex];
		},
		$getUserPaneRectByMark: function UserPaneInfo$GetUserPaneRectByMark(markIndex) {
			ss.Debug.assert(ss.isValue(this.$markToUserPane[markIndex]), 'Invalid mark index or broken UserPaneInfo data');
			var userPaneIndex = this.$markToUserPane[markIndex];
			return this.$userPaneRectangles[userPaneIndex];
		},
		$getUserPaneIndexByMark: function UserPaneInfo$GetUserPaneIndexByMark(markIndex) {
			ss.Debug.assert(ss.isValue(this.$markToUserPane[markIndex]), 'Invalid mark index or broken UserPaneInfo data');
			return this.$markToUserPane[markIndex];
		},
		$getUserPaneMarkCount: function UserPaneInfo$GetUserPaneMarkCount(userPaneIndex) {
			ss.Debug.assert(userPaneIndex < this.$userPaneCount, 'Invalid user pane index');
			return this.$markOffsets[userPaneIndex + 1] - this.$markOffsets[userPaneIndex];
		},
		$getUserPaneMarkRange: function UserPaneInfo$GetUserPaneMarkRange(userPaneIndex) {
			ss.Debug.assert(userPaneIndex < this.$userPaneCount, 'Invalid user pane index');
			return { firstMark: this.$markOffsets[userPaneIndex], lastMark: this.$markOffsets[userPaneIndex + 1] - 1 };
		},
		$computeData: function UserPaneInfo$ComputeData(paneDrawInfo) {
			var iterCols = paneDrawInfo.c.get('user_pane_col');
			var iterRows = paneDrawInfo.c.get('user_pane_row');
			var wholePane = paneDrawInfo.paneRect;
			var markCount = paneDrawInfo.markCount;
			var userPaneIndex = 0;
			var lastCol = -1;
			var lastRow = -1;
			var nullRows = ss.isNullOrUndefined(iterRows);
			var nullCols = ss.isNullOrUndefined(iterCols);
			if (!nullRows || !nullCols) {
				for (var i = 0; i < markCount; ++i) {
					var col = (nullCols ? -1 : iterCols.v[(iterCols.c ? 0 : i)]);
					var row = (nullRows ? -1 : iterRows.v[(iterRows.c ? 0 : i)]);
					if (col !== lastCol || row !== lastRow) {
						this.$addUserPane(i, userPaneIndex, col, row, wholePane);
						lastCol = col;
						lastRow = row;
						userPaneIndex += 1;
					}
				}
			}
			this.$markOffsets[userPaneIndex] = markCount;
			this.$addPreviousPaneMarks(userPaneIndex);
			return userPaneIndex;
		},
		$addPreviousPaneMarks: function UserPaneInfo$AddPreviousPaneMarks(nextIndex) {
			if (nextIndex === 0) {
				return;
			}
			var lastIndex = nextIndex - 1;
			var firstMark = this.$markOffsets[lastIndex];
			var nextMark = this.$markOffsets[nextIndex];
			for (var i = firstMark; i < nextMark; ++i) {
				this.$markToUserPane[i] = lastIndex;
			}
		},
		$addUserPane: function UserPaneInfo$AddUserPane(markIndex, userPaneIndex, col, row, wholePane) {
			if (ss.isValue(this.$columns)) {
				this.$columns[userPaneIndex] = col;
			}
			if (ss.isValue(this.$rows)) {
				this.$rows[userPaneIndex] = row;
			}
			this.$userPaneRectangles[userPaneIndex] = this.$computeUserPaneRect(wholePane, col, row);
			this.$markOffsets[userPaneIndex] = markIndex;
			this.$addPreviousPaneMarks(userPaneIndex);
		},
		$visitMarksPerUserPane: function UserPaneInfo$VisitMarksPerUserPane(visitor) {
			for (var i = 0; i < this.$userPaneCount; ++i) {
				var userPaneRect = this.$getUserPaneRectByIndex(i);
				var markRange = this.$getUserPaneMarkRange(i);
				var firstMark = markRange.firstMark;
				var lastMark = markRange.lastMark;
				for (var markIndex = firstMark; markIndex <= lastMark; ++markIndex) {
					visitor(markIndex, userPaneRect);
				}
			}
		},
		$visitMarksPerUserPane$1: function UserPaneInfo$VisitMarksPerUserPane(marks, visitor) {
			var lastUserPaneIndex = -1;
			var userPaneRect = null;
			for (var $t1 = 0; $t1 < marks.length; $t1++) {
				var markIndex = marks[$t1];
				var userPaneIndex = this.$markToUserPane[markIndex];
				ss.Debug.assert(ss.isValue(userPaneIndex), 'Invalid mark index or broken UserPaneInfo data');
				if (userPaneIndex !== lastUserPaneIndex) {
					lastUserPaneIndex = userPaneIndex;
					userPaneRect = this.$getUserPaneRectByIndex(userPaneIndex);
				}
				visitor(markIndex, userPaneRect);
			}
		}
	});
	ss.initClass($tab_VisualListViewModel, $asm, {
		get_visualList: function VisualListViewModel$get_VisualList() {
			return this.$model;
		},
		get_groupItemNodes: function VisualListViewModel$get_GroupItemNodes() {
			return this.$model.get_groupItemNodes();
		},
		get_visualListPM: function VisualListViewModel$get_VisualListPM() {
			return this.$model.get_visualListPresModel();
		},
		get_defaultBackgroundColor: function VisualListViewModel$get_DefaultBackgroundColor() {
			return this.$defaultBackgroundColor;
		},
		set_defaultBackgroundColor: function VisualListViewModel$set_DefaultBackgroundColor(value) {
			this.$defaultBackgroundColor = value;
		},
		get_hoveredNodeOrAxis: function VisualListViewModel$get_HoveredNodeOrAxis() {
			return this.$currHoveredNodeOrAxis;
		},
		set_hoveredNodeOrAxis: function VisualListViewModel$set_HoveredNodeOrAxis(value) {
			if (!ss.referenceEquals(this.$currHoveredNodeOrAxis, value)) {
				this.$prevHoveredNodeOrAxis = this.$currHoveredNodeOrAxis;
				this.$currHoveredNodeOrAxis = value;
				this.notifyPropertyChanged($tab_VisualListViewModel.propertyHoverNode);
			}
		},
		dirtyRect: function VisualListViewModel$DirtyRect(offset) {
			var unionRect = { x: 0, y: 0, w: 0, h: 0 };
			var nodes = [this.$prevHoveredNodeOrAxis, this.$currHoveredNodeOrAxis];
			for (var $t1 = 0; $t1 < nodes.length; $t1++) {
				var node = nodes[$t1];
				if (ss.isValue(node)) {
					var rect = { x: node.extentsX, y: node.extentsY, w: node.extentsWidth, h: node.extentsHeight };
					unionRect = tab.RectXYUtil.union(unionRect, rect);
				}
			}
			return tab.RectXYUtil.offsetRect(unionRect, offset);
		},
		isNodeOrAxisHovered: function VisualListViewModel$IsNodeOrAxisHovered(node) {
			return ss.referenceEquals(node, this.$currHoveredNodeOrAxis);
		},
		isSelected: function VisualListViewModel$IsSelected(node) {
			return ss.isValue(this.$selectionModel) && this.$selectionModel.isNodeSelected(node);
		},
		isBrushed: function VisualListViewModel$IsBrushed(node) {
			return ss.isValue(this.$brushingModel) && this.$brushingModel.isNodeSelected(node);
		},
		selectNode: function VisualListViewModel$SelectNode(coords, selectedNode, action, tooltipCallback) {
			tab.SelectionClientCommands.selectNode(this.$regionPart, coords, action, this.$model, selectedNode, this.$visualId, tooltipCallback);
		},
		hitTestNodes: function VisualListViewModel$HitTestNodes(coords) {
			var hitNode = _.find(this.get_groupItemNodes(), function(presModel) {
				var x = presModel.extentsX || 0;
				var y = presModel.extentsY || 0;
				var extents = { x: x, y: y, w: presModel.extentsWidth, h: presModel.extentsHeight };
				return tab.RectXYUtil.inRect(extents, coords);
			});
			return hitNode;
		},
		handleModelChange: function VisualListViewModel$HandleModelChange() {
			this.notifyPropertyChanged('visualList');
		},
		$handleNewSelectionOrNewBrushing: function VisualListViewModel$HandleNewSelectionOrNewBrushing() {
			this.notifyPropertyChanged('selection');
		},
		dispose: function VisualListViewModel$Dispose() {
			this.$model.remove_newVisualList(ss.mkdel(this, this.handleModelChange));
			if (ss.isValue(this.$selectionModel)) {
				this.$selectionModel.remove_newSelection(ss.mkdel(this, this.$handleNewSelectionOrNewBrushing));
			}
			if (ss.isValue(this.$brushingModel)) {
				this.$brushingModel.remove_newSelection(ss.mkdel(this, this.$handleNewSelectionOrNewBrushing));
			}
			spiff.BaseViewModel.prototype.dispose.call(this);
		}
	}, spiff.BaseViewModel, [ss.IDisposable, tab.IViewModel]);
	ss.initClass($tab_VisualObjectBoundsComputerAndHitTester, $asm, {
		computeBoundsOfSelectedMarks: function VisualObjectBoundsComputerAndHitTester$ComputeBoundsOfSelectedMarks(visualModel, scene) {
			var tupleSelection = visualModel.get_selectionsModel().tupleSelection;
			var selectionBounds = { x: 0, y: 0, w: 0, h: 0 };
			var $t1 = tupleSelection.get_ids();
			for (var $t2 = 0; $t2 < $t1.length; $t2++) {
				var tupleId = $t1[$t2];
				var markBounds = scene.getMarkBoundingBox(tupleId);
				selectionBounds = tab.RectXYUtil.union(selectionBounds, markBounds);
			}
			return selectionBounds;
		},
		computeBoundsOfSelectedNodes: function VisualObjectBoundsComputerAndHitTester$ComputeBoundsOfSelectedNodes(visualModel, vlvm) {
			var nodeSelection = visualModel.get_selectionsModel().nodeSelection;
			var selectionBounds = { x: 0, y: 0, w: 0, h: 0 };
			var visualListViewModel = vlvm;
			if (ss.isNullOrUndefined(visualListViewModel)) {
				return selectionBounds;
			}
			var $t1 = visualListViewModel.get_groupItemNodes();
			for (var $t2 = 0; $t2 < $t1.length; $t2++) {
				var model = $t1[$t2];
				if (!nodeSelection.isNodeSelected(model)) {
					continue;
				}
				var x = model.extentsX || 0;
				var y = model.extentsY || 0;
				var nodeBounds = { x: x, y: y, w: model.extentsWidth, h: model.extentsHeight };
				selectionBounds = tab.RectXYUtil.union(selectionBounds, nodeBounds);
			}
			return selectionBounds;
		},
		computeBoundsOfSelectedRefLines: function VisualObjectBoundsComputerAndHitTester$ComputeBoundsOfSelectedRefLines(visualModel, refLineVisualLists) {
			var refLineSelection = visualModel.get_selectionsModel().refLineSelection;
			var selectionBounds = { x: 0, y: 0, w: 0, h: 0 };
			if (refLineSelection.isEmpty) {
				return selectionBounds;
			}
			for (var $t1 = 0; $t1 < refLineVisualLists.length; $t1++) {
				var refLine = refLineVisualLists[$t1];
				for (var $t2 = 0; $t2 < refLine.drawItems.length; $t2++) {
					var refLineDrawItem = refLine.drawItems[$t2];
					var drawGroup = refLineDrawItem;
					if (!refLineSelection.isObjectSelected(drawGroup.objectId)) {
						continue;
					}
					for (var $t3 = 0; $t3 < drawGroup.drawItems.length; $t3++) {
						var drawItem = drawGroup.drawItems[$t3];
						if (drawItem.type !== 'draw-polyline' && drawItem.type !== 'draw-fill-rect') {
							continue;
						}
						var drawPoints = drawItem;
						if (drawPoints.points.length < 4) {
							continue;
						}
						var pt1 = { x: drawPoints.points[0], y: drawPoints.points[1] };
						var pt2 = { x: drawPoints.points[2], y: drawPoints.points[3] };
						var refLineRect = tab.RectXYUtil.rectXYFromCorners$1(pt1, pt2);
						refLineRect = tab.RectXYUtil.nonemptyify(refLineRect);
						selectionBounds = tab.RectXYUtil.union(selectionBounds, refLineRect);
					}
				}
			}
			return selectionBounds;
		},
		computeBoundsOfSelectedTrendLines: function VisualObjectBoundsComputerAndHitTester$ComputeBoundsOfSelectedTrendLines(visualModel, paneTableViewModel) {
			var trendLineSelection = visualModel.get_selectionsModel().trendLineSelection;
			var selectionBounds = { x: 0, y: 0, w: 0, h: 0 };
			if (trendLineSelection.isEmpty) {
				return selectionBounds;
			}
			var hitTestOrphan = new $tab_TrendLineHitTestLink(paneTableViewModel);
			var lineHitTestStructures = hitTestOrphan.get_hitTestStructures();
			var stack = new Array();
			for (var $t1 = 0; $t1 < lineHitTestStructures.length; $t1++) {
				var node = lineHitTestStructures[$t1];
				stack.push(node);
			}
			while (stack.length !== 0) {
				var node1 = stack.pop();
				if (node1.get_nodeType() === 4 || node1.get_nodeType() === 0) {
					var $t2 = node1.get_children();
					for (var $t3 = 0; $t3 < $t2.length; $t3++) {
						var child = $t2[$t3];
						stack.push(child);
					}
				}
				else if (node1.get_nodeType() === 5) {
					if (trendLineSelection.isObjectSelected(node1.get_objectId())) {
						selectionBounds = tab.RectXYUtil.union(selectionBounds, node1.get_boundingBox());
					}
				}
			}
			return selectionBounds;
		}
	});
	ss.initClass($tab_VisualPartsHitTest, $asm, {});
	ss.initEnum($tab_VisualPartTargetState, $asm, { normal: 'normal', hover: 'hover', press: 'press', highlighted: 'highlighted', selected: 'selected', fogged: 'fogged' }, true);
	ss.initClass($tab_VizContextMenuItemsHandler, $asm, {
		buildMenuItems: function VizContextMenuItemsHandler$BuildMenuItems() {
			var menuItems = [];
			if (tab.FeatureFlags.isEnabled('RichTextCreateBlankPointAndMarkAnnotation')) {
				menuItems.push({ value: $tab_VizContextMenuItemsHandler.createMarkAnnotationMenuItem, displayValue: tab.Strings.CreateMarkAnnotationFromVizContextMenu, disabled: this.$type !== 7 });
				menuItems.push({ value: $tab_VizContextMenuItemsHandler.createPointAnnotationMenuItem, displayValue: tab.Strings.CreatePointAnnotationFromVizContextMenu, disabled: false });
			}
			if (tab.FeatureFlags.isEnabled('RichTextCreateBlankAreaAnnotation')) {
				menuItems.push({ value: $tab_VizContextMenuItemsHandler.createAreaAnnotationMenuItem, displayValue: tab.Strings.CreateAreaAnnotationFromVizContextMenu, disabled: false });
			}
			return menuItems;
		},
		handleItemClicked: function VizContextMenuItemsHandler$HandleItemClicked(itemName) {
			switch (itemName) {
				case 'Annotate Mark': {
					tab.AnnotationClientCommands.createMarkAnnotation(this.$location, [this.$id], this.$visualId);
					$tab_AnnotationTelemetryUtil.reportCreatedAnnotationTelemetry($tab_AnnotationTelemetryUtil.annotationMarkType);
					break;
				}
				case 'Annotate Area': {
					tab.AnnotationClientCommands.createAreaAnnotation(this.$location, this.$visualId);
					$tab_AnnotationTelemetryUtil.reportCreatedAnnotationTelemetry($tab_AnnotationTelemetryUtil.annotationAreaType);
					break;
				}
				case 'Annotate Point': {
					tab.AnnotationClientCommands.createPointAnnotation(this.$location, this.$visualId);
					$tab_AnnotationTelemetryUtil.reportCreatedAnnotationTelemetry($tab_AnnotationTelemetryUtil.annotationPointType);
					break;
				}
				default: {
					throw new ss.Exception('Unknown menu option ' + itemName);
				}
			}
		}
	}, null, [$tab_IVizContextMenuItemsHandler]);
	$tab_VizContextMenuItemsHandler.$ctor1.prototype = $tab_VizContextMenuItemsHandler.prototype;
	ss.initClass($tab_VizContextMenuViewModel, $asm, {
		get_scrollOffset: function VizContextMenuViewModel$get_ScrollOffset() {
			if (ss.isValue(tab.ApplicationModel.get_instance().pm) && tab.ApplicationModel.get_instance().get_isLocalRenderMode()) {
				return this.$scrollOffset;
			}
			return { x: 0, y: 0 };
		},
		set_scrollOffset: function VizContextMenuViewModel$set_ScrollOffset(value) {
			this.$scrollOffset.x = value.x;
			this.$scrollOffset.y = value.y;
		},
		setAnchorEl: function VizContextMenuViewModel$SetAnchorEl(element) {
			this.vizOverlayDiv = element;
			this.incrementProps();
		},
		show: function VizContextMenuViewModel$Show(coords, handlers) {
			var offsetCoords = tab.PointUtil.subtract(coords, this.get_scrollOffset());
			this.$contextMenuHandlers = handlers;
			this.location = offsetCoords;
			this.isHidden = false;
			this.incrementProps();
		},
		createInitialProps: function VizContextMenuViewModel$CreateInitialProps() {
			return { hide: ss.mkdel(this, this.$hide), handleItemClicked: ss.mkdel(this, this.handleItemClicked) };
		},
		createUpdatedProps: function VizContextMenuViewModel$CreateUpdatedProps() {
			return { vizOverlayDiv: this.vizOverlayDiv, location: this.location, isHidden: this.isHidden, hide: ss.mkdel(this, this.$hide), handleItemClicked: ss.mkdel(this, this.handleItemClicked), menuOptions: this.$buildMenuItemInfos() };
		},
		$buildMenuItemInfos: function VizContextMenuViewModel$BuildMenuItemInfos() {
			if (ss.isNullOrUndefined(this.$contextMenuHandlers)) {
				return [];
			}
			this.$menuItemClickHandlers = {};
			var items = [];
			for (var $t1 = 0; $t1 < this.$contextMenuHandlers.length; $t1++) {
				var handler = this.$contextMenuHandlers[$t1];
				var handlerItems = handler.buildMenuItems();
				items = items.concat.apply(items, handlerItems);
				for (var $t2 = 0; $t2 < handlerItems.length; $t2++) {
					var menuItem = handlerItems[$t2];
					this.$menuItemClickHandlers[menuItem.value] = handler;
				}
			}
			return items;
		},
		$hide: function VizContextMenuViewModel$Hide() {
			this.$contextMenuHandlers = null;
			this.isHidden = true;
			this.$menuItemClickHandlers = null;
			this.incrementProps();
		},
		handleItemClicked: function VizContextMenuViewModel$HandleItemClicked(itemName) {
			if (ss.keyExists(this.$menuItemClickHandlers, itemName)) {
				this.$menuItemClickHandlers[itemName].handleItemClicked(itemName);
			}
			this.isHidden = true;
			this.incrementProps();
		}
	}, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [ss.IDisposable, tab.IViewModel, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
	ss.initClass($tab_VizHitInfo, $asm, {
		get_instanceId: function VizHitInfo$get_InstanceId() {
			return this.$1$InstanceIdField;
		},
		set_instanceId: function VizHitInfo$set_InstanceId(value) {
			this.$1$InstanceIdField = value;
		},
		get_region: function VizHitInfo$get_Region() {
			return this.$1$RegionField;
		},
		set_region: function VizHitInfo$set_Region(value) {
			this.$1$RegionField = value;
		},
		get_visualId: function VizHitInfo$get_VisualId() {
			return this.get_region().get_visualId();
		},
		get_sheetId: function VizHitInfo$get_SheetId() {
			return this.get_region().get_sheetid();
		},
		get_regionPart: function VizHitInfo$get_RegionPart() {
			return this.get_region().get_regionPart();
		},
		get_paneId: function VizHitInfo$get_PaneId() {
			return this.$1$PaneIdField;
		},
		set_paneId: function VizHitInfo$set_PaneId(value) {
			this.$1$PaneIdField = value;
		},
		get_paneColumnIndex: function VizHitInfo$get_PaneColumnIndex() {
			return this.$1$PaneColumnIndexField;
		},
		set_paneColumnIndex: function VizHitInfo$set_PaneColumnIndex(value) {
			this.$1$PaneColumnIndexField = value;
		},
		get_paneRowIndex: function VizHitInfo$get_PaneRowIndex() {
			return this.$1$PaneRowIndexField;
		},
		set_paneRowIndex: function VizHitInfo$set_PaneRowIndex(value) {
			this.$1$PaneRowIndexField = value;
		},
		get_regionCoordinates: function VizHitInfo$get_RegionCoordinates() {
			return this.$1$RegionCoordinatesField;
		},
		set_regionCoordinates: function VizHitInfo$set_RegionCoordinates(value) {
			this.$1$RegionCoordinatesField = value;
		},
		get_pageCoordinates: function VizHitInfo$get_PageCoordinates() {
			return this.$1$PageCoordinatesField;
		},
		set_pageCoordinates: function VizHitInfo$set_PageCoordinates(value) {
			this.$1$PageCoordinatesField = value;
		},
		get_result: function VizHitInfo$get_Result() {
			return this.$hitResult;
		}
	}, null, [tab.IVizHitInfo]);
	ss.initClass($tab_VizZoneFactory, $asm, {
		createPaneTableView: null,
		createPaneTableViewModel: function VizZoneFactory$CreatePaneTableViewModel(model) {
			return new $tab_PaneTableViewModel(model);
		},
		addVizDragHandler: function VizZoneFactory$AddVizDragHandler(vizDragOverride) {
			$tab_PaneTableView.addVizDragHandler(vizDragOverride);
		},
		addAsyncVizDragHandler: function VizZoneFactory$AddAsyncVizDragHandler(vizDragOverrideAsync) {
			$tab_PaneTableView.addAsyncVizDragHandler(vizDragOverrideAsync);
		},
		addVizDragApprover: function VizZoneFactory$AddVizDragApprover(vizDragApprover) {
			$tab_PaneTableView.addVizDragApprover(vizDragApprover);
		},
		computeVizScrollCapabilities: function VizZoneFactory$ComputeVizScrollCapabilities(model) {
			return $tab_PaneTableGeometryComputer.computeVizScrollCapabilities(model);
		}
	}, null, [tab.IVizZoneModule]);
	ss.initClass($tab_WorkerDoneEventArgs, $asm, {
		get_workerID: function WorkerDoneEventArgs$get_WorkerID() {
			return this.$workerID;
		},
		get_image: function WorkerDoneEventArgs$get_Image() {
			return this.$image;
		}
	}, ss.EventArgs);
	ss.initClass($tab_WorkerTimeoutEventArgs, $asm, {
		get_workerID: function WorkerTimeoutEventArgs$get_WorkerID() {
			return this.$workerID;
		}
	}, ss.EventArgs);
	ss.initClass($tab_ZoomComputer, $asm, {});
	(function() {
		$tab_$LeafletMapTemplate.$htmlTemplate = "<div><div class='tabLeafletMapHolder' /><div class='tabLeftBarnDoor' /><div class='tabRightBarnDoor' /></div>";
	})();
	(function() {
		$tab_$MapControlEventProperty.$mapControlType = 'MapControlType';
		$tab_$MapControlEventProperty.$elapsedTime = 'ElapsedTime';
		$tab_$MapControlEventProperty.$mapStyle = 'MapStyle';
		$tab_$MapControlEventProperty.$mapCode = 'MapCode';
		$tab_$MapControlEventProperty.$zoomLevel = 'ZoomLevel';
		$tab_$MapControlEventProperty.$washOut = 'WashOut';
		$tab_$MapControlEventProperty.$numRepeatBackground = 'NumRepeatBackground';
		$tab_$MapControlEventProperty.$allowLocalPanAndZoom = 'AllowLocalPanAndZoom';
		$tab_$MapControlEventProperty.$renderMode = 'RenderMode';
		$tab_$MapControlEventProperty.$hardwareConcurrency = 'HardwareConcurrency';
		$tab_$MapControlEventProperty.$renderer = 'Renderer';
	})();
	(function() {
		$tab_$MapsSearchViewTemplate.$htmlTemplate = "<div class='tabMapsSearchContainer'><div class='tabMapsSearchView'></div></div>";
	})();
	(function() {
		$tab_InteractionColorModel.defaultHighlightBgColor = new tab.ColorModel(245, 245, 171, 1);
		$tab_InteractionColorModel.defaultSelectionBgColor = new tab.ColorModel(140, 196, 211, 1);
		$tab_InteractionColorModel.defaultHighlightTextColor = new tab.ColorModel(0, 0, 0, 1);
		$tab_InteractionColorModel.defaultSelectionTextColor = new tab.ColorModel(0, 0, 0, 1);
		var $t1 = new $tab_InteractionColorModel();
		$t1.highlightBgColor = $tab_InteractionColorModel.defaultHighlightBgColor;
		$t1.selectionBgColor = $tab_InteractionColorModel.defaultSelectionBgColor;
		$t1.highlightTextColor = $tab_InteractionColorModel.defaultHighlightTextColor;
		$t1.selectionTextColor = $tab_InteractionColorModel.defaultSelectionTextColor;
		$tab_InteractionColorModel.defaultColors = $t1;
	})();
	(function() {
		$tab_DisplayList2DRenderer.$hoveredNodeTextStyle = 'rgb(0,0,0)';
		$tab_DisplayList2DRenderer.$hoveredNodeBackgroundStyle = 'rgb(245,245,245)';
		$tab_DisplayList2DRenderer.$scrollableXParts = ['x-labels', 'bottom-axis', 'top-axis'];
		$tab_DisplayList2DRenderer.$scrollableYParts = ['y-labels', 'left-axis', 'right-axis'];
		$tab_DisplayList2DRenderer.$turnOnHacksToLookPretty = true;
	})();
	(function() {
		$tab_AnnotationTelemetryUtil.annotationEventType = 'Annotations';
		$tab_AnnotationTelemetryUtil.annotationType = 'AnnotationType';
		$tab_AnnotationTelemetryUtil.annotationAction = 'Action';
		$tab_AnnotationTelemetryUtil.annotationActionFrom = 'ActionFrom';
		$tab_AnnotationTelemetryUtil.annotationCreateType = 'Create';
		$tab_AnnotationTelemetryUtil.annotationDeleteType = 'Delete';
		$tab_AnnotationTelemetryUtil.annotationMoveType = 'Move';
		$tab_AnnotationTelemetryUtil.annotationMovePointTargetType = 'Move Point Target';
		$tab_AnnotationTelemetryUtil.annotationResizeType = 'Resize';
		$tab_AnnotationTelemetryUtil.annotationMarkType = 'Mark';
		$tab_AnnotationTelemetryUtil.annotationAreaType = 'Area';
		$tab_AnnotationTelemetryUtil.annotationPointType = 'Point';
		$tab_AnnotationTelemetryUtil.annotationFromDelete = 'Delete Key';
		$tab_AnnotationTelemetryUtil.annotationFromDrag = 'Drag';
		$tab_AnnotationTelemetryUtil.annotationFromContextMenu = 'Context Menu';
	})();
	(function() {
		$tab_AnnotationVizContextMenuItemsHandler.deleteAnnotationMenuItem = 'Delete Annotation';
		$tab_AnnotationVizContextMenuItemsHandler.editAnnotationMenuItem = 'Edit Annotation';
	})();
	(function() {
		$tab_AnnotationSelectionChromeViewModel.resizeHandlerPre = 'tabAnnotationResizeHandler';
		$tab_AnnotationSelectionChromeViewModel.e = 'E';
		$tab_AnnotationSelectionChromeViewModel.w = 'W';
		$tab_AnnotationSelectionChromeViewModel.n = 'N';
		$tab_AnnotationSelectionChromeViewModel.s = 'S';
		$tab_AnnotationSelectionChromeViewModel.SE = 'SE';
		$tab_AnnotationSelectionChromeViewModel.SW = 'SW';
		$tab_AnnotationSelectionChromeViewModel.NE = 'NE';
		$tab_AnnotationSelectionChromeViewModel.NW = 'NW';
		$tab_AnnotationSelectionChromeViewModel.handlerTargetIcon = 'tabAnnotationHandlerIcon';
		$tab_AnnotationSelectionChromeViewModel.movePointTargetHandler = 'tabAnnotationPointTarget';
		$tab_AnnotationSelectionChromeViewModel.resizeHandlesArea = [$tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.SE, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.SW, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.NE, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.NW, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.e, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.w, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.n, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.s];
		$tab_AnnotationSelectionChromeViewModel.resizeHandlesPointAndMark = [$tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.e, $tab_AnnotationSelectionChromeViewModel.resizeHandlerPre + $tab_AnnotationSelectionChromeViewModel.w];
	})();
	(function() {
		$tab_AnnotationDragHandler.regionPadding = 2;
		$tab_AnnotationDragHandler.minWidth = 80;
	})();
	(function() {
		$tab_HitTestResult.$hitTypeMap = ss.mkdict(['no-hit', 0, 'area-hit', 1, 'near-hit', 2, 'exact-hit', 3]);
		$tab_HitTestResult.$visualPartMap = ss.mkdict(['annotations', 2, 'ref-lines', 4, 'trend-lines', 3, 'ref-bands', 4, 'marks', 7, 'mark-labels', 8]);
	})();
	(function() {
		$tab_CanvasTemplate.$htmlTemplate = "<canvas class='tabCanvas'></canvas>";
	})();
	(function() {
		$tab_GeometryUtil.halfPI = 0.5 * Math.PI;
		$tab_GeometryUtil.onePI = Math.PI;
		$tab_GeometryUtil.oneAndHalfPI = 1.5 * Math.PI;
		$tab_GeometryUtil.twoPI = 2 * Math.PI;
		$tab_GeometryUtil.$maxWedgeIntersectionAngle = Math.PI * 0.15;
	})();
	(function() {
		$tab_MarksRenderer.$chromeBorderThicknessOffset = 0.400000005960464;
		$tab_MarksRenderer.$white = 'rgb(255,255,255)';
	})();
	(function() {
		$tab_CircleShapeSelector.$divClassName = 'tvdrag_svg_div';
		$tab_CircleShapeSelector.$radiusClassName = 'circle_radius';
		$tab_CircleShapeSelector.$crosshairClassName = 'circle_crosshair';
		$tab_CircleShapeSelector.$crosshairSize = 4;
		$tab_CircleShapeSelector.$distanceReadoutClassName = 'tabDistanceReadout';
		$tab_CircleShapeSelector.$distanceReadoutTemplate = "<div class='tabDistanceReadout'></div>";
		$tab_CircleShapeSelector.$halfCrosshairTemplate = "<line class='circle_crosshair' x1='0' y1='0' x2='0' y2='0'></line>";
		$tab_CircleShapeSelector.$crosshairTemplate = "<line class='circle_crosshair' x1='0' y1='0' x2='0' y2='0'></line><line class='circle_crosshair' x1='0' y1='0' x2='0' y2='0'></line>";
		$tab_CircleShapeSelector.$radiusLineTemplate = "<line class='circle_radius'x1='0' y1='0' x2='0' y2='0'></line>";
		$tab_CircleShapeSelector.$htmlTemplate = "<div>\n                                                <svg class='selectionShape'>\n                                                    <circle class='tvdrag_svg_marquee'></circle><line class='circle_crosshair' x1='0' y1='0' x2='0' y2='0'></line><line class='circle_crosshair' x1='0' y1='0' x2='0' y2='0'></line><line class='circle_radius'x1='0' y1='0' x2='0' y2='0'></line></svg><div class='tabDistanceReadout'></div></div>";
	})();
	(function() {
		$tab_DownloadQueue.$maxNumWorkers = 2;
	})();
	(function() {
		$tab_FloatingToolbarButtonPressEventProperties.type = 'Viz_FloatingToolbar_ButtonPress';
		$tab_FloatingToolbarButtonPressEventProperties.buttonName = 'ButtonName';
	})();
	(function() {
		$tab_FloatingToolbarPositioningComponent.repositionTimeoutMs = 300;
	})();
	(function() {
		$tab_MapsSearchViewModel.$maxNumberOfSuggestions = 5;
	})();
	(function() {
		$tab_FloatingToolbarShowEventProperties.type = 'Viz_FloatingToolbar_Show';
		$tab_FloatingToolbarShowEventProperties.mapsSearchShown = 'MapsSearchShown';
		$tab_FloatingToolbarShowEventProperties.toolsShown = 'ToolsShown';
		$tab_FloatingToolbarShowEventProperties.panAvailable = 'PanAvailable';
		$tab_FloatingToolbarShowEventProperties.homeShown = 'HomeShown';
	})();
	(function() {
		$tab_GotoMyLocationButton.telemetryToolName = 'gotoMyLocation';
		$tab_GotoMyLocationButton.$centeringBoxRadiusInKm = 0.7;
		$tab_GotoMyLocationButton.$oneDegreeLatitudeAtEquatorInKm = 110.574;
		$tab_GotoMyLocationButton.$oneDegreeLongitudeAtEquatorInKm = 111.32;
		$tab_GotoMyLocationButton.$absolutePoleLatitude = 90;
		$tab_GotoMyLocationButton.$absoluteAntiMeridianLongitude = 180;
		$tab_GotoMyLocationButton.$getCurrentPositionRequestTimeout = 6000;
		$tab_GotoMyLocationButton.$buttonNotificationHorizontalPadding = 8;
		$tab_GotoMyLocationButton.$htmlTemplate = "<div class='tabGotoMyLocationButtonContainer'></div>";
	})();
	(function() {
		$tab_MapsSearchView.widgetClassName = 'tabMapsSearchView';
		$tab_MapsSearchView.$widgetClassNameCollapsed = 'tabMapsSearchViewCollapsed';
		$tab_MapsSearchView.$widgetContainerClassNameCollapsed = 'tabMapsSearchContainerCollapsed';
		$tab_MapsSearchView.widgetClassNameTranslucent = 'tabMapsSearchViewTranslucent';
		$tab_MapsSearchView.suggestionDisplayClassName = 'tabMapsSearchViewSuggestionDisplayName';
		$tab_MapsSearchView.suggestionActiveSearchTextClassName = 'tabMapsSearchViewSuggestionActiveSearchText';
		$tab_MapsSearchView.suggestionParentClassName = 'tabMapsSearchViewSuggestionParentName';
		$tab_MapsSearchView.queryDelayTimerMs = 200;
		$tab_MapsSearchView.suppressVizTooltipsAndOverlays = 'tabSuppressVizTooltipsAndOverlays';
		tab.ObjectRegistry.registerType($tab_MapsSearchView, $tab_MapsSearchView).call(null);
	})();
	(function() {
		$tab_FloatingToolbarContainerComponent.closeButtonContainerClass = 'tab-floating-toolbar-close-button-container';
		$tab_FloatingToolbarContainerComponent.closeButtonClass = 'tab-floating-toolbar-close-button';
		$tab_FloatingToolbarContainerComponent.toolButtonsRootClass = 'FloatingZoomToolbar';
		$tab_FloatingToolbarContainerComponent.toolButtonsContainerClass = 'fztButtonContainer';
		$tab_FloatingToolbarContainerComponent.selectionToolContainerClass = 'fztSelectionToolContainer';
		$tab_FloatingToolbarContainerComponent.toolFlyoutContainerClass = 'fztFlyOutContainer';
		$tab_FloatingToolbarContainerComponent.toolFlyoutButtonsClass = 'fztFlyOutButtons';
	})();
	(function() {
		$tab_FloatingZoomToolbar.$toolbarHtml = "<div class='FloatingZoomToolbar'></div>";
	})();
	(function() {
		$tab_PaneDrawInfo.shapeMarkStampingRatio = 32;
		$tab_PaneDrawInfo.$intColumnSuffix = '_int';
		$tab_PaneDrawInfo.$defaultFloatToIntMapFactor = 32767;
		$tab_PaneDrawInfo.$dimensionFloatToIntMapMultiplier = 100;
		$tab_PaneDrawInfo.$combinedFontTerms = ['font', 'font_size', 'font_style', 'font_weight'];
		$tab_PaneDrawInfo.$colorColumns = ['color', 'border_color', 'halo_color', 'selected_halo_color', 'highlighted_halo_color', 'selected_multi_prim_halo_color', 'text_style_color', 'background_color'];
		$tab_PaneDrawInfo.$columnsToConvertToXDomainCoords = ['x', 'x1', 'x_prev', 'x_next', 'cell_x'];
		$tab_PaneDrawInfo.$columnsToConvertToWidthDomainCoords = ['clip_width'];
		$tab_PaneDrawInfo.$columnsToConvertToYDomainCoords = ['y', 'y1', 'y_prev', 'y_next', 'cell_y'];
		$tab_PaneDrawInfo.$columnsToConvertToHeightDomainCoords = ['clip_height'];
		$tab_PaneDrawInfo.$noWorldOffsetArray = null;
		$tab_PaneDrawInfo.textAngleInRad = null;
		$tab_PaneDrawInfo.$floatColumnsMappedToInt = null;
	})();
	(function() {
		$tab_SceneInfo.$emptyRect = { x: 0, y: 0, w: 0, h: 0 };
	})();
	(function() {
		$tab_VisualPartsHitTest.visualPartNearHitTestExpansionPixels = 7;
	})();
	(function() {
		$tab_RefLineHitTestLink.$nearHitTestExpansion = 7;
		$tab_RefLineHitTestLink.$exactHitTestExpansion = 1;
	})();
	(function() {
		$tab_VizContextMenuItemsHandler.createMarkAnnotationMenuItem = 'Annotate Mark';
		$tab_VizContextMenuItemsHandler.createPointAnnotationMenuItem = 'Annotate Point';
		$tab_VizContextMenuItemsHandler.createAreaAnnotationMenuItem = 'Annotate Area';
	})();
	(function() {
		$tab_VisualListViewModel.propertyHoverNode = 'HoverNode';
	})();
	(function() {
		$tab_SmoothTooltipsOnboardingViewModel.twoFingerScrollOnboardingTipWasAcknowledgedCookie = 'twoFingerScrollOnboardingTipWasAcknowledged';
		$tab_SmoothTooltipsOnboardingViewModel.fadeInDurationMs = 100;
		$tab_SmoothTooltipsOnboardingViewModel.fadeOutDurationMs = 300;
		$tab_SmoothTooltipsOnboardingViewModel.fadeInDelayMs = 150;
		$tab_SmoothTooltipsOnboardingViewModel.fadeOutDelayMs = 1000;
	})();
	(function() {
		$tab_ZoomComputer.$zoomLevelSelectionTolerance = 0.05;
	})();
	(function() {
		$tab_PolyShapeSelector.$moveTo = 'M';
		$tab_PolyShapeSelector.$lineTo = 'L';
		$tab_PolyShapeSelector.$closePath = 'Z';
		$tab_PolyShapeSelector.$divClassName = 'tvdrag_svg_div';
		$tab_PolyShapeSelector.$htmlTemplate = "<div><svg class='selectionShape'><path class='tvdrag_svg_marquee'></path></svg></div>";
		$tab_PolyShapeSelector.$pauseTimeMS = 300;
	})();
	(function() {
		$tab_RectShapeSelector.$htmlTemplate = '<div></div>';
		$tab_RectShapeSelector.$divClassName = 'tvdrag';
		$tab_RectShapeSelector.$visibleShapeClassName = 'tvdrag_marquee';
	})();
	(function() {
		$tab_MapControlType.mapboxGLJS = 'MapboxGLJS';
		$tab_MapControlType.leaflet = 'Leaflet';
	})();
	(function() {
		$tab_MapControlTelemetry.$createMapDoneEvent = 'MapControl_CreateMap_Done';
	})();
	(function() {
		$tab_MapRenderType.client = 'Client';
		$tab_MapRenderType.server = 'Server';
	})();
	(function() {
		$tab_MapboxMapControl.overlayCanvasLayerId = 'overlay_canvas_layer';
		$tab_MapboxMapControl.overlayCanvasSourceId = 'overlay_canvas_source';
		$tab_MapboxMapControl.washoutLayerId = 'washout_layer';
		$tab_MapboxMapControl.dataLayerId = 'tableau_data_layer';
		$tab_MapboxMapControl.dataSourceId = 'tableau_data_source';
		$tab_MapboxMapControl.$urlHostRegExp = new RegExp('^https?://.*?\\.mapbox\\.com');
		$tab_MapboxMapControl.$urlAccessTokenRegExp = new RegExp('access_token=[-A-Za-z0-9_.]+');
		$tab_MapboxMapControl.$localCJKFontFamily = 'Arial, sans-serif';
		$tab_MapboxMapControl.$northWestBound = [-180, 85.051129];
		$tab_MapboxMapControl.$southEastBound = [180, -85.051129];
	})();
	(function() {
		$tab_LeafletMapControl.$maxAllowableZoomLevelForLeaflet = 100;
		$tab_LeafletMapControl.$leafletCssFile = '/css/leaflet.css';
		$tab_LeafletMapControl.$maxZoomTransitionWithAnimation = 2;
		$tab_LeafletMapControl.$spinWaitTimeForLeafletAnimation = 10;
		$tab_LeafletMapControl.$zoomDiffTolerance = 0.01;
		$tab_LeafletMapControl.$positionDiffTolerance = 8;
		$tab_LeafletMapControl.$leafletTouchingClass = 'leaflet-touching';
		$tab_LeafletMapControl.$northPole = { item1: 90, item2: 0 };
		$tab_LeafletMapControl.$southPole = { item1: -90, item2: 0 };
	})();
	(function() {
		var $t1 = [];
		$t1.push('left-axis');
		$t1.push('right-axis');
		$t1.push('y-labels');
		$t1.push('x-labels');
		$t1.push('top-axis');
		$t1.push('bottom-axis');
		$t1.push('title');
		$t1.push('caption');
		$t1.push('background');
		$tab_PaneTableViewModel.blackListVisualParts = $t1;
		$tab_PaneTableViewModel.zoomToolbarTopOffset = 10;
		$tab_PaneTableViewModel.vizNavigationSettingPropertyName = 'vizNavigationSetting';
		$tab_PaneTableViewModel.borderHighlightPropertyName = 'borderHighlight';
		$tab_PaneTableViewModel.imageLoadedPropertyName = 'images';
		$tab_PaneTableViewModel.sceneChangedPropertyName = 'scene';
	})();
	(function() {
		$tab_PaneTable2DRenderer.$displayListSelectedColorBlack = 'rgba(0,0,0,1)';
		$tab_PaneTable2DRenderer.$defaultBackgroundColor = 'rgba(255,255,255,255)';
		$tab_PaneTable2DRenderer.$renderPassOrder = ['normalUnderPass', 'normalOnPass', 'highlightedUnderPass', 'highlightedOnPass', 'selectedUnderPass', 'selectedOnPass'];
		$tab_PaneTable2DRenderer.$drawRoleOrder = ['background', 'underMark', 'marks', 'underLabel', 'label', 'foreground'];
	})();
	(function() {
		$tab_TiledViewerRegion.windowLog = null;
		$tab_TiledViewerRegion.paneBorderMaskSize = 2;
		$tab_TiledViewerRegion.canvasBorderPixels = 1;
		$tab_TiledViewerRegion.zoomAnimationTime = 777;
		$tab_TiledViewerRegion.minZoomAnimationTime = 500;
		$tab_TiledViewerRegion.zoomToAnchorAnimationTime = 500;
	})();
	(function() {
		$tab_HitTestChain.$localTapHitTestOrder = [0, 3, 2, 1];
		$tab_HitTestChain.$localHoverHitTestOrder = [3, 2, 1, 0];
		$tab_HitTestChain.$localStoryHitTestOrder = [3, 2, 1];
		$tab_HitTestChain.$serverHitTestOrder = [0];
	})();
	(function() {
		$tab_HitTestDebugger.$instance = null;
		$tab_HitTestDebugger.$binAlternation = 0;
	})();
	(function() {
		$tab_VizHitInfo.$staticId = 0;
	})();
	(function() {
		$tab_VizHitTestDebouncer.hitTestDelay = 250;
		$tab_VizHitTestDebouncer.maxHitTestDistance = 20;
	})();
	(function() {
		$tab_MapAttributionTemplate.$htmlTemplate = "<div class='tabMapAttribution'><div class='tabMapAttributionBackground' /><a class='tabMapAttributionLink'></a><a class='tabMapAttributionLink2'></a></div>";
	})();
	(function() {
		$tab_PaneTableOverlayView.$dirtyRectPadding = 3;
		$tab_PaneTableOverlayView.$maxRenderTime = 145;
		$tab_PaneTableOverlayView.$debugMode = false;
	})();
	(function() {
		$tab_PaneTableTemplate.$bordersHtml = "<div class='tvViewportBorder tvLeftBorder' /><div class='tvViewportBorder tvRightBorder' /><div class='tvViewportBorder tvTopBorder' /><div class='tvViewportBorder tvBottomBorder' />";
	})();
	(function() {
		$tab_PaneTableViewRegionParts.scrollableXRegions = ['xheader', 'bottomaxis', 'topaxis', 'viz'];
		$tab_PaneTableViewRegionParts.scrollableYRegions = ['yheader', 'leftaxis', 'rightaxis', 'viz'];
		$tab_PaneTableViewRegionParts.scrollableRegions = ['xheader', 'bottomaxis', 'topaxis', 'yheader', 'leftaxis', 'rightaxis', 'viz'];
		$tab_PaneTableViewRegionParts.scrollableTableRegions = ['xheader', 'bottomaxis', 'topaxis', 'yheader', 'leftaxis', 'rightaxis', 'viz', 'uleft', 'uright', 'lleft', 'lright'];
		$tab_PaneTableViewRegionParts.axisRegions = ['leftaxis', 'rightaxis', 'bottomaxis', 'topaxis'];
		$tab_PaneTableViewRegionParts.headerRegions = ['yheader', 'xheader', 'leftaxis', 'rightaxis', 'bottomaxis', 'topaxis', 'uleft', 'uright'];
		$tab_PaneTableViewRegionParts.regionsThatMightContainCategoricalHeader = ['yheader', 'xheader', 'bottomaxis', 'topaxis'];
		$tab_PaneTableViewRegionParts.nonVizContentRegions = ['yheader', 'leftaxis', 'rightaxis', 'xheader', 'bottomaxis', 'topaxis'];
		$tab_PaneTableViewRegionParts.contentRegions = ['yheader', 'leftaxis', 'rightaxis', 'xheader', 'bottomaxis', 'topaxis', 'viz'];
		$tab_PaneTableViewRegionParts.regionsThatClearSelectionOnTap = ['uleft', 'uright', 'lleft', 'lright', 'caption'];
		$tab_PaneTableViewRegionParts.spacerRegions = ['uleft', 'uright', 'lleft', 'lright'];
	})();
	(function() {
		$tab_TooltipResponsiveMode.$uniqueEventTypeCounter = 0;
	})();
	(function() {
		$tab_PaneTableView.suppressVizTooltipsAndOverlays = 'tabSuppressVizTooltipsAndOverlays';
		$tab_PaneTableView.titleClass = 'tab-tvTitle';
		$tab_PaneTableView.$captionTopPadding = 8;
		$tab_PaneTableView.$dragOverlayDrawThrottleMs = 30;
		$tab_PaneTableView.$asyncVizDragHandlers = [];
		$tab_PaneTableView.$vizDragHandlers = [];
		$tab_PaneTableView.$vizDragApprovers = [];
	})();
	(function() {
		$tab_RuntimeUIModule.$module = null;
		tab.ModuleManager.register($tab_IRuntimeUIModule).call(null, 'RuntimeUI', null).andMarkAsAlreadyLoadedInGlobalNamespace();
	})();
	(function() {
		$tab_SmoothTooltipsOnboardingComponent.rootElementClass = 'tab-smooth-tooltips-tip';
		$tab_SmoothTooltipsOnboardingComponent.textClass = 'tip-text';
		$tab_SmoothTooltipsOnboardingComponent.transitionEndFailSafeTimeoutMs = 200;
	})();
})();
// END VizZone
